<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>Seorenn</title>
    <link>https://seorenn.github.io</link>
    <description>Seorenn Notes and Logs</description>
    <atom:link href="https://seorenn.github.io" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>https://seorenn.github.io</generator>
    <image>
      <url>https://seorenn.github.io/static/seorenn-symbol.png</url>
      <title>Seorenn</title>
      <link>https://seorenn.github.io</link>
    </image>
    <language>ko</language>
    <lastBuildDate>Sun, 21 Jul 2024 21:19:10 +0900</lastBuildDate>
    <item>
      <title>한 주간의 애플 소식들 24-07-21</title>
      <link>https://seorenn.github.io/log/20240721-00.html</link>
      <description>&lt;h2&gt;소프트웨어 릴리즈&lt;/h2&gt;
&lt;p&gt;차세대 OS들의 공개 베타가 슬슬 시작되고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15 Sequoia public beta 1&lt;/li&gt;
&lt;li&gt;iOS 18 public beta 1&lt;/li&gt;
&lt;li&gt;iPadOS 18 public beta 1&lt;/li&gt;
&lt;li&gt;watchOS 11 public beta 1&lt;/li&gt;
&lt;li&gt;tvOS 18 public beta 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;앞서 공개되었던 개발자 베타 3에서 아래의 OS들은 빌드 번호가 갱신되어서 새로 올라왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15 Sequoia beta 3&lt;/li&gt;
&lt;li&gt;iOS 18 beta 3&lt;/li&gt;
&lt;li&gt;iPadOS 18 beta 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 버전들은 이모티콘 관련 기능에 문제가 있는지 최신 업데이트 사항이 제거되고 이전 beta 2 시절의 내용으로 돌아간 듯하다.&lt;/p&gt;
&lt;p&gt;그 외에 현재 메이저 버전의 마이너 업데이트의 네 번째 개발자 베타 버전들도 공개되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS 14.6 beta 4&lt;/li&gt;
&lt;li&gt;iOS 17.6 beta 4&lt;/li&gt;
&lt;li&gt;iPadOS 17.6 beta 4&lt;/li&gt;
&lt;li&gt;visionOS 1.3 beta 4&lt;/li&gt;
&lt;li&gt;watchOS 10.6 beta 4&lt;/li&gt;
&lt;li&gt;tvOS 17.6 beta 4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그 외에 아래의 릴리즈 소식들이 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Safari Technology Preview 199&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;일반적인 소식들&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;이제 게임 뿐만 아니라 에뮬도?&lt;/strong&gt;&lt;br/&gt;
애플이 PC 에뮬레이터 앱을 승인했다. 지난 '저작권 사유로 거부되었다'는 소식이 전해진 이후로 이해할 수 없다는 평가가 많았었는데 그래서인지 애플이 자세를 바꾼 모양이다. 어쨌든 이제 게임 에뮬레이터 뿐만 아니라 PC 에뮬레이터도 앱스토어에 대거 진출할 듯하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iOS 18&lt;/strong&gt;&lt;br/&gt;
iOS 18의 사진 앱에 '복구된 앨범' 기능이 생기는 듯하다. 여기에는 손실되거나 훼손된 사진이 복구되어 분류되는 것으로 추측된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI&lt;/strong&gt;&lt;br/&gt;
애플이 최근 Youtube 자막 등의 콘텐츠를 무단으로 AI 학습에 사용했다는 의혹이 제기되었다. 이에 대해 애플은 OpenELM 학습은 연구 목적이며 자사의 애플지능(Apple Intelligence) 서비스와는 관련이 없다고 밝혔다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AAPL&lt;/strong&gt;&lt;br/&gt;
애플의 인도 매출이 33% 가량 급증했다고 한다. 애플(AAPL)의 시가총액은 3.62조 달러를 돌파하며 다시 세계에서 가장 가치있는 기업이 되었다. 다만 iPhone의 매출 서프라이즈를 점치는 컨센서스가 많은 와중에 애플이 정작 iPhone 16 주문을 늘리지는 않을 것이라는 루머도 전해지고 있다.&lt;/p&gt;
&lt;h2&gt;기타 루머 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;iPhone 17에는 TSMC의 차세대 2nm 공정으로 제작된 칩이 사용될 가능성이 있다는 루머가 나왔다가 다시 가능성이 낮다는 루머도 나왔다.&lt;/li&gt;
&lt;li&gt;M5가 탑재될 맥북 모델들에는 신형 컴팩트 카메라 모듈이 사용될 듯하다.&lt;/li&gt;
&lt;li&gt;iPhone의 공간 절약형 내부 디자인 개발이 연기되어 iPhone 17에서나 적용될 가능성이 있는 모양이다.&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;h2&gt;소프트웨어 릴리즈&lt;/h2&gt;
&lt;p&gt;차세대 OS들의 공개 베타가 슬슬 시작되고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15 Sequoia public beta 1&lt;/li&gt;
&lt;li&gt;iOS 18 public beta 1&lt;/li&gt;
&lt;li&gt;iPadOS 18 public beta 1&lt;/li&gt;
&lt;li&gt;watchOS 11 public beta 1&lt;/li&gt;
&lt;li&gt;tvOS 18 public beta 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;앞서 공개되었던 개발자 베타 3에서 아래의 OS들은 빌드 번호가 갱신되어서 새로 올라왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15 Sequoia beta 3&lt;/li&gt;
&lt;li&gt;iOS 18 beta 3&lt;/li&gt;
&lt;li&gt;iPadOS 18 beta 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 버전들은 이모티콘 관련 기능에 문제가 있는지 최신 업데이트 사항이 제거되고 이전 beta 2 시절의 내용으로 돌아간 듯하다.&lt;/p&gt;
&lt;p&gt;그 외에 현재 메이저 버전의 마이너 업데이트의 네 번째 개발자 베타 버전들도 공개되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS 14.6 beta 4&lt;/li&gt;
&lt;li&gt;iOS 17.6 beta 4&lt;/li&gt;
&lt;li&gt;iPadOS 17.6 beta 4&lt;/li&gt;
&lt;li&gt;visionOS 1.3 beta 4&lt;/li&gt;
&lt;li&gt;watchOS 10.6 beta 4&lt;/li&gt;
&lt;li&gt;tvOS 17.6 beta 4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그 외에 아래의 릴리즈 소식들이 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Safari Technology Preview 199&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;일반적인 소식들&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;이제 게임 뿐만 아니라 에뮬도?&lt;/strong&gt;&lt;br/&gt;
애플이 PC 에뮬레이터 앱을 승인했다. 지난 '저작권 사유로 거부되었다'는 소식이 전해진 이후로 이해할 수 없다는 평가가 많았었는데 그래서인지 애플이 자세를 바꾼 모양이다. 어쨌든 이제 게임 에뮬레이터 뿐만 아니라 PC 에뮬레이터도 앱스토어에 대거 진출할 듯하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iOS 18&lt;/strong&gt;&lt;br/&gt;
iOS 18의 사진 앱에 '복구된 앨범' 기능이 생기는 듯하다. 여기에는 손실되거나 훼손된 사진이 복구되어 분류되는 것으로 추측된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI&lt;/strong&gt;&lt;br/&gt;
애플이 최근 Youtube 자막 등의 콘텐츠를 무단으로 AI 학습에 사용했다는 의혹이 제기되었다. 이에 대해 애플은 OpenELM 학습은 연구 목적이며 자사의 애플지능(Apple Intelligence) 서비스와는 관련이 없다고 밝혔다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AAPL&lt;/strong&gt;&lt;br/&gt;
애플의 인도 매출이 33% 가량 급증했다고 한다. 애플(AAPL)의 시가총액은 3.62조 달러를 돌파하며 다시 세계에서 가장 가치있는 기업이 되었다. 다만 iPhone의 매출 서프라이즈를 점치는 컨센서스가 많은 와중에 애플이 정작 iPhone 16 주문을 늘리지는 않을 것이라는 루머도 전해지고 있다.&lt;/p&gt;
&lt;h2&gt;기타 루머 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;iPhone 17에는 TSMC의 차세대 2nm 공정으로 제작된 칩이 사용될 가능성이 있다는 루머가 나왔다가 다시 가능성이 낮다는 루머도 나왔다.&lt;/li&gt;
&lt;li&gt;M5가 탑재될 맥북 모델들에는 신형 컴팩트 카메라 모듈이 사용될 듯하다.&lt;/li&gt;
&lt;li&gt;iPhone의 공간 절약형 내부 디자인 개발이 연기되어 iPhone 17에서나 적용될 가능성이 있는 모양이다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240721-00.html</guid>
      <pubDate>Sun, 21 Jul 2024 21:18:00 +0900</pubDate>
    </item>
    <item>
      <title>토스증권 VS KB증권, WTS 유사성 분쟁?</title>
      <link>https://seorenn.github.io/log/20240720-00.html</link>
      <description>&lt;p&gt;뉴스 피드를 읽다 아주 익숙한 단어가 보였다. 제목이 무려 'KB증권 VS 토스증권, WTS 유사성 두고 법적분쟁'이다. 정말이지 군침이 도는 읽고 싶은 제목이다. 그러니 링크를 클릭해 볼 수밖에 없었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;KB증권 측은 19일 “토스증권 WTS의 사용자인터페이스(UI)와 사용자경험(UX)과 관련 부분이 자사 WTS인 ‘M-able와이드’와 유사한 면이 많다고 판단했다”며 가처분 신청을 제기했다고 밝혔다. (&lt;a href="https://www.edaily.co.kr/News/Read?newsId=03079926638956160&amp;amp;mediaCodeNo=257" target="_blank"&gt;출처📎&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;둘 다 주력 WTS로 사용하는 입장에서는 KB증권에겐 좀 미안하지만 KB증권이 주장하는 바를 전혀 이해할 수가 없다. 이 둘은 추구하는 UX도 다르고 그래서 UI도 다르고 기능성 조차도 다르다. 닮았다고 해봤자 다크모드 색상 팔레트 정도가 비슷할 뿐이다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="KB증권의 WTS인 마블와이드" src="../upload/202407202340-cfc6417e.png" /&gt;
&lt;em&gt;KB증권의 WTS인 마블와이드는 배치가 꽤 자유로운 편이지만 일부 불편하고 문제점도 많다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;둘 중 선호하는 것 하나를 꼽으라면 고민할 것도 없이 토스증권의 WTS를 꼽고 싶다. 상대적으로 편하고 미려하고 빠르고 정보의 질도 더 좋다. 비교할 걸 비교해야 할 텐데 KB증권 측은 무슨 생각으로 이러는 것인가 개인적으로는 이해가 잘 안 될 정도다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="토스증권 WTS" src="../upload/202407202341-acf345a9.png" /&gt;
&lt;em&gt;토스증권의 WTS는 자유도가 약간 떨어지지만 UX를 잘 따른 편리한 UI 구성을 갖추고 있다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;물론 이 사건과는 별개로 토스증권이든 KB증권이든 모두 응원한다. WTS를 내놓았다는 것만으로도 충분히 호감가는 증권사다. 그저 좀 더 사이좋게 지냈으면 좋겠다. 물론 맥 앱을 내놓은 한국투자증권도 응원한다. 반쪽짜리 WTS만 제공하는 미래에셋증권이나 쓸 수 없는 쓰레기 같은 키움증권에 비하면 선녀 같은 증권사들이다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;뉴스 피드를 읽다 아주 익숙한 단어가 보였다. 제목이 무려 'KB증권 VS 토스증권, WTS 유사성 두고 법적분쟁'이다. 정말이지 군침이 도는 읽고 싶은 제목이다. 그러니 링크를 클릭해 볼 수밖에 없었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;KB증권 측은 19일 “토스증권 WTS의 사용자인터페이스(UI)와 사용자경험(UX)과 관련 부분이 자사 WTS인 ‘M-able와이드’와 유사한 면이 많다고 판단했다”며 가처분 신청을 제기했다고 밝혔다. (&lt;a href="https://www.edaily.co.kr/News/Read?newsId=03079926638956160&amp;amp;mediaCodeNo=257" target="_blank"&gt;출처📎&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;둘 다 주력 WTS로 사용하는 입장에서는 KB증권에겐 좀 미안하지만 KB증권이 주장하는 바를 전혀 이해할 수가 없다. 이 둘은 추구하는 UX도 다르고 그래서 UI도 다르고 기능성 조차도 다르다. 닮았다고 해봤자 다크모드 색상 팔레트 정도가 비슷할 뿐이다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="KB증권의 WTS인 마블와이드" src="../upload/202407202340-cfc6417e.png" /&gt;
&lt;em&gt;KB증권의 WTS인 마블와이드는 배치가 꽤 자유로운 편이지만 일부 불편하고 문제점도 많다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;둘 중 선호하는 것 하나를 꼽으라면 고민할 것도 없이 토스증권의 WTS를 꼽고 싶다. 상대적으로 편하고 미려하고 빠르고 정보의 질도 더 좋다. 비교할 걸 비교해야 할 텐데 KB증권 측은 무슨 생각으로 이러는 것인가 개인적으로는 이해가 잘 안 될 정도다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="토스증권 WTS" src="../upload/202407202341-acf345a9.png" /&gt;
&lt;em&gt;토스증권의 WTS는 자유도가 약간 떨어지지만 UX를 잘 따른 편리한 UI 구성을 갖추고 있다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;물론 이 사건과는 별개로 토스증권이든 KB증권이든 모두 응원한다. WTS를 내놓았다는 것만으로도 충분히 호감가는 증권사다. 그저 좀 더 사이좋게 지냈으면 좋겠다. 물론 맥 앱을 내놓은 한국투자증권도 응원한다. 반쪽짜리 WTS만 제공하는 미래에셋증권이나 쓸 수 없는 쓰레기 같은 키움증권에 비하면 선녀 같은 증권사들이다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240720-00.html</guid>
      <pubDate>Sat, 20 Jul 2024 23:44:00 +0900</pubDate>
    </item>
    <item>
      <title>Swift에서 딜레이 후 코드 호출하기</title>
      <link>https://seorenn.github.io/article/swift-run-after-delay.html</link>
      <description>&lt;p&gt;이 글에서는 Swift에서 UI를 멈추지 않게 하면서 특정 시간 동안 기다린 후 비동기로 코드를 실행시키는 방법 일부를 정리한다. 모든 방법이 아닌 개인적인 선호로 골랐다는 점에 주의하자.&lt;/p&gt;
&lt;h2&gt;타이머를 사용해 딜레이 후 호출하기&lt;/h2&gt;
&lt;p&gt;어쩌면 가장 직관적인 방법으로 &lt;code&gt;Timer&lt;/code&gt;를 이용하는 방법이 있다. Objective-C에서는 &lt;code&gt;NSTimer&lt;/code&gt;라 불리는 클래스와 동일하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;Timer.scheduledTimer(withTimeInterval: 3, repeats: false) { timer in
    print(&amp;quot;3 seconds have passed&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;타이머를 생성해서 돌리는 방법은 여러가지가 있지만 위의 방식이 가장 편한 것 같았다. 필요하다면 반복(repeats)도 지정할 수 있으니 딜레이 말고도 여러 용도로 쓸 수도 있다.&lt;/p&gt;
&lt;h2&gt;GCD를 이용해 딜레이 후 호출하기&lt;/h2&gt;
&lt;p&gt;GCD(Grand Central Dispatch)의 디스패치 큐에는 &lt;code&gt;asyncAfter&lt;/code&gt;라는 용도에 딱 맞는 메서드가 제공된다. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
    print(&amp;quot;3 seconds have passed&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;asyncAfter&lt;/code&gt;의 경우 딜레이 시간을 정의할 때 약간 난해할 수도 있는데 &lt;code&gt;DispatchTime.now()&lt;/code&gt;를 알고 있다면 크게 어려울 것 없이 쓸 수 있다.&lt;/p&gt;
&lt;p&gt;다만 위 코드는 메인 스레드에서 동작하는 만큼 동작하는 코드에 따라 UI에 영향을 줄 수도 있으니 아래와 같이 글로벌 큐를 이용하는 방식이 적절하지 않을까 생각된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;DispatchQueue.global().asyncAfter(deadline: .now() + 3) {
    DispatchQueue.main.async {
        print(&amp;quot;3 seconds have passed&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 기다리는 동안 다른 일을 더 해도 UI에 큰 무리를 안 주면서 원하는 대로 동작한다. 다만 UI에 영향을 끼치는 코드는 메인 스레드에서 돌아가도록 주의해야 하는 점은 잊지 말자.&lt;/p&gt;
&lt;p&gt;물론 위의 방식들이 정석에 가깝지만, 좀 더 단순하게 하려면 아래와 같이 그냥 쉬었다가(sleep) 하는 방법도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;DispatchQueue.global().async {
    Thread.sleep(forTimeInterval: 3)
    DispatchQueue.main.async {
        print(&amp;quot;3 seconds have passed&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;글로벌 디스패치큐는 백그라운드 스레드에서 돌아가기 때문에 사용할 수 있는 단순한 코드다. 사람에 따라 '무식한' 방법이라고 평가할 수도 있겠지만 어떻게 보면 특징이나 용도를 잘 활용한 기능으로 볼 수도 있어서 '단순한' 방법이라 표현하는 게 맞을 것 같다. 어쨌든 잘 동작하고 별 문제도 없으니 말이다.&lt;/p&gt;
&lt;h2&gt;Task&lt;/h2&gt;
&lt;p&gt;Swift Concurrency 지원으로 추가된 비동기 루틴을 지원하는 &lt;code&gt;Task&lt;/code&gt;를 활용하면 역시 쉬었다가 처리하는 방식의 '단순한' 방법을 쓸 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;Task {
    try await Task.sleep(nanoseconds: 3000000000)
    print(&amp;quot;3 seconds have passed&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Task&lt;/code&gt; 기반은 취소가 가능하다는 장점이 있다. 태스크 취소를 하려면 아래와 같이 해당 태스크 인스턴스에서 &lt;code&gt;cancel()&lt;/code&gt; 메서드를 호출해 주면 된다. 다만 이 글의 주제에서 벗어나기 때문에 더 자세한 소개는 생략한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;let delayedTask = Task {
    try await Task.sleep(nanoseconds: 300000000000)
    print(&amp;quot;300 seconds have passed&amp;quot;)
}

...

// 해당 태스크를 취소해야 할 필요가 있을 때
delayedTask.cancel()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;태스크 내에서의 딜레이(sleep) 명령으로 &lt;code&gt;Thread.sleep()&lt;/code&gt;을 쓸 수 있는지는 잘 모르겠지만, 취소를 위해서는 반드시 &lt;code&gt;Task.sleep()&lt;/code&gt;을 써야 한다는 것 정도만 알아두자.&lt;/p&gt;
&lt;h2&gt;사족&lt;/h2&gt;
&lt;p&gt;GCD를 이용할 수 있으니 당연히 Thread나 OperationQueue를 이용할 수도 있지 않겠나라고 할 수도 있는데 맞다. 사실 이 둘도 위의 예와 거의 동일한 동작을 만들 수 있다. 하지만 가장 심플한 예는 아무래도 위에서 거론한 방식들 같다. 즉 이 외에도 여러 방법이 있을 수도 있으니 상황에 맞는 특수한 방법은 직접 찾아보자.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;이 글에서는 Swift에서 UI를 멈추지 않게 하면서 특정 시간 동안 기다린 후 비동기로 코드를 실행시키는 방법 일부를 정리한다. 모든 방법이 아닌 개인적인 선호로 골랐다는 점에 주의하자.&lt;/p&gt;
&lt;h2&gt;타이머를 사용해 딜레이 후 호출하기&lt;/h2&gt;
&lt;p&gt;어쩌면 가장 직관적인 방법으로 &lt;code&gt;Timer&lt;/code&gt;를 이용하는 방법이 있다. Objective-C에서는 &lt;code&gt;NSTimer&lt;/code&gt;라 불리는 클래스와 동일하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;Timer.scheduledTimer(withTimeInterval: 3, repeats: false) { timer in
    print(&amp;quot;3 seconds have passed&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;타이머를 생성해서 돌리는 방법은 여러가지가 있지만 위의 방식이 가장 편한 것 같았다. 필요하다면 반복(repeats)도 지정할 수 있으니 딜레이 말고도 여러 용도로 쓸 수도 있다.&lt;/p&gt;
&lt;h2&gt;GCD를 이용해 딜레이 후 호출하기&lt;/h2&gt;
&lt;p&gt;GCD(Grand Central Dispatch)의 디스패치 큐에는 &lt;code&gt;asyncAfter&lt;/code&gt;라는 용도에 딱 맞는 메서드가 제공된다. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
    print(&amp;quot;3 seconds have passed&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;asyncAfter&lt;/code&gt;의 경우 딜레이 시간을 정의할 때 약간 난해할 수도 있는데 &lt;code&gt;DispatchTime.now()&lt;/code&gt;를 알고 있다면 크게 어려울 것 없이 쓸 수 있다.&lt;/p&gt;
&lt;p&gt;다만 위 코드는 메인 스레드에서 동작하는 만큼 동작하는 코드에 따라 UI에 영향을 줄 수도 있으니 아래와 같이 글로벌 큐를 이용하는 방식이 적절하지 않을까 생각된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;DispatchQueue.global().asyncAfter(deadline: .now() + 3) {
    DispatchQueue.main.async {
        print(&amp;quot;3 seconds have passed&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 기다리는 동안 다른 일을 더 해도 UI에 큰 무리를 안 주면서 원하는 대로 동작한다. 다만 UI에 영향을 끼치는 코드는 메인 스레드에서 돌아가도록 주의해야 하는 점은 잊지 말자.&lt;/p&gt;
&lt;p&gt;물론 위의 방식들이 정석에 가깝지만, 좀 더 단순하게 하려면 아래와 같이 그냥 쉬었다가(sleep) 하는 방법도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;DispatchQueue.global().async {
    Thread.sleep(forTimeInterval: 3)
    DispatchQueue.main.async {
        print(&amp;quot;3 seconds have passed&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;글로벌 디스패치큐는 백그라운드 스레드에서 돌아가기 때문에 사용할 수 있는 단순한 코드다. 사람에 따라 '무식한' 방법이라고 평가할 수도 있겠지만 어떻게 보면 특징이나 용도를 잘 활용한 기능으로 볼 수도 있어서 '단순한' 방법이라 표현하는 게 맞을 것 같다. 어쨌든 잘 동작하고 별 문제도 없으니 말이다.&lt;/p&gt;
&lt;h2&gt;Task&lt;/h2&gt;
&lt;p&gt;Swift Concurrency 지원으로 추가된 비동기 루틴을 지원하는 &lt;code&gt;Task&lt;/code&gt;를 활용하면 역시 쉬었다가 처리하는 방식의 '단순한' 방법을 쓸 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;Task {
    try await Task.sleep(nanoseconds: 3000000000)
    print(&amp;quot;3 seconds have passed&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Task&lt;/code&gt; 기반은 취소가 가능하다는 장점이 있다. 태스크 취소를 하려면 아래와 같이 해당 태스크 인스턴스에서 &lt;code&gt;cancel()&lt;/code&gt; 메서드를 호출해 주면 된다. 다만 이 글의 주제에서 벗어나기 때문에 더 자세한 소개는 생략한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;let delayedTask = Task {
    try await Task.sleep(nanoseconds: 300000000000)
    print(&amp;quot;300 seconds have passed&amp;quot;)
}

...

// 해당 태스크를 취소해야 할 필요가 있을 때
delayedTask.cancel()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;태스크 내에서의 딜레이(sleep) 명령으로 &lt;code&gt;Thread.sleep()&lt;/code&gt;을 쓸 수 있는지는 잘 모르겠지만, 취소를 위해서는 반드시 &lt;code&gt;Task.sleep()&lt;/code&gt;을 써야 한다는 것 정도만 알아두자.&lt;/p&gt;
&lt;h2&gt;사족&lt;/h2&gt;
&lt;p&gt;GCD를 이용할 수 있으니 당연히 Thread나 OperationQueue를 이용할 수도 있지 않겠나라고 할 수도 있는데 맞다. 사실 이 둘도 위의 예와 거의 동일한 동작을 만들 수 있다. 하지만 가장 심플한 예는 아무래도 위에서 거론한 방식들 같다. 즉 이 외에도 여러 방법이 있을 수도 있으니 상황에 맞는 특수한 방법은 직접 찾아보자.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/swift-run-after-delay.html</guid>
      <pubDate>Fri, 19 Jul 2024 14:48:00 +0900</pubDate>
    </item>
    <item>
      <title>체코 원전 잭팟이라더니 주가는 왜 비실거릴까?</title>
      <link>https://seorenn.github.io/log/20240718-00.html</link>
      <description>&lt;p&gt;오랜만에 한국 원자력 수출에 좋은 소식이 떴다. 체코 원전 수주 소식이 들려온 것이다. 최소 15조 원 이상의 가치라며 말이다.&lt;/p&gt;
&lt;p&gt;그런데 정작 수주 소식이 들리자 관련 기업들의 주가는 호들갑은 커녕 차익실현 분위기가 강하다. 정확히 말해서 오전 까지는 분위기가 참 좋아 보였는데 오후가 되니 급격하게 사그라들었다고 보는 게 맞을 것 같다.&lt;/p&gt;
&lt;p&gt;일단 확실하게 알아야 할 것은 아직 '수주'가 아니라는 점이다. 정확히 말해 한국 기업들이 우선협상대상자가 되었다는 것이고 이제 체코 정부와 1:1로 협상해야 한다는 이야기다. 언론에서 24조 원 어치이니 최소 15조 원 이라니 뭐라니 하는 표현은 다 이유가 있는 것이었다. 물론 우선협상대상자가 되면 이후 별 문제 없으면 계약으로 진행된다고 볼 수는 있다. 뒤엎기에는 좀 멀리 간 것이니 말이다.&lt;/p&gt;
&lt;p&gt;또 한가지 문제는 바로 원전의 사이클이 너무 길다는 것이다. 원전 건설에는 4~5년 혹은 그 이상을 바라봐야 할 지도 모를 초장기 사업이다. 조선도 길다고 하는데 원전은 그 이상이니 실제로 돈이 되려면 오랜 시간이 걸릴 지도 모른다.&lt;/p&gt;
&lt;p&gt;따라서 이번 우선협상대상자 선정 소식 만으로 주가가 폭등하는 것 자체가 이상한 것이긴 하다. 그저 수주 가능성이 테마가 되었고 그 테마가 끝난 것이라 생각된다.&lt;/p&gt;
&lt;p&gt;물론 그렇다고 해도 모멘텀이 완전히 사라진 건 아닐 것이다. 그게 실적으로 나타나려면 오래 걸리니 조정이 왔을 때 담아놓고 기다리면 수익으로 이어질 가능성은 높을 것 같다. 중간에 별 삽질만 없다면 말이다.&lt;/p&gt;
&lt;p&gt;그런데 SMR은 과연 괜찮을까? 알려진 바로 모듈형의 경우 짧으면 1년 정도가 걸린다고 하니 SMR 쪽이 압도적으로 짧기는 하다. 문제가 있다면 아직 기술 개발 중이라는 점이겠지만 말이다.&lt;/p&gt;
&lt;p&gt;어쨌거나 추측성 이야기이니 너무 심각하게 보진 말자. 그리고 체코 원전 사업이 잘 진행 되었으면 좋겠다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;오랜만에 한국 원자력 수출에 좋은 소식이 떴다. 체코 원전 수주 소식이 들려온 것이다. 최소 15조 원 이상의 가치라며 말이다.&lt;/p&gt;
&lt;p&gt;그런데 정작 수주 소식이 들리자 관련 기업들의 주가는 호들갑은 커녕 차익실현 분위기가 강하다. 정확히 말해서 오전 까지는 분위기가 참 좋아 보였는데 오후가 되니 급격하게 사그라들었다고 보는 게 맞을 것 같다.&lt;/p&gt;
&lt;p&gt;일단 확실하게 알아야 할 것은 아직 '수주'가 아니라는 점이다. 정확히 말해 한국 기업들이 우선협상대상자가 되었다는 것이고 이제 체코 정부와 1:1로 협상해야 한다는 이야기다. 언론에서 24조 원 어치이니 최소 15조 원 이라니 뭐라니 하는 표현은 다 이유가 있는 것이었다. 물론 우선협상대상자가 되면 이후 별 문제 없으면 계약으로 진행된다고 볼 수는 있다. 뒤엎기에는 좀 멀리 간 것이니 말이다.&lt;/p&gt;
&lt;p&gt;또 한가지 문제는 바로 원전의 사이클이 너무 길다는 것이다. 원전 건설에는 4~5년 혹은 그 이상을 바라봐야 할 지도 모를 초장기 사업이다. 조선도 길다고 하는데 원전은 그 이상이니 실제로 돈이 되려면 오랜 시간이 걸릴 지도 모른다.&lt;/p&gt;
&lt;p&gt;따라서 이번 우선협상대상자 선정 소식 만으로 주가가 폭등하는 것 자체가 이상한 것이긴 하다. 그저 수주 가능성이 테마가 되었고 그 테마가 끝난 것이라 생각된다.&lt;/p&gt;
&lt;p&gt;물론 그렇다고 해도 모멘텀이 완전히 사라진 건 아닐 것이다. 그게 실적으로 나타나려면 오래 걸리니 조정이 왔을 때 담아놓고 기다리면 수익으로 이어질 가능성은 높을 것 같다. 중간에 별 삽질만 없다면 말이다.&lt;/p&gt;
&lt;p&gt;그런데 SMR은 과연 괜찮을까? 알려진 바로 모듈형의 경우 짧으면 1년 정도가 걸린다고 하니 SMR 쪽이 압도적으로 짧기는 하다. 문제가 있다면 아직 기술 개발 중이라는 점이겠지만 말이다.&lt;/p&gt;
&lt;p&gt;어쨌거나 추측성 이야기이니 너무 심각하게 보진 말자. 그리고 체코 원전 사업이 잘 진행 되었으면 좋겠다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240718-00.html</guid>
      <pubDate>Thu, 18 Jul 2024 16:47:00 +0900</pubDate>
    </item>
    <item>
      <title>Xcode 및 Swift 프로젝트에서 컴파일러 플래그 추가하기</title>
      <link>https://seorenn.github.io/article/xcode-swift-compiler-flag.html</link>
      <description>&lt;p&gt;하나의 소스 코드로 여러 일을 처리하고 싶은 욕심은 어떤 프로그래머나 가지고 있을 것 같다. 그 중 C 등의 컴파일 되는 언어에서 유래한 흔한 방식으로 바로 전처리기(Proprocessor)를 활용하는 방법이 있다. 코드가 아닌 빌드 도구 차원에서 빌드하는 코드가 어떻게 동작할 지를 결정할 수 있는 좋은 방법이니 말이다.&lt;/p&gt;
&lt;p&gt;그렇다면 Xcode에서 작업 중인 Swift 프로젝트에서는 이런 전처리기 플래그를 어떻게 추가하면 좋을까?&lt;/p&gt;
&lt;p&gt;물론 Xcode에서 쉽게 할 수 있게 방법은 갖춰 놓고 있다. 그저 직관적으로 쉽게 할 수 있는 방법이 없을 뿐이다. 그렇다고 어려운 건 절대로 아니다.&lt;/p&gt;
&lt;h2&gt;Swift 프로젝트에 컴파일러 플래그 추가하기&lt;/h2&gt;
&lt;p&gt;플래그를 추가하기 위해서 Xcode에서 해당 프로젝트의 Target을 선택한 후 Build Settings에서 아래와 같은 루트로 혹은 검색으로 Other Swift Flags 항목을 찾아보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Build Settings - Swift Compiler - Custom Flags - Other Swift Flags&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기에서 원하는 빌드 환경에서 &lt;code&gt;+&lt;/code&gt; 버튼을 눌러서 원하는 플래그를 &lt;code&gt;-D&lt;/code&gt; 옵션을 붙여서 추가해주자. 예를 들어 &lt;code&gt;SPECIAL_FEATURE&lt;/code&gt;라는 플래그를 추가해 주고 싶다면 &lt;code&gt;-DSPECIAL_FEATURE&lt;/code&gt;라고 적어주면 된다. 두 개 이상 추가하고 싶다면 각 플래그 이름마다 이렇게 &lt;code&gt;-D&lt;/code&gt;를 앞에 붙여서 계속 추가해 주면 된다. &lt;em&gt;물론 &lt;code&gt;-D&lt;/code&gt; 뿐만 아니라 다양한 컴파일러 옵션을 사용할 수도 있지만 이 글의 주제는 어디까지나 플래그 추가다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이후 Swift에서 &lt;code&gt;#if&lt;/code&gt;를 이용해 이 플래그가 정의되었을 경우의 동작을 코딩할 수 있다. 예를 들어 위에서처럼 플래그에 &lt;code&gt;-DSPECIAL_FEATURE&lt;/code&gt;를 추가한 경우 아래와 같은 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;#if SPECIAL_FEATURE
useSpecialFeature()
#else
useNormalFeature()
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C에 익숙하다면 왜 &lt;code&gt;#ifdef&lt;/code&gt;나 &lt;code&gt;#if defined()&lt;/code&gt;가 아닌가 고민할 수도 있겠지만 Swift에선 이렇게 하면 되니 괜히 고민하지 말자. 난이도도 한 번만 해보면 참 간단한 일이라고 느낄 것이다.&lt;/p&gt;
&lt;h2&gt;트러블슈팅&lt;/h2&gt;
&lt;p&gt;플래그를 추가하고 빌드하는데 아래와 같은 오류를 만날 수도 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Conditional compilation flags must be valid Swift identifiers (rather than ' FLAGNAME')&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 오류는 뭔가를 잘못 적은 것 같다는 의미로 이해하면 된다. 혹시 플래그를 추가할 때 &lt;code&gt;-DNAME&lt;/code&gt; 형식이 아닌 &lt;code&gt;-D NAME&lt;/code&gt; 등 이상한 형식으로 입력되지 않았나 확인해 보자. 기본적으로 &lt;code&gt;-D&lt;/code&gt; 옵션 뒤에 공백 없이 플래그 이름이 바로 나열되어야 한다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;하나의 소스 코드로 여러 일을 처리하고 싶은 욕심은 어떤 프로그래머나 가지고 있을 것 같다. 그 중 C 등의 컴파일 되는 언어에서 유래한 흔한 방식으로 바로 전처리기(Proprocessor)를 활용하는 방법이 있다. 코드가 아닌 빌드 도구 차원에서 빌드하는 코드가 어떻게 동작할 지를 결정할 수 있는 좋은 방법이니 말이다.&lt;/p&gt;
&lt;p&gt;그렇다면 Xcode에서 작업 중인 Swift 프로젝트에서는 이런 전처리기 플래그를 어떻게 추가하면 좋을까?&lt;/p&gt;
&lt;p&gt;물론 Xcode에서 쉽게 할 수 있게 방법은 갖춰 놓고 있다. 그저 직관적으로 쉽게 할 수 있는 방법이 없을 뿐이다. 그렇다고 어려운 건 절대로 아니다.&lt;/p&gt;
&lt;h2&gt;Swift 프로젝트에 컴파일러 플래그 추가하기&lt;/h2&gt;
&lt;p&gt;플래그를 추가하기 위해서 Xcode에서 해당 프로젝트의 Target을 선택한 후 Build Settings에서 아래와 같은 루트로 혹은 검색으로 Other Swift Flags 항목을 찾아보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Build Settings - Swift Compiler - Custom Flags - Other Swift Flags&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기에서 원하는 빌드 환경에서 &lt;code&gt;+&lt;/code&gt; 버튼을 눌러서 원하는 플래그를 &lt;code&gt;-D&lt;/code&gt; 옵션을 붙여서 추가해주자. 예를 들어 &lt;code&gt;SPECIAL_FEATURE&lt;/code&gt;라는 플래그를 추가해 주고 싶다면 &lt;code&gt;-DSPECIAL_FEATURE&lt;/code&gt;라고 적어주면 된다. 두 개 이상 추가하고 싶다면 각 플래그 이름마다 이렇게 &lt;code&gt;-D&lt;/code&gt;를 앞에 붙여서 계속 추가해 주면 된다. &lt;em&gt;물론 &lt;code&gt;-D&lt;/code&gt; 뿐만 아니라 다양한 컴파일러 옵션을 사용할 수도 있지만 이 글의 주제는 어디까지나 플래그 추가다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이후 Swift에서 &lt;code&gt;#if&lt;/code&gt;를 이용해 이 플래그가 정의되었을 경우의 동작을 코딩할 수 있다. 예를 들어 위에서처럼 플래그에 &lt;code&gt;-DSPECIAL_FEATURE&lt;/code&gt;를 추가한 경우 아래와 같은 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;#if SPECIAL_FEATURE
useSpecialFeature()
#else
useNormalFeature()
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C에 익숙하다면 왜 &lt;code&gt;#ifdef&lt;/code&gt;나 &lt;code&gt;#if defined()&lt;/code&gt;가 아닌가 고민할 수도 있겠지만 Swift에선 이렇게 하면 되니 괜히 고민하지 말자. 난이도도 한 번만 해보면 참 간단한 일이라고 느낄 것이다.&lt;/p&gt;
&lt;h2&gt;트러블슈팅&lt;/h2&gt;
&lt;p&gt;플래그를 추가하고 빌드하는데 아래와 같은 오류를 만날 수도 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Conditional compilation flags must be valid Swift identifiers (rather than ' FLAGNAME')&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 오류는 뭔가를 잘못 적은 것 같다는 의미로 이해하면 된다. 혹시 플래그를 추가할 때 &lt;code&gt;-DNAME&lt;/code&gt; 형식이 아닌 &lt;code&gt;-D NAME&lt;/code&gt; 등 이상한 형식으로 입력되지 않았나 확인해 보자. 기본적으로 &lt;code&gt;-D&lt;/code&gt; 옵션 뒤에 공백 없이 플래그 이름이 바로 나열되어야 한다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/xcode-swift-compiler-flag.html</guid>
      <pubDate>Wed, 17 Jul 2024 16:47:00 +0900</pubDate>
    </item>
    <item>
      <title>SwiftUI에서 바인딩 매개변수를 일반 타입의 값으로 넘기기</title>
      <link>https://seorenn.github.io/article/swift-fix-cannot-convert-to-binding.html</link>
      <description>&lt;p&gt;SwiftUI로 뷰를 만들다 해당 뷰를 테스트 해야 할 일이 있을 수 있다. 예를 들자면 프리뷰(SwiftUI Preview)용 코드를 작성할 때 등등 말이다. 그래서 시험용으로 몇몇 변수의 값을 하드코딩으로 넘기는 경우도 허다할 것이다.&lt;/p&gt;
&lt;p&gt;그런데 이런 경우 아래와 같은 형식의 오류를 종종 볼 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cannot convert value of type 'FooBar' to expected argument type 'Binding&amp;lt;FooBar&amp;gt;'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;직역하면 특정 타입의 값을 원하는 바인딩 타입으로 변환할 수 없다라는 의미다. 참고로 &lt;code&gt;FooBar&lt;/code&gt;로 표기한 부분에는 실제로 사용된 타입이 표시되는 부분이니 오해하지 말자. 사용하는 타입에 따라 메시지는 당연히 바뀔 것이다.&lt;/p&gt;
&lt;p&gt;어쨌거나 이 오류의 원인은 &lt;code&gt;@Binding&lt;/code&gt; 등으로 표기된 프로퍼티의 값으로 넘겨야 할 값을 그냥 정적인 값으로 넘겼기 때문에 발생한다.&lt;/p&gt;
&lt;p&gt;따라서 해결 방법 중 가장 직관적인(?) 방법은 넘기려는 값을 &lt;code&gt;@State&lt;/code&gt; 등의 프로퍼티로 생성해서 바인딩 가능하게 넘기는 방법이 있을 것이다. 물론 그게 귀찮으니 이런 글이 탄생했지만 말이다.&lt;/p&gt;
&lt;h2&gt;그 외에 가장 간단한 해결 방법&lt;/h2&gt;
&lt;p&gt;이럴 때를 위해 &lt;code&gt;Binding.constant&lt;/code&gt;가 제공된다. 어려울 것 없이 넘기려는 값을 매개변수로 넣어서 '바인딩 타입으로 값을 한번 감싸서 전달'하는 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;MyViewController(name: .constant(&amp;quot;Temporary Name&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그렇게 하면 간단하게 해결된다.&lt;/p&gt;
&lt;p&gt;물론 이렇게 하면 SwiftUI 특유의 바인딩의 제대로 된 기능을 활용하지 못 한다는 점을 기억하자. 단순히 테스트 혹은 프리뷰 용도로만 활용하기엔 괜찮은 방법 같다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;SwiftUI로 뷰를 만들다 해당 뷰를 테스트 해야 할 일이 있을 수 있다. 예를 들자면 프리뷰(SwiftUI Preview)용 코드를 작성할 때 등등 말이다. 그래서 시험용으로 몇몇 변수의 값을 하드코딩으로 넘기는 경우도 허다할 것이다.&lt;/p&gt;
&lt;p&gt;그런데 이런 경우 아래와 같은 형식의 오류를 종종 볼 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cannot convert value of type 'FooBar' to expected argument type 'Binding&amp;lt;FooBar&amp;gt;'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;직역하면 특정 타입의 값을 원하는 바인딩 타입으로 변환할 수 없다라는 의미다. 참고로 &lt;code&gt;FooBar&lt;/code&gt;로 표기한 부분에는 실제로 사용된 타입이 표시되는 부분이니 오해하지 말자. 사용하는 타입에 따라 메시지는 당연히 바뀔 것이다.&lt;/p&gt;
&lt;p&gt;어쨌거나 이 오류의 원인은 &lt;code&gt;@Binding&lt;/code&gt; 등으로 표기된 프로퍼티의 값으로 넘겨야 할 값을 그냥 정적인 값으로 넘겼기 때문에 발생한다.&lt;/p&gt;
&lt;p&gt;따라서 해결 방법 중 가장 직관적인(?) 방법은 넘기려는 값을 &lt;code&gt;@State&lt;/code&gt; 등의 프로퍼티로 생성해서 바인딩 가능하게 넘기는 방법이 있을 것이다. 물론 그게 귀찮으니 이런 글이 탄생했지만 말이다.&lt;/p&gt;
&lt;h2&gt;그 외에 가장 간단한 해결 방법&lt;/h2&gt;
&lt;p&gt;이럴 때를 위해 &lt;code&gt;Binding.constant&lt;/code&gt;가 제공된다. 어려울 것 없이 넘기려는 값을 매개변수로 넣어서 '바인딩 타입으로 값을 한번 감싸서 전달'하는 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;MyViewController(name: .constant(&amp;quot;Temporary Name&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그렇게 하면 간단하게 해결된다.&lt;/p&gt;
&lt;p&gt;물론 이렇게 하면 SwiftUI 특유의 바인딩의 제대로 된 기능을 활용하지 못 한다는 점을 기억하자. 단순히 테스트 혹은 프리뷰 용도로만 활용하기엔 괜찮은 방법 같다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/swift-fix-cannot-convert-to-binding.html</guid>
      <pubDate>Tue, 16 Jul 2024 13:47:00 +0900</pubDate>
    </item>
    <item>
      <title>투싼 하이브리드 개인적인 평가</title>
      <link>https://seorenn.github.io/article/tucson-hev-nx4-facelift-review.html</link>
      <description>&lt;p&gt;투싼 하이브리드(NX4 부분변경 모델) 전륜 모델을 2024년 1월 구입하여 지금껏 계속 운행하고 있다. 이 글은 이 차의 장단점이나 평가를 간단히 정리해 보는 글이며 지속적으로 업데이트 될 예정이다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="더 뉴 투싼" src="../upload/202407152138-a18f7cbb.png" /&gt;
&lt;em&gt;더 뉴 투싼 (현대자동차)&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;전반적인 승차감&lt;/h2&gt;
&lt;p&gt;딱히 다른 고급차나 대형차를 충분히 몰아본 경험이 없는 개인으로써 투싼 하이브리드 - 이하 투싼하브 - 는 굉장히 만족스럽다고 평가한다.&lt;/p&gt;
&lt;p&gt;다만 조수석에 앉은 동승자는 썩 마음에 들지는 않은 승차감인 모양이다. 덕분에 혹시나 나중에 투싼에 질리게 되었을 때 더 큰 차로 바꿀 명분을 자연스럽게 획득했다.&lt;/p&gt;
&lt;p&gt;뒷좌석에는 아이들이 주로 타는데 일단 좀 몰다 보면 잠에 들긴 해서 그나마 안심하고는 있다. 하지만 큰 애는 카시트가 답답하다고 하면서 잘 안 타려고 하는 게 혹시 승차감 때문인가 싶어서 좀 마음에 걸린다.&lt;/p&gt;
&lt;p&gt;세단과 SUV의 승차감 비교는 대체로 무의미한 일이니 하지 말자.&lt;/p&gt;
&lt;h2&gt;성능&lt;/h2&gt;
&lt;p&gt;패밀리카로써 더 이상의 성능이 필요할까? 조용하고 힘세고 빠르다. 초 고각 언덕도 무리 없이 올라갔고 고속도로에서도 충분히 넘치는 가속력이었다. 심지어 4인이 타고 짐도 가득 실었어도 힘이 달린다는 느낌을 받은 적은 한 번도 없었다.&lt;/p&gt;
&lt;p&gt;아마도 1.6T HEV 조합에서 가장 최적의 성능을 내는 한계 차종이 이 투싼 급이지 않을까 생각된다. 커뮤니티의 평가이긴 했지만 투싼보다 높은 급의 세그먼트에선 1.6T HEV의 힘의 부족이 느껴진다는 평가가 종종 보이니 말이다.&lt;/p&gt;
&lt;h2&gt;언덕 오르기&lt;/h2&gt;
&lt;p&gt;평범한 언덕 말고 초고경사 언덕을 오를 일이 가끔 있는데 옛날에 몰던 오래된 차로는 상당히 곤욕스러운 일이었다. 얼마나 언덕이 심하면 브레이크에서 발을 떼면 후진 풀악셀을 밟는 느낌이었으니 말이다. 그래서 옛날 차로는 브레이크에서 발을 떼서 엑셀로 발을 옮기는 순간이 너무나 긴장되고 무서웠던 순간이 많았다.&lt;/p&gt;
&lt;p&gt;하지만 투싼은 밀림방지 기능도 있는 데다 오토홀드를 쓸 수도 있어서 언덕에서 상대적으로 덜 무서웠다. 아직까지 오토홀드 없이도 그렇게 밀린다는 느낌을 받은 적은 없는 것 같다. 다만 급경사의 길에서 주차하는 등 정방향이 아닌 상황에서는 약간씩 밀리는 경우가 있기는 하다.&lt;/p&gt;
&lt;h2&gt;고속도로 주행&lt;/h2&gt;
&lt;p&gt;주행감이나 승차감, 소음 면에서는 딱히 서술할 게 없을 것 같다. 고속으로 달리는 환경에선 고급 차량이 아닌 이상 큰 차이는 없을 것 같다. &lt;/p&gt;
&lt;p&gt;고속도로에서 스마트 크루즈 컨트롤(스마트CC)을 켜니 졸린다. 이건 너무나 큰 단점(?)이다. 물론 그만큼 편하다는 말이다. 시내만 달리다 갑자기 전용도로나 고속도로에 나가면 온 몸과 기분이 편해진다.&lt;/p&gt;
&lt;p&gt;다만 조향 보조 기능 혹은 차로 이탈 방지 기능 덕분에 좀 위험한 순간이 있었다. 예를 들어 어떤 자동차 전용도로에서 커브길에 차선이 끊긴 구간을 지나간 적이 있었는데 차가 멋대로 코너 바깥쪽으로 갑자기 핸들을 돌리길래 식겁하는 줄 알았다. 이래서 운행 보조구나 라고 절실히 느꼈다.&lt;/p&gt;
&lt;p&gt;약간의 단점이 더 있다면 인터페이스 같다. 주행 보조 버튼을 누르는 순간 스마트CC를 비롯한 온갖 주행 보조 기능이 켜지는 건 당연히 좋다. 하지만 이 버튼을 다시 눌러서 비활성화 시키면 크루즈 컨트롤만 비활성화 되는 것은 여전히 이상하다고 생각된다. 하다못해 차로중앙유지도 함께 비활성화 되었으면 좋겠다.&lt;/p&gt;
&lt;p&gt;고속도로주행보조는 HDA2가 아닌 HDA1이라 차선 자동 변경 기능은 없고 대신 깜빡이를 넣으면 속도를 더 올리는 등으로 보조해 줬는데 개인적인 운행 스타일에 맞지는 않았다. 그래서 차선 변경할 때는 그냥 액셀이나 브레이크 살짝으로 일부러 스마트CC를 비활성화 한 뒤 수동으로 끼어들고 다시 스마트CC를 활성화하는 식으로 운행했다. 어차피 스마트CC를 쓰는 사람이 차선을 자주 바꿀 이유는 없을 것 같고 말이다.&lt;/p&gt;
&lt;p&gt;이 기능에서 가장 큰 단점은 정전식 센서가 없어서 스티어링 휠을 자주 흔들어 줘야 한다는 점 같다. 직선으로 쭈욱 가는데 스티어링 휠을 흔들어야 한다는 건 오히려 위험해지게 만드는 행위가 아닐지 생각해 봐야 할 것 같다.&lt;/p&gt;
&lt;h2&gt;연비&lt;/h2&gt;
&lt;p&gt;주로 시내 짧은 거리를 운행했으며 장거리는 정말 가끔 운행하는 입장에서 최저 기록은 8.8 km/L, 최고 기록은 55.4 km/L로 찍혔다. 너무 천차만별인 것 같은데 주행거리나 속도 등 여러 변수가 존재한다. &lt;/p&gt;
&lt;p&gt;다만 누적 연비는 10 km/L 수준으로 처참하게 낮은데 아무래도 주행하지 않고 공회전 하는 경우가 많아서 그런 모양이다. 특히 아직 새 차 냄새가 완전히 빠지지 않아서 시동을 걸고도 출발하지 않고 창문을 열고 한참을 기다리는 경우가 잦았으니 어쩔 수 없을 것 같다.&lt;/p&gt;
&lt;p&gt;고속도로가 포함된 장거리의 경우에는 대체로 14km/L 이상은 나와주는 편이지만 4인 탑승 기준으로는 18km/L 이상 뽑는 것은 좀 무리라는 느낌도 들었다.&lt;/p&gt;
&lt;p&gt;관련된 설정으로 회생제동은 과거에는 1 레벨로 설정하고 다녔지만 지금은 0 레벨 즉 기본 상태로 사용 중이다. 이렇게 해도 타력주행 시 작게나마 충전이 되고 약간 브레이킹 시 회생제동이 잘 걸린다. 그 외에 스마트 회생제동은 시내 주행 시에만 자동 레벨로 아주 간혹 사용할 때도 있었지만 동승객이 있는 경우는 사용하지 않는 편이다.&lt;/p&gt;
&lt;h2&gt;어라운드 뷰&lt;/h2&gt;
&lt;p&gt;어라운드 뷰는 차량 주변을 3D로 합성해서 보여주는 멋지고 정말 돈 값을 하는 옵션이다. 안 그래도 아파트 주차장이 좁아서 주차 라인도 협소한데 여기에 딱 맞게 넣을 때 큰 역할을 한다. 예전에는 내려서 눈으로 보고 삐져나가 있으면 다시 타서 이동시키고 별 X랄을 했어야 했는데 말이다.&lt;/p&gt;
&lt;p&gt;종종 좁은 골목길이나 차량이 빡빡한 주차장에 갇힐(?) 때가 있는데 거리 센서와 함께 이 어라운드 뷰를 잘 이용해 차를 안전하게 탈출(?)시키는 등 정말 큰 도움이 될 때도 있었다. 이 정도면 이미 돈 값은 하는 옵션이다.&lt;/p&gt;
&lt;p&gt;다만 한 밤 중에는 돈 값을 못 할 때가 많다. 아무래도 주변이 어두워서 잘 보이지 않는데 차선도 잘 보일 리가 없다. 밤에 간접적으로 빛을 비춰줄 특수한 조명 시스템이 있었으면 좋겠다는 생각이 든다.&lt;/p&gt;
&lt;p&gt;참고로 어라운드 뷰는 인스퍼레이션 트림의 경우 파킹어시스트 옵션에 포함되어 있다.&lt;/p&gt;
&lt;h2&gt;긴급 제동&lt;/h2&gt;
&lt;p&gt;긴급 제동이 동작하면 굉장히 위험한 순간일 것 같은데 뭐 틀린 건 아니다. 다만 개인적인 경험으론 그렇게 위험한 경우는 아니었다. 예를 들어 후진 중 뒤에 사람이 갑자기 나타나 지나간다거나, 후진 주차 중 뒤차에 너무 가까이 붙었을 때 등 긴급제동에 도움을 받았다. 하지만 어차피 아주 천천히 움직이던 상황이라 그렇게 위험하진 않은 상황이기도 했었다.&lt;/p&gt;
&lt;p&gt;뭐 하여간 이 긴급제동도 돈 값을 하는 옵션 같다. 아 옵션이 아니라 기본 기능인가?&lt;/p&gt;
&lt;p&gt;참고로 긴급제동이 걸릴 만큼 사물과 가까운 상황에서는 다시 긴급 제동을 걸어주지는 않는 모양이다. 쓰라린 경험(?)으로 익힌 교훈이다.&lt;/p&gt;
&lt;h2&gt;변속 충격&lt;/h2&gt;
&lt;p&gt;전반적으로 변속 과정이 잘 느껴지지 않을 정도로 가속이나 감속 시 이질감을 느끼지 못 했다.&lt;/p&gt;
&lt;p&gt;특이한 점으로 저속의 어느 구간에서 모터가 약간 치고 나가는 듯한 느낌을 받을 때도 있었다. 다만 자주 겪지는 않았고 무엇보다 해당 구간은 짧은 영역의 RPM에 한해서만 나타나는 듯했다. 어쩌면 모터와 엔진이 함께 돌아가다 엔진이 꺼지며 모터가 약간 힘을 더 내는 구간에서 그렇게 느껴지는 것일지도 모르겠다.&lt;/p&gt;
&lt;p&gt;비슷하게 오르막길에서 액셀을 약하게 밟아서 속도를 아주 부드럽게 서서히 줄여갈 경우 내연기관이 꺼지는 순간 역시 모터가 갑자기 살짝 강하게 개입되는 느낌을 받을 때도 있다. 하지만 아이가 동승하고 있지 않다면 이렇게 심하게 부드러운 운행을 할 이유는 없을 것 같아서 별 문제는 아니라고 생각된다.&lt;/p&gt;
&lt;h2&gt;소음&lt;/h2&gt;
&lt;p&gt;페이스리프트 전의 투싼 하이브리드의 단점 중 가볍게 하나 꼽히는 게 내연기관이 개입될 때 소음이 크게 느껴진다는 평가가 있었다. 그래서 페이스리프트 된 더 뉴 투싼 하이브리드도 그러지 않을까 생각했다.&lt;/p&gt;
&lt;p&gt;그런데 더 뉴 투싼 하이브리드를 몰아보면서 갑자기 소음이 커진다거나 시끄럽다거나 하는 느낌을 못 받았다. 엔진이 개입될 때의 소리도 갑자기 커지는 게 아니라 부드럽게 커지는 느낌이었다. 어쩌면 엔진오일 증가 문제 때문에 이전에 비해 엔진이 더 자주 개입하는 걸 수도 있다. 고속도로에 진입해서 급하게 가속할 때도 소음이 갑자기 커진다는 느낌을 받지는 못했다.&lt;/p&gt;
&lt;p&gt;엔진 소리 자체도 불쾌감보다는 오히려 기분 좋은 경쾌감이 느껴지는 사운드라고 생각한다.&lt;/p&gt;
&lt;p&gt;물론 소음이 작은 것은 아니다. 창문을 열어놓은 상태에서 시동이 걸리면 상당히 시끄럽기는 하다. 그리고 뒷좌석에서는 소음을 상대적으로 크게 느낄 가능성은 있다. 2중 접합 유리는 앞 좌석에만 있으니 말이다.&lt;/p&gt;
&lt;h2&gt;전체적인 공간&lt;/h2&gt;
&lt;p&gt;투싼 급이면 4인 가족 패밀리카로 충분한 공간이라고 생각한다. 아직까지 실내가 좁아서 불만족스러웠던 경험이 없었다.&lt;/p&gt;
&lt;p&gt;다만 4인 패밀리카로써는 약간의 조건이 있다. 바로 유모차는 한 대만 싣는다는 조건이다. 만약 아이가 둘인데 나이 차이가 별로 안 나거나 쌍둥이라서 유모차를 2대 혹은 대형 사이즈나 왜건 등을 실어야 한다면 안타깝지만 이보다 더 큰 급의 차량은 선택이 아닌 필수인 것 같다. 하지만 아이가 둘이라도 한 명은 유모차를 안 타도 될 만큼 나이가 들었다는 가정에서는 충분히 4인 가족 패밀리카로 손색이 없는 공간인 것 같다.&lt;/p&gt;
&lt;p&gt;어쨌든 최대한 짐을 많이 실었을 때는 유모차 하나, 27인치 모니터 3대가 들어갈 만한 크기의 골판지 상자, 마트에서 주는 쇼핑백 하나 정도가 들어가고도 룸 미러를 보는 데 문제가 없었다.&lt;/p&gt;
&lt;h2&gt;트렁크&lt;/h2&gt;
&lt;p&gt;투싼 뒤에서 트렁크를 직접 열 때는 간단히 버튼 하나만 누르면 쑥 자동으로 열리고 다시 버튼 하나만 누르면 자동으로 닫히는데, 이런 걸 경험해 보지 못한 이에겐 참으로 신문물이다. 정말 편하다.&lt;/p&gt;
&lt;p&gt;그런데 스마트키나 운전석에서 열 때는 왜 한 번에 자동이 아닌 꾹 누르고 있어야 하는지는 좀 불만스러웠다. 물론 안전 때문이라고는 하지만 열릴 때 자동으로 문제가 있으면 멈추도록 만드는 게 상품성은 확실히 좋았을 텐데 말이다. 닫힐 때도 뭔가 걸리면 자동으로 멈추게 하는 것 정도는 기본이 되어야 하지 않을까 생각되기도 했다.&lt;/p&gt;
&lt;p&gt;어쨌든 편하고 아직까지 안전 문제와 관련한 이벤트도 없었기에 당장은 만족하는 편이다.&lt;/p&gt;
&lt;p&gt;트렁크 공간은 이미 서술했다시피 넓다고 생각하면 넓지만, 아주 큰 짐을 넣을 때면 작게 느껴지는 건 어쩔 수 없을 것 같기도 하다. 하지만 SUV의 장점, 즉 뒷좌석 폴딩으로 확 넓어지는 트렁크 공간을 체감할 수도 있으니 무작정 실망할 필요는 없을 것 같다. 그저 뒷좌석 모두가 카시트에 점령되지만 않는다면 말이지만 말이다.&lt;/p&gt;
&lt;h2&gt;블랙박스(feat. 빌트인캠2)&lt;/h2&gt;
&lt;p&gt;사제 블랙박스를 달 필요가 없을 정도로 충분한 기능을 제공한다. 약간의 이벤트에도 해당 이벤트가 어디서 발생했는지 표시해 주는 등 차 안에서 블랙박스의 내용을 볼 때도 충분하다.&lt;/p&gt;
&lt;p&gt;주차 중에도 차체에 충격이 있을 경우 자동으로 녹화가 되고 이를 블루링크 앱을 통해 알림을 받고 아예 원격으로도 볼 수 있게 해 준다는 점은 정말 신세계인 것 같다. 하지만 그 충격이란게 대부분 주변에 큰 차가 지나간 경우라서 어떨 때는 왜 이렇게 민감한가 생각되기도 한다.&lt;/p&gt;
&lt;p&gt;다만 약간 불편한 점이 있다면 블루링크 앱에서 자꾸 ‘녹화가 잘 끝났다’는 알림을 보내오는 게 귀찮다는 점 정도일 것 같다.&lt;/p&gt;
&lt;p&gt;어쨌든 가성비 측면에서도 제법 효율적이라고 생각되는 옵션 같다.&lt;/p&gt;
&lt;h2&gt;베이비 모드&lt;/h2&gt;
&lt;p&gt;드라이브 모드를 베이비 모드 - 정확히는 MY DRIVE를 베이비 모드로 세팅한 경우 - 로 세팅하고 운행하면 확실히 출발 때가 답답하다는 것을 느끼긴 했다. 좋게 말하자면 정말 부드럽게 출발한다.&lt;/p&gt;
&lt;p&gt;다만 멈출 때나 과속방지턱을 넘을 때는 얼마나 차이가 있는 지는 아직도 잘 모르겠다.&lt;/p&gt;
&lt;p&gt;앞서 언급했다시피 간혹 답답하다는 느낌이 들 때도 있어서 항상 사용하지는 않지만 아이들이 타고 있고 가끔 컨디션이 별로라고 느껴질 때는 해당 모드를 설장하는 편이다.&lt;/p&gt;
&lt;h2&gt;HUD&lt;/h2&gt;
&lt;p&gt;HUD가 있으니 클러스터를 거의 안 보는 것 같다. 해봤자 남은 주행 가능 거리나 기름 양 확인할 때, 회생제동 잘 되나 혹은 회생제동 레벨이 얼마인지 확인할 때가 아니면 클러스터를 볼 일이 없는 수준이니 말이다. 그만큼 확실히 편하고 돈 값을 하는 기능이다. 특히 전방 주시 시점에서 시점을 크게 안 옮겨도 되니 안전 측면에서도 정말 중요한 옵션이라고 생각된다.&lt;/p&gt;
&lt;p&gt;지금은 좀 익숙해진 것 같지만 여전히 HUD가 맺히는 초점이 잘 안 맞는 것 같은 건 완벽하게 적응되지는 않는 것 같다. 하지만 인식에 문제가 있는 수준은 아니라서 별 불만은 없는 편이다.&lt;/p&gt;
&lt;h2&gt;후면 깜빡이&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;더 뉴 투싼의 가장 큰 단점은 후면 깜빡이 위치&lt;/strong&gt;인 것은 변함이 없다. 아마도 투싼 구입을 꺼리는 요소 두 가지를 꼽으라면 디자인 취향을 빼면 이 후면 깜박이 위치가 가장 큰 원인일 것이다.&lt;/p&gt;
&lt;p&gt;그런데 지금에 와서 이렇게 낮은 후면 깜빡이도 그렇게 큰 문제는 아니다라고도 느껴진다. 아직도 끼어들기 하다가 신경질적인 반응을 받아 본 적은 없다. 그리고 직접 운전할 때 깜빡이가 낮은 차가 끼어든다고 위험했을 법한 상황은 아직 겪은 적이 없다. 그리고 깜빡이가 높든 낮든 갑자기 끼어드는 차는 어쨌든 위험천만했다. 역시 사람은 적응의 동물이라 깜빡이가 낮아도 다 적응하게 되어있다.&lt;/p&gt;
&lt;p&gt;개인적인 경험으로도 앞 차의 후면 깜빡이가 너무 낮아서 짜증나는 상황을 겪은 적은 없었기도 하다. 깜빡이 위치든 뭐든 무엇보다 중요한 것은 안전운전 그리고 방어운전이다.&lt;/p&gt;
&lt;h2&gt;보닛&lt;/h2&gt;
&lt;p&gt;보닛(본네트)은 차를 인수하고 난 뒤 바로 궁금해서 열어본 적이 한 번 있었다. 보닛 자체는 꽤나 무거웠다. 고정시키려면 꼬챙이를 걸어야 해서 불편했고 꼬챙이가 구부려져 갑자기 보닛 뚜껑이 떨어질 것 같은 불안감이 느껴지기도 했다.&lt;/p&gt;
&lt;p&gt;그런데 보닛을 직접 열 일이 얼마나 될까 생각해 보니 이 정도 불편함은 그냥 잊혔다. 어차피 보닛을 자주 열 사람은 아무래도 정비사일 테니 말이다.&lt;/p&gt;
&lt;h2&gt;외장&lt;/h2&gt;
&lt;p&gt;외장 색상이 아마존 메탈릭 그레이인데 직사광선이 없는 곳에서는 어두운 회색에 까깝게 보이지만 빛에 따라서 녹색과 펄이 비쳐 보이는 독특한 색상이다.&lt;/p&gt;
&lt;p&gt;이런 다크 그레이 계열 색상은 특히 오염에 강하다고 느끼고 있다. 주변에 다니는 투싼을 통해 적어도 흰색에 비해 회색이 오염이 심하게 튀지 않고 검은색에 비해서도 더러워졌다는 느낌을 덜 받는 것 같다. 그래서 개인적으로는 차를 대충 몰려는 사람에게는 회색 계열 색상을 추천하고 싶다. 강력한 이미지의 그릴과 따로 노는 느낌의 흰색과 빨간색은 특히 안 어울리는 것 같기도 하고 말이다.&lt;/p&gt;
&lt;p&gt;그래서 아직도 세차장에 가보지 않았지만 차 상태는 깨끗하다고 느껴진다. 그저 먼지만 털고 물왁스로 정말 어쩌다 한번 닦았고 유리만 전용 세정제로 닦아주고 있다. 차가 너무 커서 세차할 엄두가 잘 안나기도 하고 말이다. 더 큰 차는 도대체 어떻게 닦아야 되나 모르겠다.&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;더 뉴 투싼 하이브리드는 짐이 그렇게 많지는 않은 4인 가족이 타기에 무난하고 크기도 구축 아파트 주차장 라인에 꽉 차게 들어가는 아슬아슬한 크기에 연비도 좋고 성능도 무난한 한마디로 ‘적당한’ 패밀리 카다. 물론 혼자 타기에도, 배우자나 이성 친구와 타기에도 더없이 좋은 차 같다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;투싼 하이브리드(NX4 부분변경 모델) 전륜 모델을 2024년 1월 구입하여 지금껏 계속 운행하고 있다. 이 글은 이 차의 장단점이나 평가를 간단히 정리해 보는 글이며 지속적으로 업데이트 될 예정이다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="더 뉴 투싼" src="../upload/202407152138-a18f7cbb.png" /&gt;
&lt;em&gt;더 뉴 투싼 (현대자동차)&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;전반적인 승차감&lt;/h2&gt;
&lt;p&gt;딱히 다른 고급차나 대형차를 충분히 몰아본 경험이 없는 개인으로써 투싼 하이브리드 - 이하 투싼하브 - 는 굉장히 만족스럽다고 평가한다.&lt;/p&gt;
&lt;p&gt;다만 조수석에 앉은 동승자는 썩 마음에 들지는 않은 승차감인 모양이다. 덕분에 혹시나 나중에 투싼에 질리게 되었을 때 더 큰 차로 바꿀 명분을 자연스럽게 획득했다.&lt;/p&gt;
&lt;p&gt;뒷좌석에는 아이들이 주로 타는데 일단 좀 몰다 보면 잠에 들긴 해서 그나마 안심하고는 있다. 하지만 큰 애는 카시트가 답답하다고 하면서 잘 안 타려고 하는 게 혹시 승차감 때문인가 싶어서 좀 마음에 걸린다.&lt;/p&gt;
&lt;p&gt;세단과 SUV의 승차감 비교는 대체로 무의미한 일이니 하지 말자.&lt;/p&gt;
&lt;h2&gt;성능&lt;/h2&gt;
&lt;p&gt;패밀리카로써 더 이상의 성능이 필요할까? 조용하고 힘세고 빠르다. 초 고각 언덕도 무리 없이 올라갔고 고속도로에서도 충분히 넘치는 가속력이었다. 심지어 4인이 타고 짐도 가득 실었어도 힘이 달린다는 느낌을 받은 적은 한 번도 없었다.&lt;/p&gt;
&lt;p&gt;아마도 1.6T HEV 조합에서 가장 최적의 성능을 내는 한계 차종이 이 투싼 급이지 않을까 생각된다. 커뮤니티의 평가이긴 했지만 투싼보다 높은 급의 세그먼트에선 1.6T HEV의 힘의 부족이 느껴진다는 평가가 종종 보이니 말이다.&lt;/p&gt;
&lt;h2&gt;언덕 오르기&lt;/h2&gt;
&lt;p&gt;평범한 언덕 말고 초고경사 언덕을 오를 일이 가끔 있는데 옛날에 몰던 오래된 차로는 상당히 곤욕스러운 일이었다. 얼마나 언덕이 심하면 브레이크에서 발을 떼면 후진 풀악셀을 밟는 느낌이었으니 말이다. 그래서 옛날 차로는 브레이크에서 발을 떼서 엑셀로 발을 옮기는 순간이 너무나 긴장되고 무서웠던 순간이 많았다.&lt;/p&gt;
&lt;p&gt;하지만 투싼은 밀림방지 기능도 있는 데다 오토홀드를 쓸 수도 있어서 언덕에서 상대적으로 덜 무서웠다. 아직까지 오토홀드 없이도 그렇게 밀린다는 느낌을 받은 적은 없는 것 같다. 다만 급경사의 길에서 주차하는 등 정방향이 아닌 상황에서는 약간씩 밀리는 경우가 있기는 하다.&lt;/p&gt;
&lt;h2&gt;고속도로 주행&lt;/h2&gt;
&lt;p&gt;주행감이나 승차감, 소음 면에서는 딱히 서술할 게 없을 것 같다. 고속으로 달리는 환경에선 고급 차량이 아닌 이상 큰 차이는 없을 것 같다. &lt;/p&gt;
&lt;p&gt;고속도로에서 스마트 크루즈 컨트롤(스마트CC)을 켜니 졸린다. 이건 너무나 큰 단점(?)이다. 물론 그만큼 편하다는 말이다. 시내만 달리다 갑자기 전용도로나 고속도로에 나가면 온 몸과 기분이 편해진다.&lt;/p&gt;
&lt;p&gt;다만 조향 보조 기능 혹은 차로 이탈 방지 기능 덕분에 좀 위험한 순간이 있었다. 예를 들어 어떤 자동차 전용도로에서 커브길에 차선이 끊긴 구간을 지나간 적이 있었는데 차가 멋대로 코너 바깥쪽으로 갑자기 핸들을 돌리길래 식겁하는 줄 알았다. 이래서 운행 보조구나 라고 절실히 느꼈다.&lt;/p&gt;
&lt;p&gt;약간의 단점이 더 있다면 인터페이스 같다. 주행 보조 버튼을 누르는 순간 스마트CC를 비롯한 온갖 주행 보조 기능이 켜지는 건 당연히 좋다. 하지만 이 버튼을 다시 눌러서 비활성화 시키면 크루즈 컨트롤만 비활성화 되는 것은 여전히 이상하다고 생각된다. 하다못해 차로중앙유지도 함께 비활성화 되었으면 좋겠다.&lt;/p&gt;
&lt;p&gt;고속도로주행보조는 HDA2가 아닌 HDA1이라 차선 자동 변경 기능은 없고 대신 깜빡이를 넣으면 속도를 더 올리는 등으로 보조해 줬는데 개인적인 운행 스타일에 맞지는 않았다. 그래서 차선 변경할 때는 그냥 액셀이나 브레이크 살짝으로 일부러 스마트CC를 비활성화 한 뒤 수동으로 끼어들고 다시 스마트CC를 활성화하는 식으로 운행했다. 어차피 스마트CC를 쓰는 사람이 차선을 자주 바꿀 이유는 없을 것 같고 말이다.&lt;/p&gt;
&lt;p&gt;이 기능에서 가장 큰 단점은 정전식 센서가 없어서 스티어링 휠을 자주 흔들어 줘야 한다는 점 같다. 직선으로 쭈욱 가는데 스티어링 휠을 흔들어야 한다는 건 오히려 위험해지게 만드는 행위가 아닐지 생각해 봐야 할 것 같다.&lt;/p&gt;
&lt;h2&gt;연비&lt;/h2&gt;
&lt;p&gt;주로 시내 짧은 거리를 운행했으며 장거리는 정말 가끔 운행하는 입장에서 최저 기록은 8.8 km/L, 최고 기록은 55.4 km/L로 찍혔다. 너무 천차만별인 것 같은데 주행거리나 속도 등 여러 변수가 존재한다. &lt;/p&gt;
&lt;p&gt;다만 누적 연비는 10 km/L 수준으로 처참하게 낮은데 아무래도 주행하지 않고 공회전 하는 경우가 많아서 그런 모양이다. 특히 아직 새 차 냄새가 완전히 빠지지 않아서 시동을 걸고도 출발하지 않고 창문을 열고 한참을 기다리는 경우가 잦았으니 어쩔 수 없을 것 같다.&lt;/p&gt;
&lt;p&gt;고속도로가 포함된 장거리의 경우에는 대체로 14km/L 이상은 나와주는 편이지만 4인 탑승 기준으로는 18km/L 이상 뽑는 것은 좀 무리라는 느낌도 들었다.&lt;/p&gt;
&lt;p&gt;관련된 설정으로 회생제동은 과거에는 1 레벨로 설정하고 다녔지만 지금은 0 레벨 즉 기본 상태로 사용 중이다. 이렇게 해도 타력주행 시 작게나마 충전이 되고 약간 브레이킹 시 회생제동이 잘 걸린다. 그 외에 스마트 회생제동은 시내 주행 시에만 자동 레벨로 아주 간혹 사용할 때도 있었지만 동승객이 있는 경우는 사용하지 않는 편이다.&lt;/p&gt;
&lt;h2&gt;어라운드 뷰&lt;/h2&gt;
&lt;p&gt;어라운드 뷰는 차량 주변을 3D로 합성해서 보여주는 멋지고 정말 돈 값을 하는 옵션이다. 안 그래도 아파트 주차장이 좁아서 주차 라인도 협소한데 여기에 딱 맞게 넣을 때 큰 역할을 한다. 예전에는 내려서 눈으로 보고 삐져나가 있으면 다시 타서 이동시키고 별 X랄을 했어야 했는데 말이다.&lt;/p&gt;
&lt;p&gt;종종 좁은 골목길이나 차량이 빡빡한 주차장에 갇힐(?) 때가 있는데 거리 센서와 함께 이 어라운드 뷰를 잘 이용해 차를 안전하게 탈출(?)시키는 등 정말 큰 도움이 될 때도 있었다. 이 정도면 이미 돈 값은 하는 옵션이다.&lt;/p&gt;
&lt;p&gt;다만 한 밤 중에는 돈 값을 못 할 때가 많다. 아무래도 주변이 어두워서 잘 보이지 않는데 차선도 잘 보일 리가 없다. 밤에 간접적으로 빛을 비춰줄 특수한 조명 시스템이 있었으면 좋겠다는 생각이 든다.&lt;/p&gt;
&lt;p&gt;참고로 어라운드 뷰는 인스퍼레이션 트림의 경우 파킹어시스트 옵션에 포함되어 있다.&lt;/p&gt;
&lt;h2&gt;긴급 제동&lt;/h2&gt;
&lt;p&gt;긴급 제동이 동작하면 굉장히 위험한 순간일 것 같은데 뭐 틀린 건 아니다. 다만 개인적인 경험으론 그렇게 위험한 경우는 아니었다. 예를 들어 후진 중 뒤에 사람이 갑자기 나타나 지나간다거나, 후진 주차 중 뒤차에 너무 가까이 붙었을 때 등 긴급제동에 도움을 받았다. 하지만 어차피 아주 천천히 움직이던 상황이라 그렇게 위험하진 않은 상황이기도 했었다.&lt;/p&gt;
&lt;p&gt;뭐 하여간 이 긴급제동도 돈 값을 하는 옵션 같다. 아 옵션이 아니라 기본 기능인가?&lt;/p&gt;
&lt;p&gt;참고로 긴급제동이 걸릴 만큼 사물과 가까운 상황에서는 다시 긴급 제동을 걸어주지는 않는 모양이다. 쓰라린 경험(?)으로 익힌 교훈이다.&lt;/p&gt;
&lt;h2&gt;변속 충격&lt;/h2&gt;
&lt;p&gt;전반적으로 변속 과정이 잘 느껴지지 않을 정도로 가속이나 감속 시 이질감을 느끼지 못 했다.&lt;/p&gt;
&lt;p&gt;특이한 점으로 저속의 어느 구간에서 모터가 약간 치고 나가는 듯한 느낌을 받을 때도 있었다. 다만 자주 겪지는 않았고 무엇보다 해당 구간은 짧은 영역의 RPM에 한해서만 나타나는 듯했다. 어쩌면 모터와 엔진이 함께 돌아가다 엔진이 꺼지며 모터가 약간 힘을 더 내는 구간에서 그렇게 느껴지는 것일지도 모르겠다.&lt;/p&gt;
&lt;p&gt;비슷하게 오르막길에서 액셀을 약하게 밟아서 속도를 아주 부드럽게 서서히 줄여갈 경우 내연기관이 꺼지는 순간 역시 모터가 갑자기 살짝 강하게 개입되는 느낌을 받을 때도 있다. 하지만 아이가 동승하고 있지 않다면 이렇게 심하게 부드러운 운행을 할 이유는 없을 것 같아서 별 문제는 아니라고 생각된다.&lt;/p&gt;
&lt;h2&gt;소음&lt;/h2&gt;
&lt;p&gt;페이스리프트 전의 투싼 하이브리드의 단점 중 가볍게 하나 꼽히는 게 내연기관이 개입될 때 소음이 크게 느껴진다는 평가가 있었다. 그래서 페이스리프트 된 더 뉴 투싼 하이브리드도 그러지 않을까 생각했다.&lt;/p&gt;
&lt;p&gt;그런데 더 뉴 투싼 하이브리드를 몰아보면서 갑자기 소음이 커진다거나 시끄럽다거나 하는 느낌을 못 받았다. 엔진이 개입될 때의 소리도 갑자기 커지는 게 아니라 부드럽게 커지는 느낌이었다. 어쩌면 엔진오일 증가 문제 때문에 이전에 비해 엔진이 더 자주 개입하는 걸 수도 있다. 고속도로에 진입해서 급하게 가속할 때도 소음이 갑자기 커진다는 느낌을 받지는 못했다.&lt;/p&gt;
&lt;p&gt;엔진 소리 자체도 불쾌감보다는 오히려 기분 좋은 경쾌감이 느껴지는 사운드라고 생각한다.&lt;/p&gt;
&lt;p&gt;물론 소음이 작은 것은 아니다. 창문을 열어놓은 상태에서 시동이 걸리면 상당히 시끄럽기는 하다. 그리고 뒷좌석에서는 소음을 상대적으로 크게 느낄 가능성은 있다. 2중 접합 유리는 앞 좌석에만 있으니 말이다.&lt;/p&gt;
&lt;h2&gt;전체적인 공간&lt;/h2&gt;
&lt;p&gt;투싼 급이면 4인 가족 패밀리카로 충분한 공간이라고 생각한다. 아직까지 실내가 좁아서 불만족스러웠던 경험이 없었다.&lt;/p&gt;
&lt;p&gt;다만 4인 패밀리카로써는 약간의 조건이 있다. 바로 유모차는 한 대만 싣는다는 조건이다. 만약 아이가 둘인데 나이 차이가 별로 안 나거나 쌍둥이라서 유모차를 2대 혹은 대형 사이즈나 왜건 등을 실어야 한다면 안타깝지만 이보다 더 큰 급의 차량은 선택이 아닌 필수인 것 같다. 하지만 아이가 둘이라도 한 명은 유모차를 안 타도 될 만큼 나이가 들었다는 가정에서는 충분히 4인 가족 패밀리카로 손색이 없는 공간인 것 같다.&lt;/p&gt;
&lt;p&gt;어쨌든 최대한 짐을 많이 실었을 때는 유모차 하나, 27인치 모니터 3대가 들어갈 만한 크기의 골판지 상자, 마트에서 주는 쇼핑백 하나 정도가 들어가고도 룸 미러를 보는 데 문제가 없었다.&lt;/p&gt;
&lt;h2&gt;트렁크&lt;/h2&gt;
&lt;p&gt;투싼 뒤에서 트렁크를 직접 열 때는 간단히 버튼 하나만 누르면 쑥 자동으로 열리고 다시 버튼 하나만 누르면 자동으로 닫히는데, 이런 걸 경험해 보지 못한 이에겐 참으로 신문물이다. 정말 편하다.&lt;/p&gt;
&lt;p&gt;그런데 스마트키나 운전석에서 열 때는 왜 한 번에 자동이 아닌 꾹 누르고 있어야 하는지는 좀 불만스러웠다. 물론 안전 때문이라고는 하지만 열릴 때 자동으로 문제가 있으면 멈추도록 만드는 게 상품성은 확실히 좋았을 텐데 말이다. 닫힐 때도 뭔가 걸리면 자동으로 멈추게 하는 것 정도는 기본이 되어야 하지 않을까 생각되기도 했다.&lt;/p&gt;
&lt;p&gt;어쨌든 편하고 아직까지 안전 문제와 관련한 이벤트도 없었기에 당장은 만족하는 편이다.&lt;/p&gt;
&lt;p&gt;트렁크 공간은 이미 서술했다시피 넓다고 생각하면 넓지만, 아주 큰 짐을 넣을 때면 작게 느껴지는 건 어쩔 수 없을 것 같기도 하다. 하지만 SUV의 장점, 즉 뒷좌석 폴딩으로 확 넓어지는 트렁크 공간을 체감할 수도 있으니 무작정 실망할 필요는 없을 것 같다. 그저 뒷좌석 모두가 카시트에 점령되지만 않는다면 말이지만 말이다.&lt;/p&gt;
&lt;h2&gt;블랙박스(feat. 빌트인캠2)&lt;/h2&gt;
&lt;p&gt;사제 블랙박스를 달 필요가 없을 정도로 충분한 기능을 제공한다. 약간의 이벤트에도 해당 이벤트가 어디서 발생했는지 표시해 주는 등 차 안에서 블랙박스의 내용을 볼 때도 충분하다.&lt;/p&gt;
&lt;p&gt;주차 중에도 차체에 충격이 있을 경우 자동으로 녹화가 되고 이를 블루링크 앱을 통해 알림을 받고 아예 원격으로도 볼 수 있게 해 준다는 점은 정말 신세계인 것 같다. 하지만 그 충격이란게 대부분 주변에 큰 차가 지나간 경우라서 어떨 때는 왜 이렇게 민감한가 생각되기도 한다.&lt;/p&gt;
&lt;p&gt;다만 약간 불편한 점이 있다면 블루링크 앱에서 자꾸 ‘녹화가 잘 끝났다’는 알림을 보내오는 게 귀찮다는 점 정도일 것 같다.&lt;/p&gt;
&lt;p&gt;어쨌든 가성비 측면에서도 제법 효율적이라고 생각되는 옵션 같다.&lt;/p&gt;
&lt;h2&gt;베이비 모드&lt;/h2&gt;
&lt;p&gt;드라이브 모드를 베이비 모드 - 정확히는 MY DRIVE를 베이비 모드로 세팅한 경우 - 로 세팅하고 운행하면 확실히 출발 때가 답답하다는 것을 느끼긴 했다. 좋게 말하자면 정말 부드럽게 출발한다.&lt;/p&gt;
&lt;p&gt;다만 멈출 때나 과속방지턱을 넘을 때는 얼마나 차이가 있는 지는 아직도 잘 모르겠다.&lt;/p&gt;
&lt;p&gt;앞서 언급했다시피 간혹 답답하다는 느낌이 들 때도 있어서 항상 사용하지는 않지만 아이들이 타고 있고 가끔 컨디션이 별로라고 느껴질 때는 해당 모드를 설장하는 편이다.&lt;/p&gt;
&lt;h2&gt;HUD&lt;/h2&gt;
&lt;p&gt;HUD가 있으니 클러스터를 거의 안 보는 것 같다. 해봤자 남은 주행 가능 거리나 기름 양 확인할 때, 회생제동 잘 되나 혹은 회생제동 레벨이 얼마인지 확인할 때가 아니면 클러스터를 볼 일이 없는 수준이니 말이다. 그만큼 확실히 편하고 돈 값을 하는 기능이다. 특히 전방 주시 시점에서 시점을 크게 안 옮겨도 되니 안전 측면에서도 정말 중요한 옵션이라고 생각된다.&lt;/p&gt;
&lt;p&gt;지금은 좀 익숙해진 것 같지만 여전히 HUD가 맺히는 초점이 잘 안 맞는 것 같은 건 완벽하게 적응되지는 않는 것 같다. 하지만 인식에 문제가 있는 수준은 아니라서 별 불만은 없는 편이다.&lt;/p&gt;
&lt;h2&gt;후면 깜빡이&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;더 뉴 투싼의 가장 큰 단점은 후면 깜빡이 위치&lt;/strong&gt;인 것은 변함이 없다. 아마도 투싼 구입을 꺼리는 요소 두 가지를 꼽으라면 디자인 취향을 빼면 이 후면 깜박이 위치가 가장 큰 원인일 것이다.&lt;/p&gt;
&lt;p&gt;그런데 지금에 와서 이렇게 낮은 후면 깜빡이도 그렇게 큰 문제는 아니다라고도 느껴진다. 아직도 끼어들기 하다가 신경질적인 반응을 받아 본 적은 없다. 그리고 직접 운전할 때 깜빡이가 낮은 차가 끼어든다고 위험했을 법한 상황은 아직 겪은 적이 없다. 그리고 깜빡이가 높든 낮든 갑자기 끼어드는 차는 어쨌든 위험천만했다. 역시 사람은 적응의 동물이라 깜빡이가 낮아도 다 적응하게 되어있다.&lt;/p&gt;
&lt;p&gt;개인적인 경험으로도 앞 차의 후면 깜빡이가 너무 낮아서 짜증나는 상황을 겪은 적은 없었기도 하다. 깜빡이 위치든 뭐든 무엇보다 중요한 것은 안전운전 그리고 방어운전이다.&lt;/p&gt;
&lt;h2&gt;보닛&lt;/h2&gt;
&lt;p&gt;보닛(본네트)은 차를 인수하고 난 뒤 바로 궁금해서 열어본 적이 한 번 있었다. 보닛 자체는 꽤나 무거웠다. 고정시키려면 꼬챙이를 걸어야 해서 불편했고 꼬챙이가 구부려져 갑자기 보닛 뚜껑이 떨어질 것 같은 불안감이 느껴지기도 했다.&lt;/p&gt;
&lt;p&gt;그런데 보닛을 직접 열 일이 얼마나 될까 생각해 보니 이 정도 불편함은 그냥 잊혔다. 어차피 보닛을 자주 열 사람은 아무래도 정비사일 테니 말이다.&lt;/p&gt;
&lt;h2&gt;외장&lt;/h2&gt;
&lt;p&gt;외장 색상이 아마존 메탈릭 그레이인데 직사광선이 없는 곳에서는 어두운 회색에 까깝게 보이지만 빛에 따라서 녹색과 펄이 비쳐 보이는 독특한 색상이다.&lt;/p&gt;
&lt;p&gt;이런 다크 그레이 계열 색상은 특히 오염에 강하다고 느끼고 있다. 주변에 다니는 투싼을 통해 적어도 흰색에 비해 회색이 오염이 심하게 튀지 않고 검은색에 비해서도 더러워졌다는 느낌을 덜 받는 것 같다. 그래서 개인적으로는 차를 대충 몰려는 사람에게는 회색 계열 색상을 추천하고 싶다. 강력한 이미지의 그릴과 따로 노는 느낌의 흰색과 빨간색은 특히 안 어울리는 것 같기도 하고 말이다.&lt;/p&gt;
&lt;p&gt;그래서 아직도 세차장에 가보지 않았지만 차 상태는 깨끗하다고 느껴진다. 그저 먼지만 털고 물왁스로 정말 어쩌다 한번 닦았고 유리만 전용 세정제로 닦아주고 있다. 차가 너무 커서 세차할 엄두가 잘 안나기도 하고 말이다. 더 큰 차는 도대체 어떻게 닦아야 되나 모르겠다.&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;더 뉴 투싼 하이브리드는 짐이 그렇게 많지는 않은 4인 가족이 타기에 무난하고 크기도 구축 아파트 주차장 라인에 꽉 차게 들어가는 아슬아슬한 크기에 연비도 좋고 성능도 무난한 한마디로 ‘적당한’ 패밀리 카다. 물론 혼자 타기에도, 배우자나 이성 친구와 타기에도 더없이 좋은 차 같다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/tucson-hev-nx4-facelift-review.html</guid>
      <pubDate>Mon, 15 Jul 2024 21:21:00 +0900</pubDate>
    </item>
    <item>
      <title>한 주간의 애플 소식들 24-07-14</title>
      <link>https://seorenn.github.io/log/20240714-00.html</link>
      <description>&lt;h2&gt;소프트웨어 릴리즈 소식들&lt;/h2&gt;
&lt;p&gt;차세대 애플 플랫폼 OS 들의 세 번째 개발자 베타가 공개되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15 Sequoia beta 3: &lt;em&gt;macOS 15 beta 3는 명확한 이유는 알 수 없지만 홀로 수 일 늦게 공개되었다.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;iOS 18 beta 3: 써드파티 앱 아이콘의 다크모드 자동 적용, 동적 배경화면 색상 자동 변경 지원, RCS 지원 통신사 추가, Apple TV 앱에 InSight 기능 추가 등&lt;/li&gt;
&lt;li&gt;iPadOS 18 beta 3: Apple TV 앱에 InSight 기능 추가, Freeform Scenes 추가 등&lt;/li&gt;
&lt;li&gt;visionOS 2 beta 3&lt;/li&gt;
&lt;li&gt;watchOS 11 beta 3&lt;/li&gt;
&lt;li&gt;tvOS 18 beta 3: InSight 기능 추가 등&lt;/li&gt;
&lt;li&gt;Xcode 16 beta 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;언급된 항목을 제외하곤 이전 베타와 비교해서 어떤 차이가 있는 지는 알려지지 않았다. 아마도 기능은 확정되었을 것 같고 이제는 버그 수정 위주로 개발이 진행되지 않을까 추측된다. &lt;/p&gt;
&lt;p&gt;참고로 visionOS 2의 공개 베타는 나오지 않을 가능성도 있다고 한다.&lt;/p&gt;
&lt;p&gt;그 외에 현재 안정 버전의 마이너 업데이트들도 세 번째 개발자 베타가 공개되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS 14.6 beta 3&lt;/li&gt;
&lt;li&gt;iOS 17.6 beta 3&lt;/li&gt;
&lt;li&gt;iPadOS 17.6 beta 3&lt;/li&gt;
&lt;li&gt;visionOS 1.3 beta 3&lt;/li&gt;
&lt;li&gt;watchOS 10.6 beta 3&lt;/li&gt;
&lt;li&gt;tvOS 17.6 beta 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 버전들도 명확한 업데이트 내역이 알려지지 않고 있다. 처음부터 예상되었던 '버그 패치 수준의 업데이트일 것'이라는 예측은 아직도 틀리지 않은 것 같다. 어쨌거나 이 버전들도 개발자 베타 공개 수 일 후 공공 베타가 공개되었다.&lt;/p&gt;
&lt;p&gt;그 외에도 아래의 릴리즈 소식이 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AirPods Pro 2 Firmware 7A5244b Beta &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;일반적인 소식들&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AI&lt;/strong&gt;&lt;br/&gt;
애플지능이 결합된 새로운 시리는 내년 봄은 되어야 볼 수 있을 것 같다. 한편 애플은 OpenAI의 참관인(observer) 지위를 포기했다고 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;맥 점유율 부활&lt;/strong&gt;&lt;br/&gt;
맥 출하량이 전년비 6% 성장했다고 한다. 지난 실적에서 슬슬 PC 수요가 부활하는 듯한 모습이 보이더니 PC 부문엣서 가장 강한 성장세를 보이며 9%의 시장점유율을 달성했다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iPhone 관련 루머들&lt;/strong&gt;&lt;br/&gt;
iPhone 16에서 Face ID 시스템이 대대적으로 개편될 가능성이 제기되었다. 그 외에 충전 시스템도 개선되어서 40W 유선 충전, 20W 무선 충전이 지원될 가능성이 있다. 카메라 광학줌은 프로맥스 급에서도 여전히 5배 줌이 탑재될 것 같고 테트라프리즘 카메라는 아이폰 17 프로맥스에나 탑재될 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iOS 18&lt;/strong&gt;&lt;br/&gt;
iOS 18에는 집중이나 휴식 모드용 새로운 배경음이 추가되었다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFC 개방?!&lt;/strong&gt;&lt;br/&gt;
아이폰 교통카드 관련 이미지 정보가 유출되면서 아이폰의 한국 교통카드 지원이 머지 않았다는 루머가 돌았다. 유럽에서는 아이폰에 삼성페이가 들어오는 등 NFC 개방이 진행된다고 하며 동시에 EU의 애플페이 반독점 조사가 종결 되었다고 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;끝이 없는 반독점 규제&lt;/strong&gt;&lt;br/&gt;
유럽에서 거액의 벌금을 내야 할 처지에 몰린 애플이 이제는 인도에서도 비슷한 규제로 압력을 받을 가능성이 보인다. 유럽을 따라 이런 흐름을 보이는 국가들이 점점 많아질 것으로 보이는데 애플의 한 발 빠른 대처가 필요해 보인다.&lt;/p&gt;
&lt;h2&gt;기타 루머 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;차세대 애플워치 SE는 가격을 낮추기 위해 플라스틱을 사용할 것이란 전만이 제기되었다.&lt;/li&gt;
&lt;li&gt;애플지능을 결합한 테이블탑 로봇에 대한 루머가 나오기 시작했다.&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;h2&gt;소프트웨어 릴리즈 소식들&lt;/h2&gt;
&lt;p&gt;차세대 애플 플랫폼 OS 들의 세 번째 개발자 베타가 공개되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15 Sequoia beta 3: &lt;em&gt;macOS 15 beta 3는 명확한 이유는 알 수 없지만 홀로 수 일 늦게 공개되었다.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;iOS 18 beta 3: 써드파티 앱 아이콘의 다크모드 자동 적용, 동적 배경화면 색상 자동 변경 지원, RCS 지원 통신사 추가, Apple TV 앱에 InSight 기능 추가 등&lt;/li&gt;
&lt;li&gt;iPadOS 18 beta 3: Apple TV 앱에 InSight 기능 추가, Freeform Scenes 추가 등&lt;/li&gt;
&lt;li&gt;visionOS 2 beta 3&lt;/li&gt;
&lt;li&gt;watchOS 11 beta 3&lt;/li&gt;
&lt;li&gt;tvOS 18 beta 3: InSight 기능 추가 등&lt;/li&gt;
&lt;li&gt;Xcode 16 beta 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;언급된 항목을 제외하곤 이전 베타와 비교해서 어떤 차이가 있는 지는 알려지지 않았다. 아마도 기능은 확정되었을 것 같고 이제는 버그 수정 위주로 개발이 진행되지 않을까 추측된다. &lt;/p&gt;
&lt;p&gt;참고로 visionOS 2의 공개 베타는 나오지 않을 가능성도 있다고 한다.&lt;/p&gt;
&lt;p&gt;그 외에 현재 안정 버전의 마이너 업데이트들도 세 번째 개발자 베타가 공개되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS 14.6 beta 3&lt;/li&gt;
&lt;li&gt;iOS 17.6 beta 3&lt;/li&gt;
&lt;li&gt;iPadOS 17.6 beta 3&lt;/li&gt;
&lt;li&gt;visionOS 1.3 beta 3&lt;/li&gt;
&lt;li&gt;watchOS 10.6 beta 3&lt;/li&gt;
&lt;li&gt;tvOS 17.6 beta 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 버전들도 명확한 업데이트 내역이 알려지지 않고 있다. 처음부터 예상되었던 '버그 패치 수준의 업데이트일 것'이라는 예측은 아직도 틀리지 않은 것 같다. 어쨌거나 이 버전들도 개발자 베타 공개 수 일 후 공공 베타가 공개되었다.&lt;/p&gt;
&lt;p&gt;그 외에도 아래의 릴리즈 소식이 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AirPods Pro 2 Firmware 7A5244b Beta &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;일반적인 소식들&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AI&lt;/strong&gt;&lt;br/&gt;
애플지능이 결합된 새로운 시리는 내년 봄은 되어야 볼 수 있을 것 같다. 한편 애플은 OpenAI의 참관인(observer) 지위를 포기했다고 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;맥 점유율 부활&lt;/strong&gt;&lt;br/&gt;
맥 출하량이 전년비 6% 성장했다고 한다. 지난 실적에서 슬슬 PC 수요가 부활하는 듯한 모습이 보이더니 PC 부문엣서 가장 강한 성장세를 보이며 9%의 시장점유율을 달성했다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iPhone 관련 루머들&lt;/strong&gt;&lt;br/&gt;
iPhone 16에서 Face ID 시스템이 대대적으로 개편될 가능성이 제기되었다. 그 외에 충전 시스템도 개선되어서 40W 유선 충전, 20W 무선 충전이 지원될 가능성이 있다. 카메라 광학줌은 프로맥스 급에서도 여전히 5배 줌이 탑재될 것 같고 테트라프리즘 카메라는 아이폰 17 프로맥스에나 탑재될 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iOS 18&lt;/strong&gt;&lt;br/&gt;
iOS 18에는 집중이나 휴식 모드용 새로운 배경음이 추가되었다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFC 개방?!&lt;/strong&gt;&lt;br/&gt;
아이폰 교통카드 관련 이미지 정보가 유출되면서 아이폰의 한국 교통카드 지원이 머지 않았다는 루머가 돌았다. 유럽에서는 아이폰에 삼성페이가 들어오는 등 NFC 개방이 진행된다고 하며 동시에 EU의 애플페이 반독점 조사가 종결 되었다고 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;끝이 없는 반독점 규제&lt;/strong&gt;&lt;br/&gt;
유럽에서 거액의 벌금을 내야 할 처지에 몰린 애플이 이제는 인도에서도 비슷한 규제로 압력을 받을 가능성이 보인다. 유럽을 따라 이런 흐름을 보이는 국가들이 점점 많아질 것으로 보이는데 애플의 한 발 빠른 대처가 필요해 보인다.&lt;/p&gt;
&lt;h2&gt;기타 루머 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;차세대 애플워치 SE는 가격을 낮추기 위해 플라스틱을 사용할 것이란 전만이 제기되었다.&lt;/li&gt;
&lt;li&gt;애플지능을 결합한 테이블탑 로봇에 대한 루머가 나오기 시작했다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240714-00.html</guid>
      <pubDate>Sun, 14 Jul 2024 21:16:00 +0900</pubDate>
    </item>
    <item>
      <title>파이썬 예외 처리 정리</title>
      <link>https://seorenn.github.io/article/python-exceptions.html</link>
      <description>&lt;p&gt;이 글은 Python의 예외(Exceptions) 처리의 가장 기초적인 부분을 정리한다. 참고로 문법은 버전 3.x 이후이며 2.x 버전에서도 문법은 비슷하지만 약간 느슨(?)할 수도 있다.&lt;/p&gt;
&lt;h2&gt;예외 처리 기본 구조&lt;/h2&gt;
&lt;p&gt;파이썬의 예외 처리의 가장 기본 키워드는 &lt;code&gt;try&lt;/code&gt;와 &lt;code&gt;except&lt;/code&gt;다. 대충 아래와 같은 식으로 쓸 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except:
    print(&amp;quot;ERROR: 뭔가 에러가 났어요!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;try&lt;/code&gt; 블록 내부에서 예외가 발생할지도 모를 코드를 배치하면 여기 안에서 예와가 발생할 경우 그 아래의 &lt;code&gt;except&lt;/code&gt; 블록으로 플로우가 넘어가면서 예외를 처리할 수 있다. 여기서 오류를 처리하던지 프로그램을 종료시키던지 아니면 그저 로그만 남기고 넘어갈 수도 있다.&lt;/p&gt;
&lt;p&gt;가장 기본적인 구조는 위와 같지만 요즘은 이렇게 쓰면 아마 누군가(?) 경고를 날려 줄 것이다. 정확히 말하자면 파이썬 커뮤니티에서는 명확한 예외의 이름을 명시하는 것을 추천하고 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except ValueError:
    print(&amp;quot;Value Error!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 &lt;code&gt;do_what()&lt;/code&gt;에서 발생되는 예외 중 &lt;code&gt;ValueError&lt;/code&gt; 예외가 발생하면 &lt;code&gt;except&lt;/code&gt; 블록으로 진입되어 처리할 수 있으나 이 외의 예외는 &lt;code&gt;except&lt;/code&gt; 블록으로 진입되지 않는데 만약 더 상위에 따로 예외를 처리하는 코드가 없으면 프로그램 자체가 예외를 발생시키며 강제 종료된다.&lt;/p&gt;
&lt;p&gt;예외 이름을 명시하더라도 약간 부족할 수 있다. 좀 더 정확한 예외 원인을 알려주는 경우가 있으니 예외 인스턴스를 받아서 처리해보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except ValueError as e:
    print(f&amp;quot;Value Error: {e}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 경우 &lt;code&gt;ValueError&lt;/code&gt;라는 예외에서 넘겨주는 문자열이 있을 경우 화면에 표시가 된다. 다만 이 부분은 예외 클래스에 따라 좀 더 적합한 방식이 있을 수도 있다.&lt;/p&gt;
&lt;p&gt;만약 한 예외가 아니라 여러 예외를 처리하고 싶다면 아래와 같이 &lt;code&gt;except&lt;/code&gt;를 계속 나열할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except ValueError:
    print(&amp;quot;Value Error!&amp;quot;)
except AttributeError:
    print(&amp;quot;Attribute Error!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 여러 예외를 처리하되 각각의 예외의 상황에 맞게 처리가 가능하다.&lt;/p&gt;
&lt;p&gt;아니면 여러 예외를 하나의 동일한 코드로 처리하고 싶다면 아래와 같이 여러 예외를 하나의 &lt;code&gt;except&lt;/code&gt;로 처리할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except (ValueError, AttributeError):
    print(&amp;quot;Value or Attribute Error!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 경우 경우 &lt;code&gt;ValueError&lt;/code&gt; 혹은 &lt;code&gt;AttributeError&lt;/code&gt; 둘 중 하나의 예외가 발생하면 &lt;code&gt;except&lt;/code&gt; 안의 구문이 실행된다. 만약 이 경우에서도 상세한 메시지를 구하는 등 예외 인스턴스를 얻고 싶다면 아래와 같이 좀 더 코드를 추가할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except (ValueError, AttributeError) as e:
    print(f&amp;quot;Something Error: {e}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;예외 발생시키기&lt;/h2&gt;
&lt;p&gt;예외는 &lt;code&gt;raise&lt;/code&gt; 커맨드로 발생시킬 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;raise ValueError()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예외 클래스는 보통은 첫 인자로 문자열 메시지를 넣을 수 있게 구성된 경우가 많다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;raise ValueError(&amp;quot;The value is invalid&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;사용자 정의 예외&lt;/h2&gt;
&lt;p&gt;개인이 만든 기능에는 당연히 개인이 정의한 오류가 발생할 수 있다. 따라서 당연하게도 예외 클래스 또한 원하는 대로 별도로 디자인할 수 있다.&lt;/p&gt;
&lt;p&gt;아래는 &lt;code&gt;TestException&lt;/code&gt; 이라는 예외를 만들고 이를 일부러 발생시키는 예제다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class TestException(Exception):
    pass

def test():
    raise TestException()

try:
    test()
except TestException as e:
    print(f'TestException: {e}')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TestException&lt;/code&gt; 클래스 정의에서 볼 수 있듯이 예외 클래스는 &lt;code&gt;Exception&lt;/code&gt;을 상속 받은 클래스라 보면 된다.&lt;/p&gt;
&lt;p&gt;이 예외 클래스에 메시지 기능을 간단히 추가하고자 한다면 문자열 변환 메소드를 추가해 주는 방법이 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class TestException(Exception):
    def __str__(self):
        return &amp;quot;TestException&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 좀 더 예외 다운 예외 클래스로 만들고 싶다면 별도의 메시지를 전달 받을 수 있는 편이 좋을 것 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class TestException(Exception):
    def __init__(self, message=&amp;quot;&amp;quot;):
        self.message = message
    def __str__(self):
        return f&amp;quot;TestException {self.message}&amp;quot;

def test():
    raise TestException(&amp;quot;Some Error&amp;quot;)

try:
    test()
except Exception as e:
    print(f'Exception: {e}')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아마 기본적인 예외 클래스의 골격은 이런 형태면 될 것 같다.&lt;/p&gt;
&lt;h2&gt;예외 발생 시 트레이스백을 그대로 출력하기&lt;/h2&gt;
&lt;p&gt;예외가 발생할 경우 상세한 트레이스백(traceback) - 혹은 스택트레이스(stack trace) - 메시지를 콘솔에 표시해서 에러에 대처하는게 디버깅에 매우 유용하다. 이런 경우 &lt;code&gt;traceback&lt;/code&gt; 모듈의 &lt;code&gt;print_exc()&lt;/code&gt;함수를 이용할 수 있다. 예를 들자면 이런 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import traceback

try:
    do_what()
except Exception:
    traceback.print_exc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 구현하면 &lt;code&gt;try&lt;/code&gt; 블록 안에서 예외가 발생할 경우 상세한 트레이스백이 콘솔에 표시된다.&lt;/p&gt;
&lt;p&gt;만약 이 트레이스백 등을 포함한 전체 예외 메시지를 로그로 남기기 위해 문자열로 받고 싶다면 &lt;code&gt;format_exc()&lt;/code&gt; 함수를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import traceback

try:
    do_what()
except Exception:
    stacktrace = traceback.format_exc()
    log(stacktrace)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드에서 &lt;code&gt;log()&lt;/code&gt;라는 함수는 임의로 정의한 로그를 기록하는 함수다. 이런 식으로 상세한 예외 상황 메시지를 출력하거나 전달할 수 있다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;이 글은 Python의 예외(Exceptions) 처리의 가장 기초적인 부분을 정리한다. 참고로 문법은 버전 3.x 이후이며 2.x 버전에서도 문법은 비슷하지만 약간 느슨(?)할 수도 있다.&lt;/p&gt;
&lt;h2&gt;예외 처리 기본 구조&lt;/h2&gt;
&lt;p&gt;파이썬의 예외 처리의 가장 기본 키워드는 &lt;code&gt;try&lt;/code&gt;와 &lt;code&gt;except&lt;/code&gt;다. 대충 아래와 같은 식으로 쓸 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except:
    print(&amp;quot;ERROR: 뭔가 에러가 났어요!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;try&lt;/code&gt; 블록 내부에서 예외가 발생할지도 모를 코드를 배치하면 여기 안에서 예와가 발생할 경우 그 아래의 &lt;code&gt;except&lt;/code&gt; 블록으로 플로우가 넘어가면서 예외를 처리할 수 있다. 여기서 오류를 처리하던지 프로그램을 종료시키던지 아니면 그저 로그만 남기고 넘어갈 수도 있다.&lt;/p&gt;
&lt;p&gt;가장 기본적인 구조는 위와 같지만 요즘은 이렇게 쓰면 아마 누군가(?) 경고를 날려 줄 것이다. 정확히 말하자면 파이썬 커뮤니티에서는 명확한 예외의 이름을 명시하는 것을 추천하고 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except ValueError:
    print(&amp;quot;Value Error!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 &lt;code&gt;do_what()&lt;/code&gt;에서 발생되는 예외 중 &lt;code&gt;ValueError&lt;/code&gt; 예외가 발생하면 &lt;code&gt;except&lt;/code&gt; 블록으로 진입되어 처리할 수 있으나 이 외의 예외는 &lt;code&gt;except&lt;/code&gt; 블록으로 진입되지 않는데 만약 더 상위에 따로 예외를 처리하는 코드가 없으면 프로그램 자체가 예외를 발생시키며 강제 종료된다.&lt;/p&gt;
&lt;p&gt;예외 이름을 명시하더라도 약간 부족할 수 있다. 좀 더 정확한 예외 원인을 알려주는 경우가 있으니 예외 인스턴스를 받아서 처리해보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except ValueError as e:
    print(f&amp;quot;Value Error: {e}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 경우 &lt;code&gt;ValueError&lt;/code&gt;라는 예외에서 넘겨주는 문자열이 있을 경우 화면에 표시가 된다. 다만 이 부분은 예외 클래스에 따라 좀 더 적합한 방식이 있을 수도 있다.&lt;/p&gt;
&lt;p&gt;만약 한 예외가 아니라 여러 예외를 처리하고 싶다면 아래와 같이 &lt;code&gt;except&lt;/code&gt;를 계속 나열할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except ValueError:
    print(&amp;quot;Value Error!&amp;quot;)
except AttributeError:
    print(&amp;quot;Attribute Error!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 여러 예외를 처리하되 각각의 예외의 상황에 맞게 처리가 가능하다.&lt;/p&gt;
&lt;p&gt;아니면 여러 예외를 하나의 동일한 코드로 처리하고 싶다면 아래와 같이 여러 예외를 하나의 &lt;code&gt;except&lt;/code&gt;로 처리할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except (ValueError, AttributeError):
    print(&amp;quot;Value or Attribute Error!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 경우 경우 &lt;code&gt;ValueError&lt;/code&gt; 혹은 &lt;code&gt;AttributeError&lt;/code&gt; 둘 중 하나의 예외가 발생하면 &lt;code&gt;except&lt;/code&gt; 안의 구문이 실행된다. 만약 이 경우에서도 상세한 메시지를 구하는 등 예외 인스턴스를 얻고 싶다면 아래와 같이 좀 더 코드를 추가할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    do_what()
except (ValueError, AttributeError) as e:
    print(f&amp;quot;Something Error: {e}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;예외 발생시키기&lt;/h2&gt;
&lt;p&gt;예외는 &lt;code&gt;raise&lt;/code&gt; 커맨드로 발생시킬 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;raise ValueError()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예외 클래스는 보통은 첫 인자로 문자열 메시지를 넣을 수 있게 구성된 경우가 많다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;raise ValueError(&amp;quot;The value is invalid&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;사용자 정의 예외&lt;/h2&gt;
&lt;p&gt;개인이 만든 기능에는 당연히 개인이 정의한 오류가 발생할 수 있다. 따라서 당연하게도 예외 클래스 또한 원하는 대로 별도로 디자인할 수 있다.&lt;/p&gt;
&lt;p&gt;아래는 &lt;code&gt;TestException&lt;/code&gt; 이라는 예외를 만들고 이를 일부러 발생시키는 예제다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class TestException(Exception):
    pass

def test():
    raise TestException()

try:
    test()
except TestException as e:
    print(f'TestException: {e}')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TestException&lt;/code&gt; 클래스 정의에서 볼 수 있듯이 예외 클래스는 &lt;code&gt;Exception&lt;/code&gt;을 상속 받은 클래스라 보면 된다.&lt;/p&gt;
&lt;p&gt;이 예외 클래스에 메시지 기능을 간단히 추가하고자 한다면 문자열 변환 메소드를 추가해 주는 방법이 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class TestException(Exception):
    def __str__(self):
        return &amp;quot;TestException&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 좀 더 예외 다운 예외 클래스로 만들고 싶다면 별도의 메시지를 전달 받을 수 있는 편이 좋을 것 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class TestException(Exception):
    def __init__(self, message=&amp;quot;&amp;quot;):
        self.message = message
    def __str__(self):
        return f&amp;quot;TestException {self.message}&amp;quot;

def test():
    raise TestException(&amp;quot;Some Error&amp;quot;)

try:
    test()
except Exception as e:
    print(f'Exception: {e}')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아마 기본적인 예외 클래스의 골격은 이런 형태면 될 것 같다.&lt;/p&gt;
&lt;h2&gt;예외 발생 시 트레이스백을 그대로 출력하기&lt;/h2&gt;
&lt;p&gt;예외가 발생할 경우 상세한 트레이스백(traceback) - 혹은 스택트레이스(stack trace) - 메시지를 콘솔에 표시해서 에러에 대처하는게 디버깅에 매우 유용하다. 이런 경우 &lt;code&gt;traceback&lt;/code&gt; 모듈의 &lt;code&gt;print_exc()&lt;/code&gt;함수를 이용할 수 있다. 예를 들자면 이런 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import traceback

try:
    do_what()
except Exception:
    traceback.print_exc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 구현하면 &lt;code&gt;try&lt;/code&gt; 블록 안에서 예외가 발생할 경우 상세한 트레이스백이 콘솔에 표시된다.&lt;/p&gt;
&lt;p&gt;만약 이 트레이스백 등을 포함한 전체 예외 메시지를 로그로 남기기 위해 문자열로 받고 싶다면 &lt;code&gt;format_exc()&lt;/code&gt; 함수를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import traceback

try:
    do_what()
except Exception:
    stacktrace = traceback.format_exc()
    log(stacktrace)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드에서 &lt;code&gt;log()&lt;/code&gt;라는 함수는 임의로 정의한 로그를 기록하는 함수다. 이런 식으로 상세한 예외 상황 메시지를 출력하거나 전달할 수 있다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-exceptions.html</guid>
      <pubDate>Sat, 13 Jul 2024 17:47:00 +0900</pubDate>
    </item>
    <item>
      <title>미국 6월 PPI가 망한 것 같은데 미장은 왜 저럴까?</title>
      <link>https://seorenn.github.io/log/20240712-01.html</link>
      <description>&lt;p&gt;오늘은 미국 6월 PPI가 발표되었다. 제목에도 적었지만 예상보다는 좀 높게 나왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 6월 헤드라인 PPI MoM 0.2% (+0.2%), YoY 2.6% (+0.2%)&lt;/li&gt;
&lt;li&gt;미국 5월 근원 PPI MoM 0.4% (+0.1%), YoY 3.0% (+0.4%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;헤드라인과 근원 지표 모두 지난 달보다 오른 데다 예상치 보다도 다 높게 나와버렸다. 이러면 조만간의 CPI에 안 좋은 영향을 끼칠 가능성이 있다.&lt;/p&gt;
&lt;p&gt;그런데 주식시장은 왜인지 신경 안 쓰는 분위기다. 오랜만에 3대 지수가 모두 오름세를 보이며 랠리를 다시 시작하는 듯한 느낌까지 받았다.&lt;/p&gt;
&lt;p&gt;왜 이러는 걸까? 도무지 이해가 안 된다.&lt;/p&gt;
&lt;p&gt;물론 PPI 자체는 연준이 신경 쓰지는 않는 것 같기에 무시해도 될 짇도 모른다. 하지만 소외되긴 했어도 CPI의 선행지표이기도 한데 이렇게 넘어가도 되는 걸까?&lt;/p&gt;
&lt;p&gt;물론 이번주 주식시장이 끝나기까지 아직 시간이 많이 남았기에 어떻게 될 지는 모르는 일이긴 하다. 거기다 FedWatch를 보니 9월 인하 확률이 지난 파월 청문회 때 보다 더 높아졌다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;내가 보지 못한 무엇인가가 있는 것일까?&lt;/p&gt;
&lt;/blockquote&gt;</description>
      <content:encoded>&lt;p&gt;오늘은 미국 6월 PPI가 발표되었다. 제목에도 적었지만 예상보다는 좀 높게 나왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 6월 헤드라인 PPI MoM 0.2% (+0.2%), YoY 2.6% (+0.2%)&lt;/li&gt;
&lt;li&gt;미국 5월 근원 PPI MoM 0.4% (+0.1%), YoY 3.0% (+0.4%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;헤드라인과 근원 지표 모두 지난 달보다 오른 데다 예상치 보다도 다 높게 나와버렸다. 이러면 조만간의 CPI에 안 좋은 영향을 끼칠 가능성이 있다.&lt;/p&gt;
&lt;p&gt;그런데 주식시장은 왜인지 신경 안 쓰는 분위기다. 오랜만에 3대 지수가 모두 오름세를 보이며 랠리를 다시 시작하는 듯한 느낌까지 받았다.&lt;/p&gt;
&lt;p&gt;왜 이러는 걸까? 도무지 이해가 안 된다.&lt;/p&gt;
&lt;p&gt;물론 PPI 자체는 연준이 신경 쓰지는 않는 것 같기에 무시해도 될 짇도 모른다. 하지만 소외되긴 했어도 CPI의 선행지표이기도 한데 이렇게 넘어가도 되는 걸까?&lt;/p&gt;
&lt;p&gt;물론 이번주 주식시장이 끝나기까지 아직 시간이 많이 남았기에 어떻게 될 지는 모르는 일이긴 하다. 거기다 FedWatch를 보니 9월 인하 확률이 지난 파월 청문회 때 보다 더 높아졌다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;내가 보지 못한 무엇인가가 있는 것일까?&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240712-01.html</guid>
      <pubDate>Fri, 12 Jul 2024 23:28:00 +0900</pubDate>
    </item>
    <item>
      <title>어쩌면 끔찍한 이야기</title>
      <link>https://seorenn.github.io/log/20240712-00.html</link>
      <description>&lt;p&gt;아이가 어린이집에 가야 할 시간에 있었던 작고 사소하지만 끔찍한 이야기다.&lt;/p&gt;
&lt;p&gt;아이는 준비를 다 마쳤는데 오늘도 뭔가를 먹으면서 가고 싶다고 한다. 밖에서 뭔가 먹는 걸 굉장히 즐기는 시기 같다. 어쨌든 늘 그랬다시피 작은 비닐 지퍼백을 하나 꺼내서 여기다 늘 먹던 젤리를 3개만 담게 했다.&lt;/p&gt;
&lt;p&gt;여기까진 평화로웠는데, 갑자기 아이가 어린이집까지 차를 태워 달라고 떼를 쓴다. 지구영웅은 가까운 거리를 걸어간다고 설득해도 통하지 않았다.&lt;/p&gt;
&lt;p&gt;어쩔 수 없이 걸어가도 15분도 안 걸리는 거리를 차를 끌고 가게 되었다. &lt;/p&gt;
&lt;p&gt;주차장에 도착해서 아이를 카시트에 앉혔다. 예전에 그렇게 차에 타기 싫어하던 아이의 모습은 어디 간 것일까. 그래도 이 모습은 다행이라면 다행이다.&lt;/p&gt;
&lt;p&gt;어쨌든 운전석에 앉았다. 그리고 시동을 걸고 출발했다. 이대로 조심히 운전해서 느긋하게 갔다 오면 될 터였다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"흘렸어!"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;출발한지 얼마 안 되어 뒷좌석에서 갑자기 울린 외침이었다. 아이가 지퍼백에 담아 둔 젤리를 꺼내다 흘린 모양이다.&lt;/p&gt;
&lt;p&gt;'주우면 되겠지'라는 단순한 생각이 들고 이후 몇 개를 흘렸는지 물어봤다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"두 개!"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;... &lt;/p&gt;
&lt;p&gt;'어쨌든 주우면 되겠지. 흘렸다고 안 우는 것만 해도 어디일까.'&lt;/p&gt;
&lt;p&gt;가까운 거리라 금새 어린이집에 도착했다. 대충 차를 대놓고 아이를 어린이집에 데려갔다. 원하는 바를 이룬 아이는 순순히 선생님 손을 잡고 어린이집으로 들어갔다.&lt;/p&gt;
&lt;p&gt;찰나의 평화를 즐긴 후 다시 차에 돌아와 뒷좌석 카시트 주변을 살펴봤다. 2개나 흘렸다던 젤리를 찾기 위해서다. &lt;/p&gt;
&lt;p&gt;그리고 한참을 뒤적거리다 결국 하나를 찾았다.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;문제가 있다면 나머지 하나를 아직도 찾지 못 했다는 점이다.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;뜨거운 여름, 지하 주차장 따위 없는 오래된 아파트 지상 주차장에 차를 대놓고 있어야 하는 상황에 젤리가 차 안 어딘가에 떨어져 있다. 이 정도 더위면 차 안은 엄청 뜨거워지고 젤리는 녹아 내릴 것이다. 녹아내려서 시트에 끈적하게 달라붙어 나중에 청소도 쉽지 않게 하고 냄새도 나게 하고 벌레도 꼬이게 할 지도 모를 젤리가 어딘가에 숨어있다.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;'끔찍하다.'&lt;/p&gt;
&lt;p&gt;'살려줘.'&lt;/p&gt;
&lt;p&gt;'으앙.'&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;아이가 어린이집에 가야 할 시간에 있었던 작고 사소하지만 끔찍한 이야기다.&lt;/p&gt;
&lt;p&gt;아이는 준비를 다 마쳤는데 오늘도 뭔가를 먹으면서 가고 싶다고 한다. 밖에서 뭔가 먹는 걸 굉장히 즐기는 시기 같다. 어쨌든 늘 그랬다시피 작은 비닐 지퍼백을 하나 꺼내서 여기다 늘 먹던 젤리를 3개만 담게 했다.&lt;/p&gt;
&lt;p&gt;여기까진 평화로웠는데, 갑자기 아이가 어린이집까지 차를 태워 달라고 떼를 쓴다. 지구영웅은 가까운 거리를 걸어간다고 설득해도 통하지 않았다.&lt;/p&gt;
&lt;p&gt;어쩔 수 없이 걸어가도 15분도 안 걸리는 거리를 차를 끌고 가게 되었다. &lt;/p&gt;
&lt;p&gt;주차장에 도착해서 아이를 카시트에 앉혔다. 예전에 그렇게 차에 타기 싫어하던 아이의 모습은 어디 간 것일까. 그래도 이 모습은 다행이라면 다행이다.&lt;/p&gt;
&lt;p&gt;어쨌든 운전석에 앉았다. 그리고 시동을 걸고 출발했다. 이대로 조심히 운전해서 느긋하게 갔다 오면 될 터였다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"흘렸어!"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;출발한지 얼마 안 되어 뒷좌석에서 갑자기 울린 외침이었다. 아이가 지퍼백에 담아 둔 젤리를 꺼내다 흘린 모양이다.&lt;/p&gt;
&lt;p&gt;'주우면 되겠지'라는 단순한 생각이 들고 이후 몇 개를 흘렸는지 물어봤다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"두 개!"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;... &lt;/p&gt;
&lt;p&gt;'어쨌든 주우면 되겠지. 흘렸다고 안 우는 것만 해도 어디일까.'&lt;/p&gt;
&lt;p&gt;가까운 거리라 금새 어린이집에 도착했다. 대충 차를 대놓고 아이를 어린이집에 데려갔다. 원하는 바를 이룬 아이는 순순히 선생님 손을 잡고 어린이집으로 들어갔다.&lt;/p&gt;
&lt;p&gt;찰나의 평화를 즐긴 후 다시 차에 돌아와 뒷좌석 카시트 주변을 살펴봤다. 2개나 흘렸다던 젤리를 찾기 위해서다. &lt;/p&gt;
&lt;p&gt;그리고 한참을 뒤적거리다 결국 하나를 찾았다.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;문제가 있다면 나머지 하나를 아직도 찾지 못 했다는 점이다.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;뜨거운 여름, 지하 주차장 따위 없는 오래된 아파트 지상 주차장에 차를 대놓고 있어야 하는 상황에 젤리가 차 안 어딘가에 떨어져 있다. 이 정도 더위면 차 안은 엄청 뜨거워지고 젤리는 녹아 내릴 것이다. 녹아내려서 시트에 끈적하게 달라붙어 나중에 청소도 쉽지 않게 하고 냄새도 나게 하고 벌레도 꼬이게 할 지도 모를 젤리가 어딘가에 숨어있다.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;'끔찍하다.'&lt;/p&gt;
&lt;p&gt;'살려줘.'&lt;/p&gt;
&lt;p&gt;'으앙.'&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240712-00.html</guid>
      <pubDate>Fri, 12 Jul 2024 10:12:00 +0900</pubDate>
    </item>
    <item>
      <title>CPI가 잘 나왔지만 뭐 어쩌라는 걸까</title>
      <link>https://seorenn.github.io/log/20240711-02.html</link>
      <description>&lt;p&gt;미국의 6월 CPI가 발표되었다. 정리하자면 아주 잘 나왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 6월 헤드라인 CPI MoM -0.1% (-0.1%), YoY 3.0% (-0.3%)&lt;/li&gt;
&lt;li&gt;미국 6월 근원 CPI MoM 0.1% (-0.1%), YoY 3.3% (-0.1%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;무려 전월비 헤드라인 CPI가 역성장했다. 물가가 오히려 떨어졌다는 말인데 상당히 이례적인 일이다. 아마도 끈질겼던 주거비 둔화가 나타나고 있는 모양이다.&lt;/p&gt;
&lt;p&gt;그 외에 특징이 있다면 모든 지표가 예상치를 하회했다는 점 같다.&lt;/p&gt;
&lt;p&gt;같이 발표된 실업수당청구건수는 예상보다 낮게 나오면서 죽지 않는 노동시장에 대한 노이로제가 또 발동되는 거 아닌가 약간은 걱정스럽기도 하다.&lt;/p&gt;
&lt;p&gt;그렇다면 실제 시장의 반응은 어떨까. &lt;/p&gt;
&lt;p&gt;최근 많이 올라서인지 아니면 실업수당 때문인지 나스닥과 S&amp;amp;P500은 떨어지고 있는 것 같다. 이는 국장에 긍정적인 요소는 아닐 것 같다.&lt;/p&gt;
&lt;p&gt;반대로 다우지수 쪽은 최근 하락세가 길었던 만큼 반대로 오르는 것처럼 보이기도 하지만 국장에 큰 의미는 없을 것 같다. &lt;/p&gt;
&lt;p&gt;그런데 금리에 민감한 러셀2000이 제법 오르고 있다. 그리고 코스피는 이 녀석과 비슷하게 움직일 때가 많다. 이대로 마감 된다면 내일 국장은 나쁘진 않을 지도 모른다. &lt;/p&gt;
&lt;p&gt;그런데 필라델피아 반도체 지수는 또 떨어지고 있다. 이러면 삼성전자와 하이닉스 등 반도체 주가가 안 좋고 결국 내일 국장은 또한 안 좋을 수 있다. &lt;/p&gt;
&lt;p&gt;파월 청문회를 좋게 해석하는 건지 미 국채들도 잘 팔리면서 금리가 제법 떨어지고 있다. 덕분에 달러지수도 떨어지고 그래서 원달러 환율도 내려가는 긍정적인 효과가 보이고 있다. 그리고 이러면 내일 국장은 좋은 분위기가 나올 수도 있다.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;아 도대체 뭐 어쩌라는 걸까. 세상 참 편하게 살기 어렵다. 뭐 하나 공식에 딱 맞게 떨어지는 모두가 돈을 버는 공평한 세상... 따위 없는 게 당연하겠지. &lt;/p&gt;
&lt;p&gt;매크로는 역시나 큰 추세만 보는 게 맞을 것 같다. 내일 국장이 어떻게 될지 아니 당장 미장은 어떻게 될지 생각해서 뭐 할까. 예측 보다는 역시 모든 상황 대비에 신경 쓰는 게 맞을 것 같다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;미국의 6월 CPI가 발표되었다. 정리하자면 아주 잘 나왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 6월 헤드라인 CPI MoM -0.1% (-0.1%), YoY 3.0% (-0.3%)&lt;/li&gt;
&lt;li&gt;미국 6월 근원 CPI MoM 0.1% (-0.1%), YoY 3.3% (-0.1%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;무려 전월비 헤드라인 CPI가 역성장했다. 물가가 오히려 떨어졌다는 말인데 상당히 이례적인 일이다. 아마도 끈질겼던 주거비 둔화가 나타나고 있는 모양이다.&lt;/p&gt;
&lt;p&gt;그 외에 특징이 있다면 모든 지표가 예상치를 하회했다는 점 같다.&lt;/p&gt;
&lt;p&gt;같이 발표된 실업수당청구건수는 예상보다 낮게 나오면서 죽지 않는 노동시장에 대한 노이로제가 또 발동되는 거 아닌가 약간은 걱정스럽기도 하다.&lt;/p&gt;
&lt;p&gt;그렇다면 실제 시장의 반응은 어떨까. &lt;/p&gt;
&lt;p&gt;최근 많이 올라서인지 아니면 실업수당 때문인지 나스닥과 S&amp;amp;P500은 떨어지고 있는 것 같다. 이는 국장에 긍정적인 요소는 아닐 것 같다.&lt;/p&gt;
&lt;p&gt;반대로 다우지수 쪽은 최근 하락세가 길었던 만큼 반대로 오르는 것처럼 보이기도 하지만 국장에 큰 의미는 없을 것 같다. &lt;/p&gt;
&lt;p&gt;그런데 금리에 민감한 러셀2000이 제법 오르고 있다. 그리고 코스피는 이 녀석과 비슷하게 움직일 때가 많다. 이대로 마감 된다면 내일 국장은 나쁘진 않을 지도 모른다. &lt;/p&gt;
&lt;p&gt;그런데 필라델피아 반도체 지수는 또 떨어지고 있다. 이러면 삼성전자와 하이닉스 등 반도체 주가가 안 좋고 결국 내일 국장은 또한 안 좋을 수 있다. &lt;/p&gt;
&lt;p&gt;파월 청문회를 좋게 해석하는 건지 미 국채들도 잘 팔리면서 금리가 제법 떨어지고 있다. 덕분에 달러지수도 떨어지고 그래서 원달러 환율도 내려가는 긍정적인 효과가 보이고 있다. 그리고 이러면 내일 국장은 좋은 분위기가 나올 수도 있다.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;아 도대체 뭐 어쩌라는 걸까. 세상 참 편하게 살기 어렵다. 뭐 하나 공식에 딱 맞게 떨어지는 모두가 돈을 버는 공평한 세상... 따위 없는 게 당연하겠지. &lt;/p&gt;
&lt;p&gt;매크로는 역시나 큰 추세만 보는 게 맞을 것 같다. 내일 국장이 어떻게 될지 아니 당장 미장은 어떻게 될지 생각해서 뭐 할까. 예측 보다는 역시 모든 상황 대비에 신경 쓰는 게 맞을 것 같다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240711-02.html</guid>
      <pubDate>Thu, 11 Jul 2024 23:44:00 +0900</pubDate>
    </item>
    <item>
      <title>중요하지만 왠지 소외된 한국 기준금리 동결 소식</title>
      <link>https://seorenn.github.io/log/20240711-01.html</link>
      <description>&lt;p&gt;한국은행 금통위는 상당히 중요한 이벤트임에도 &lt;a href="../log/20240711-00.html"&gt;파월 청문회&lt;/a&gt; 소식에 개인적으로 뇌리에서 잊혀져 버렸다. 어쨌든 간에 오늘 금통위가 있었고 결과야 다들 예상하던 그거가 나왔다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;한국은행은 금융통화위원회를 통해 기준금리를 3.5%로 만장일치로 동결 결정하였다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;동결 결정 자체가 어떻든 이제는 인하 의견이 얼마나 나오는 지가 핵심이 된 듯하다. 마침 물가도 잡히고 것처럼 보이기도 하니 인하 의견이 더 나올 시점인 것 같기도 하다.&lt;/p&gt;
&lt;p&gt;정리하자면 금통위원 6인 중 4인은 향후 3개월 간 동결, 2인은 3개월 내 인하 의견을 냈다고 한다. 인하 의견이 좀 더 늘었다는 점에서 이제 다음 혹은 다다음 회의 부터는 인하 확률이 높아질 수도 있다는 말일 거다.&lt;/p&gt;
&lt;p&gt;하지만 이창용 총재도 인터뷰를 통해 밝혔다시피 인하가 실제로 언제 이뤄질지는 알 수가 없을 것 같다. 적어도 미국이 먼저 인하해야 그나마 인하 여력이 생길 테니 베팅은 그 이후로 하는 게 당연해 보인다.&lt;/p&gt;
&lt;p&gt;거기다 최근 가계부채가 다시 오르는 조짐을 보이는 것에도 한은은 어떻게든 대처를 해야 할 테고 말이다.&lt;/p&gt;
&lt;p&gt;그럼 9월은 미국 인하, 10월은 한국 인하 이렇게 봐도 될까? 베팅할 수 있다면 작게 해보고 싶기는 하지만 요즘 생활이 쪼들리니 참아야 할 것 같다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;한국은행 금통위는 상당히 중요한 이벤트임에도 &lt;a href="../log/20240711-00.html"&gt;파월 청문회&lt;/a&gt; 소식에 개인적으로 뇌리에서 잊혀져 버렸다. 어쨌든 간에 오늘 금통위가 있었고 결과야 다들 예상하던 그거가 나왔다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;한국은행은 금융통화위원회를 통해 기준금리를 3.5%로 만장일치로 동결 결정하였다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;동결 결정 자체가 어떻든 이제는 인하 의견이 얼마나 나오는 지가 핵심이 된 듯하다. 마침 물가도 잡히고 것처럼 보이기도 하니 인하 의견이 더 나올 시점인 것 같기도 하다.&lt;/p&gt;
&lt;p&gt;정리하자면 금통위원 6인 중 4인은 향후 3개월 간 동결, 2인은 3개월 내 인하 의견을 냈다고 한다. 인하 의견이 좀 더 늘었다는 점에서 이제 다음 혹은 다다음 회의 부터는 인하 확률이 높아질 수도 있다는 말일 거다.&lt;/p&gt;
&lt;p&gt;하지만 이창용 총재도 인터뷰를 통해 밝혔다시피 인하가 실제로 언제 이뤄질지는 알 수가 없을 것 같다. 적어도 미국이 먼저 인하해야 그나마 인하 여력이 생길 테니 베팅은 그 이후로 하는 게 당연해 보인다.&lt;/p&gt;
&lt;p&gt;거기다 최근 가계부채가 다시 오르는 조짐을 보이는 것에도 한은은 어떻게든 대처를 해야 할 테고 말이다.&lt;/p&gt;
&lt;p&gt;그럼 9월은 미국 인하, 10월은 한국 인하 이렇게 봐도 될까? 베팅할 수 있다면 작게 해보고 싶기는 하지만 요즘 생활이 쪼들리니 참아야 할 것 같다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240711-01.html</guid>
      <pubDate>Thu, 11 Jul 2024 15:18:00 +0900</pubDate>
    </item>
    <item>
      <title>이번 청문회 파월의 발언은 어땠나</title>
      <link>https://seorenn.github.io/log/20240711-00.html</link>
      <description>&lt;p&gt;연 이틀간 미 국회에서 열린 금융 관련 청문회가 화제를 모았다. 당연하게도 전 세계 경제에 막대한 영향을 끼치는 연준의 수장이 출석하기 때문이었다. 이미 잘 알려졌지만 그의 발언이 어땠는지 대충 정리해 보려고 한다.&lt;/p&gt;
&lt;h2&gt;첫째날 상원 청문회&lt;/h2&gt;
&lt;p&gt;정치의 장이기도 한 국회인 만큼 다분히 정치적인 공격이 많은 곳이었지만 파월은 이곳에서 정치적으로 중립적이며 연준 의장으로써도 모호한 자세를 취했다. 아마도 "나는 어쨌든 중립이어야 한다"라고 주장하는 듯했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기저기 잘 피해다니는 '비둘기 도법 Lv Max'을 구사하시는 파월 형님이셨다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;대충 정리하자면 아래의 발언들이 있었다. 직역도 의역도 아니라 개인적으로 알아듣기 좋게 완전히 바꾼 문장도 있음에 주의하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최근 지표는 긍정적이나 데이터를 더 봐야 한다.&lt;/li&gt;
&lt;li&gt;지속되는 고금리는 경제에 위해를 가할 것이다.&lt;/li&gt;
&lt;li&gt;노동시장은 인플레이션의 위협적이지 않을 만큼 둔화되고 있다. 최근 실업률은 아직 양호한 수준이지만 더 올라가는 건 걱정스러운 일이.&lt;/li&gt;
&lt;li&gt;금리 인하 시기는 특정할 수 없지만 매 회의 때마다 결정될 수도 있다.&lt;/li&gt;
&lt;li&gt;향후 정책 방향에 대해 신호를 주지 않을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;둘째날 하원 청문회&lt;/h2&gt;
&lt;p&gt;다음 날은 하원 청문회였다. 여기서도 당연하겠지만 파월은 전날과 같은 자세를 굳히고 있었다. 유독 눈에 띄는 발언은 아래 하나로 정리할 수 있을 것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;인플레이션 목표치 2% 달성까지 기다리지 않을 것 (?!)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;뭔가 좀 더 비둘기 적인 느낌이 된 것 같은데 어쩌면 이틀 째 이어지는 공격에 좀 시달린 것 같기도 하다. 안 그래도 최근 대선 때문에 스트레스를 많이 받고 있을 것 같은데 말이다.&lt;/p&gt;
&lt;h2&gt;정리&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;결론: '9월 인하' 카드가 테이블에 올라왔다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;그리고&lt;/h2&gt;
&lt;p&gt;적을 게 없으니 그냥 시장 반응이나 또 붙여봐야겠다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FedWatch" src="../upload/202407111341-ecb781c0.png" /&gt;
&lt;em&gt;FedWatch&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;마지막으로 올렸던 베팅표에서 9월 인하 확률이 많이 올라가긴 했다. 다만 최근의 피크에서는 좀 낮아졌다는 소리를 들었는데 뭐 그래도 거기서 거기 같다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;연 이틀간 미 국회에서 열린 금융 관련 청문회가 화제를 모았다. 당연하게도 전 세계 경제에 막대한 영향을 끼치는 연준의 수장이 출석하기 때문이었다. 이미 잘 알려졌지만 그의 발언이 어땠는지 대충 정리해 보려고 한다.&lt;/p&gt;
&lt;h2&gt;첫째날 상원 청문회&lt;/h2&gt;
&lt;p&gt;정치의 장이기도 한 국회인 만큼 다분히 정치적인 공격이 많은 곳이었지만 파월은 이곳에서 정치적으로 중립적이며 연준 의장으로써도 모호한 자세를 취했다. 아마도 "나는 어쨌든 중립이어야 한다"라고 주장하는 듯했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기저기 잘 피해다니는 '비둘기 도법 Lv Max'을 구사하시는 파월 형님이셨다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;대충 정리하자면 아래의 발언들이 있었다. 직역도 의역도 아니라 개인적으로 알아듣기 좋게 완전히 바꾼 문장도 있음에 주의하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최근 지표는 긍정적이나 데이터를 더 봐야 한다.&lt;/li&gt;
&lt;li&gt;지속되는 고금리는 경제에 위해를 가할 것이다.&lt;/li&gt;
&lt;li&gt;노동시장은 인플레이션의 위협적이지 않을 만큼 둔화되고 있다. 최근 실업률은 아직 양호한 수준이지만 더 올라가는 건 걱정스러운 일이.&lt;/li&gt;
&lt;li&gt;금리 인하 시기는 특정할 수 없지만 매 회의 때마다 결정될 수도 있다.&lt;/li&gt;
&lt;li&gt;향후 정책 방향에 대해 신호를 주지 않을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;둘째날 하원 청문회&lt;/h2&gt;
&lt;p&gt;다음 날은 하원 청문회였다. 여기서도 당연하겠지만 파월은 전날과 같은 자세를 굳히고 있었다. 유독 눈에 띄는 발언은 아래 하나로 정리할 수 있을 것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;인플레이션 목표치 2% 달성까지 기다리지 않을 것 (?!)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;뭔가 좀 더 비둘기 적인 느낌이 된 것 같은데 어쩌면 이틀 째 이어지는 공격에 좀 시달린 것 같기도 하다. 안 그래도 최근 대선 때문에 스트레스를 많이 받고 있을 것 같은데 말이다.&lt;/p&gt;
&lt;h2&gt;정리&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;결론: '9월 인하' 카드가 테이블에 올라왔다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;그리고&lt;/h2&gt;
&lt;p&gt;적을 게 없으니 그냥 시장 반응이나 또 붙여봐야겠다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FedWatch" src="../upload/202407111341-ecb781c0.png" /&gt;
&lt;em&gt;FedWatch&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;마지막으로 올렸던 베팅표에서 9월 인하 확률이 많이 올라가긴 했다. 다만 최근의 피크에서는 좀 낮아졌다는 소리를 들었는데 뭐 그래도 거기서 거기 같다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240711-00.html</guid>
      <pubDate>Thu, 11 Jul 2024 13:43:00 +0900</pubDate>
    </item>
    <item>
      <title>Poetry 소개 및 간단한 사용법 정리</title>
      <link>https://seorenn.github.io/article/python-poetry.html</link>
      <description>&lt;p&gt;Poetry는 Python용 패키징 겸 의존성 관리를 도와주는 도구로 pip나 virtualenv를 좀 더 포괄적으로 그리고 현대적으로 사용할 수 있게 도와준다. 이 Poetry의 사용법을 간단히 알아보자.&lt;/p&gt;
&lt;h2&gt;프로젝트 시작하기&lt;/h2&gt;
&lt;p&gt;Poetry는 당연하겠지만 프로젝트 단위로 사용할 수 있다. 그래서 사용하기 위해선 아래와 같이 &lt;code&gt;new&lt;/code&gt; 커맨드로 프로젝트를 생성해야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry new PROJECT_NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 몇몇 확인 단계를 거쳐 새로운 파이썬 프로젝트를 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;만약 이미 존재하는 프로젝트에 Poetry 환경만 구성하고 싶다면 아래와 같이 &lt;code&gt;init&lt;/code&gt; 커맨드를 사용해 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 두 커맨드 모두 핵심으로 프로젝트 루트에 &lt;code&gt;pyproject.toml&lt;/code&gt;이라는 파일을 생성한다. 이름대로 프로젝트 정의 및 의존성 목록을 담은 중요한 파일이다.&lt;/p&gt;
&lt;h2&gt;의존성 관리하기&lt;/h2&gt;
&lt;p&gt;프로젝트에 의존성을 추가하려면 아래와 같이 &lt;code&gt;add&lt;/code&gt; 커맨드를 사용하면 된다. 여기에 특정 버전을 명시할 수도 있고, 개발 모드 전용 의존성일 경우 &lt;code&gt;--dev&lt;/code&gt; 플래그도 추가해 줄 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry add PACKAGE_NAME
poetry add ANOTHER_PACKAGE_NAME==x.y.z
poetry add --dev PACKAGE_NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 명령들은 프로젝트의 virtualenv 환경에 자동으로 설치까지 진행된다.&lt;/p&gt;
&lt;p&gt;의존성 패키지를 삭제하려면 &lt;code&gt;remove&lt;/code&gt; 커맨드를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;poetry remove PACKAGE_NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 외에 사용하는 의존성 패키지들의 버전을 일괄적으로 업데이트 하려면 &lt;code&gt;update&lt;/code&gt; 커맨드를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 &lt;code&gt;pyproject.toml&lt;/code&gt; 스펙에 적힌 한도 내에서 최신 버전으로 업데이트 된다.&lt;/p&gt;
&lt;h2&gt;수작업으로 의존성 관리하기&lt;/h2&gt;
&lt;p&gt;CLI 커맨드 보다 수작업을 좋아한다면 &lt;code&gt;pyproject.toml&lt;/code&gt; 파일을 열어서 직접 명시해 주는 방법도 있다. 예를 들자면 이런 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;[tool.poetry.dependencies]
python = &amp;quot;^3.8&amp;quot;
somepackage = &amp;quot;^3.10.0&amp;quot;

[tool.poetry.dev-dependencies]
pytest = &amp;quot;^5.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;버전 앞에 붙인 꺽쇠(&lt;code&gt;^&lt;/code&gt;)의 의미는 '메이저 업데이트를 제외한 최신 버전' 이라는 의미이다. 즉 &lt;code&gt;^3.10.0&lt;/code&gt;이라는 의미는 &lt;code&gt;3.x.y&lt;/code&gt; 버전 중 가장 최신 버전을 사용한다는 의미다.&lt;/p&gt;
&lt;p&gt;이렇게 작성한 후 &lt;code&gt;install&lt;/code&gt; 커맨드를 사용하면 프로젝트의 virtualenv 환경에 일괄 패키지 설치가 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;poetry install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 커맨드를 보고 &lt;code&gt;pip install -r requirements.txt&lt;/code&gt;라는 커맨드가 떠오른다면 정답이다. 즉 이 커맨드를 &lt;code&gt;poetry install&lt;/code&gt; 커맨드로 완전히 대체할 수 있다.&lt;/p&gt;
&lt;h2&gt;프로젝트 실행하기&lt;/h2&gt;
&lt;p&gt;프로젝트를 실행시키기 위해서는 &lt;code&gt;run&lt;/code&gt; 커맨드를 사용하면 된다. 예를 들어 실행시킬 엔트리포인트 파일이 &lt;code&gt;main.py&lt;/code&gt;라면 아래와 같은 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry run python main.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경우 해당 프로젝트의 virtualenv 환경에서 &lt;code&gt;run&lt;/code&gt; 뒤의 커맨드가 실행되는 식이다.&lt;/p&gt;
&lt;h2&gt;virtualenv 셸 얻기&lt;/h2&gt;
&lt;p&gt;프로젝트의 virtualenv 환경에서 여러 가지를 시험해 보기 위해 셸을 얻고 싶다면 단순하게 &lt;code&gt;shell&lt;/code&gt; 커맨드를 사용하면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry shell
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Docker와 Poetry&lt;/h2&gt;
&lt;p&gt;Poetry의 특징은 virtualenv 환경을 자동으로 통합하는 것이다. 그리고 Docker 컨테이너는 프로젝트 단위로 독립된 환경을 구축하려는 의도가 있다. 결과적으로 해당 프로젝트를 Docker 컨테이너 내에서 돌린다면 Poetry의 virtualenv 환경 통합 기능은 불필요할 수도 있다.&lt;/p&gt;
&lt;p&gt;그럴 때는 간단하게 아래 커맨드로 virtualenv 환경을 생성하지 않도록 설정해 줄 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry config virtualenvs.create false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 커맨드는 Poetry의 virtualenv를 비활성화 시키므로 &lt;code&gt;Dockerfile&lt;/code&gt; 등에 &lt;code&gt;poetry install&lt;/code&gt; 커맨드를 실행하기 전에 동작하도록 작성하면 될 것 같다.&lt;/p&gt;
&lt;h2&gt;기타&lt;/h2&gt;
&lt;p&gt;Poetry 자체를 업그레이드 하려면 &lt;code&gt;self update&lt;/code&gt; 커맨드를 사용해 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;poetry self update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다만 Homebrew 등의 다른 패키지 매니저를 통해 Poetry를 설치했다면 위 커맨드를 신경 쓸 필요는 없을 것 같다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;Poetry는 Python용 패키징 겸 의존성 관리를 도와주는 도구로 pip나 virtualenv를 좀 더 포괄적으로 그리고 현대적으로 사용할 수 있게 도와준다. 이 Poetry의 사용법을 간단히 알아보자.&lt;/p&gt;
&lt;h2&gt;프로젝트 시작하기&lt;/h2&gt;
&lt;p&gt;Poetry는 당연하겠지만 프로젝트 단위로 사용할 수 있다. 그래서 사용하기 위해선 아래와 같이 &lt;code&gt;new&lt;/code&gt; 커맨드로 프로젝트를 생성해야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry new PROJECT_NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 몇몇 확인 단계를 거쳐 새로운 파이썬 프로젝트를 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;만약 이미 존재하는 프로젝트에 Poetry 환경만 구성하고 싶다면 아래와 같이 &lt;code&gt;init&lt;/code&gt; 커맨드를 사용해 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 두 커맨드 모두 핵심으로 프로젝트 루트에 &lt;code&gt;pyproject.toml&lt;/code&gt;이라는 파일을 생성한다. 이름대로 프로젝트 정의 및 의존성 목록을 담은 중요한 파일이다.&lt;/p&gt;
&lt;h2&gt;의존성 관리하기&lt;/h2&gt;
&lt;p&gt;프로젝트에 의존성을 추가하려면 아래와 같이 &lt;code&gt;add&lt;/code&gt; 커맨드를 사용하면 된다. 여기에 특정 버전을 명시할 수도 있고, 개발 모드 전용 의존성일 경우 &lt;code&gt;--dev&lt;/code&gt; 플래그도 추가해 줄 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry add PACKAGE_NAME
poetry add ANOTHER_PACKAGE_NAME==x.y.z
poetry add --dev PACKAGE_NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 명령들은 프로젝트의 virtualenv 환경에 자동으로 설치까지 진행된다.&lt;/p&gt;
&lt;p&gt;의존성 패키지를 삭제하려면 &lt;code&gt;remove&lt;/code&gt; 커맨드를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;poetry remove PACKAGE_NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 외에 사용하는 의존성 패키지들의 버전을 일괄적으로 업데이트 하려면 &lt;code&gt;update&lt;/code&gt; 커맨드를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 &lt;code&gt;pyproject.toml&lt;/code&gt; 스펙에 적힌 한도 내에서 최신 버전으로 업데이트 된다.&lt;/p&gt;
&lt;h2&gt;수작업으로 의존성 관리하기&lt;/h2&gt;
&lt;p&gt;CLI 커맨드 보다 수작업을 좋아한다면 &lt;code&gt;pyproject.toml&lt;/code&gt; 파일을 열어서 직접 명시해 주는 방법도 있다. 예를 들자면 이런 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;[tool.poetry.dependencies]
python = &amp;quot;^3.8&amp;quot;
somepackage = &amp;quot;^3.10.0&amp;quot;

[tool.poetry.dev-dependencies]
pytest = &amp;quot;^5.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;버전 앞에 붙인 꺽쇠(&lt;code&gt;^&lt;/code&gt;)의 의미는 '메이저 업데이트를 제외한 최신 버전' 이라는 의미이다. 즉 &lt;code&gt;^3.10.0&lt;/code&gt;이라는 의미는 &lt;code&gt;3.x.y&lt;/code&gt; 버전 중 가장 최신 버전을 사용한다는 의미다.&lt;/p&gt;
&lt;p&gt;이렇게 작성한 후 &lt;code&gt;install&lt;/code&gt; 커맨드를 사용하면 프로젝트의 virtualenv 환경에 일괄 패키지 설치가 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;poetry install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 커맨드를 보고 &lt;code&gt;pip install -r requirements.txt&lt;/code&gt;라는 커맨드가 떠오른다면 정답이다. 즉 이 커맨드를 &lt;code&gt;poetry install&lt;/code&gt; 커맨드로 완전히 대체할 수 있다.&lt;/p&gt;
&lt;h2&gt;프로젝트 실행하기&lt;/h2&gt;
&lt;p&gt;프로젝트를 실행시키기 위해서는 &lt;code&gt;run&lt;/code&gt; 커맨드를 사용하면 된다. 예를 들어 실행시킬 엔트리포인트 파일이 &lt;code&gt;main.py&lt;/code&gt;라면 아래와 같은 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry run python main.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경우 해당 프로젝트의 virtualenv 환경에서 &lt;code&gt;run&lt;/code&gt; 뒤의 커맨드가 실행되는 식이다.&lt;/p&gt;
&lt;h2&gt;virtualenv 셸 얻기&lt;/h2&gt;
&lt;p&gt;프로젝트의 virtualenv 환경에서 여러 가지를 시험해 보기 위해 셸을 얻고 싶다면 단순하게 &lt;code&gt;shell&lt;/code&gt; 커맨드를 사용하면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry shell
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Docker와 Poetry&lt;/h2&gt;
&lt;p&gt;Poetry의 특징은 virtualenv 환경을 자동으로 통합하는 것이다. 그리고 Docker 컨테이너는 프로젝트 단위로 독립된 환경을 구축하려는 의도가 있다. 결과적으로 해당 프로젝트를 Docker 컨테이너 내에서 돌린다면 Poetry의 virtualenv 환경 통합 기능은 불필요할 수도 있다.&lt;/p&gt;
&lt;p&gt;그럴 때는 간단하게 아래 커맨드로 virtualenv 환경을 생성하지 않도록 설정해 줄 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;poetry config virtualenvs.create false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 커맨드는 Poetry의 virtualenv를 비활성화 시키므로 &lt;code&gt;Dockerfile&lt;/code&gt; 등에 &lt;code&gt;poetry install&lt;/code&gt; 커맨드를 실행하기 전에 동작하도록 작성하면 될 것 같다.&lt;/p&gt;
&lt;h2&gt;기타&lt;/h2&gt;
&lt;p&gt;Poetry 자체를 업그레이드 하려면 &lt;code&gt;self update&lt;/code&gt; 커맨드를 사용해 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;poetry self update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다만 Homebrew 등의 다른 패키지 매니저를 통해 Poetry를 설치했다면 위 커맨드를 신경 쓸 필요는 없을 것 같다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-poetry.html</guid>
      <pubDate>Tue, 09 Jul 2024 23:40:00 +0900</pubDate>
    </item>
    <item>
      <title>Emacs Lisp에서 비동기 호출 코드 작성하기</title>
      <link>https://seorenn.github.io/article/emacs-lisp-async-call.html</link>
      <description>&lt;p&gt;그렇게 자주 있는 일은 아니겠지만 이맥스의 UI를 얼려버릴 만큼 무거운 코드를 돌려야 할 일이 있다면 느낌이 어떨까. 이맥스가 얼어버리는 현상은 결코 유쾌하지는 못 할 것이다. 그동안 다른 작업도 못 하고 말이다.&lt;/p&gt;
&lt;p&gt;그렇다면 비동기로 호출하면 이런 문제를 해결할 수 있지 않을까? 간단하게 이맥스에서 비동기로 코드를 호출하는 방법을 정리해 보자.&lt;/p&gt;
&lt;h2&gt;run-with-idle-timer&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(run-with-idle-timer 3 nil #'my-function)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;run-with-idle-timer&lt;/code&gt; 함수는 지정된 시간이 지난 후 이맥스가 쉬는(idle) 도중에 지정한 함수를 비동기로 호출한다.&lt;/p&gt;
&lt;p&gt;두 번째 인자는 반복 여부라 원하는 반복 횟수를 적어줄 수도 있다.&lt;/p&gt;
&lt;h2&gt;run-with-timer&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(run-with-timer 3 nil #'my-function)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;run-with-timer&lt;/code&gt; 함수도 지정된 시간이 지난 후 지정한 함수를 비동기로 호출한다. 다만 이맥스가 쉬든 말든 무작정 호출하는 듯하다.&lt;/p&gt;
&lt;p&gt;역시나 두 번째 인자로 반복 횟수를 지정할 수 있다.&lt;/p&gt;
&lt;h2&gt;async.el&lt;/h2&gt;
&lt;p&gt;순수하게 비동기 호출만을 생각하고 외부 패키지에 대해 열려있다면(?) async.el 혹은 emacs-async라는 패키지를 사용할 수도 있다. 이 패키지 내의 &lt;code&gt;async-start&lt;/code&gt; 함수를 이용할 수 있다고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;참고로 이 항목은 직접 돌려보진 않았고 그저 메모 목적으로 작성한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(async-start
  (lambda () (my-function)) 
  ;; callback
  (lambda (result) 
    (message &amp;quot;Result: %s&amp;quot; result)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 &lt;code&gt;async-start&lt;/code&gt; 함수는 두 개의 함수를 인자로 넘긴다. 첫 인자가 비동기로 호출할 함수이고 두 번째 인자는 비동기 실행 결과를 받아서 동작하는 함수다. 즉 위의 예의 경우 my-function이라는 함수가 비동기로 호출된 후 이 함수의 결과가 두 번째 인자의 함수에 첫 인자로 전달된다.&lt;/p&gt;
&lt;p&gt;만약 결과를 받을 필요가 없다면 무시(ignore) 심볼을 남겨주자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(async-start
  (lambda () (my-function)) 
  'ignore)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;쉴 시간 주기&lt;/h2&gt;
&lt;p&gt;이 항목은 비동기 처리 자체와는 관계가 없지만 약간의 덤이다. &lt;/p&gt;
&lt;p&gt;단순 비동기 호출이라도 과도한 작업은 당연하게도 이맥스를 얼려버리는 현상이 나타날 수밖에 없다. 이를 피하기 위해선 비동기 코드의 루프에서 쉴 시간을 조금씩 주는 편이 좋다. 예를 들자면 &lt;code&gt;sleep-for&lt;/code&gt; 함수가 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(sleep-for 1)  ;; wait for 1 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;쉬게만 한다면 위의 코드로도 충분하겠지만 좀 더 깔끔하게(?) 쉬려면 &lt;code&gt;sit-for&lt;/code&gt;를 사용하는 편이 좋다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(sit-for 1)  ;; redisplay and wait for 1 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sit-for&lt;/code&gt;는 &lt;code&gt;sleep-for&lt;/code&gt;와 비슷하지만 화면을 한번 갱신시켜 준다는 점이 특징이다.  그 외에 입력이 가능하게 되면 멈추는 등 비동기 작업 용도로는 &lt;code&gt;sleep-for&lt;/code&gt;에 비해 약간읜 전문적(?)인 느낌이다.&lt;/p&gt;
&lt;p&gt;참고로 쉬는 시간은 초(seconds) 단위인데 소수점 단위도 된다. 즉 0.1초나 0.01초 정도로 짧게 쉬는 것도 가능하다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/jwiegley/emacs-async" target="_blank"&gt;emacs-async📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-sharp-quote-sign.md.html"&gt;Emacs Lisp에서 샤프 작은따옴표(#') 기호의 의미&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;그렇게 자주 있는 일은 아니겠지만 이맥스의 UI를 얼려버릴 만큼 무거운 코드를 돌려야 할 일이 있다면 느낌이 어떨까. 이맥스가 얼어버리는 현상은 결코 유쾌하지는 못 할 것이다. 그동안 다른 작업도 못 하고 말이다.&lt;/p&gt;
&lt;p&gt;그렇다면 비동기로 호출하면 이런 문제를 해결할 수 있지 않을까? 간단하게 이맥스에서 비동기로 코드를 호출하는 방법을 정리해 보자.&lt;/p&gt;
&lt;h2&gt;run-with-idle-timer&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(run-with-idle-timer 3 nil #'my-function)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;run-with-idle-timer&lt;/code&gt; 함수는 지정된 시간이 지난 후 이맥스가 쉬는(idle) 도중에 지정한 함수를 비동기로 호출한다.&lt;/p&gt;
&lt;p&gt;두 번째 인자는 반복 여부라 원하는 반복 횟수를 적어줄 수도 있다.&lt;/p&gt;
&lt;h2&gt;run-with-timer&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(run-with-timer 3 nil #'my-function)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;run-with-timer&lt;/code&gt; 함수도 지정된 시간이 지난 후 지정한 함수를 비동기로 호출한다. 다만 이맥스가 쉬든 말든 무작정 호출하는 듯하다.&lt;/p&gt;
&lt;p&gt;역시나 두 번째 인자로 반복 횟수를 지정할 수 있다.&lt;/p&gt;
&lt;h2&gt;async.el&lt;/h2&gt;
&lt;p&gt;순수하게 비동기 호출만을 생각하고 외부 패키지에 대해 열려있다면(?) async.el 혹은 emacs-async라는 패키지를 사용할 수도 있다. 이 패키지 내의 &lt;code&gt;async-start&lt;/code&gt; 함수를 이용할 수 있다고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;참고로 이 항목은 직접 돌려보진 않았고 그저 메모 목적으로 작성한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(async-start
  (lambda () (my-function)) 
  ;; callback
  (lambda (result) 
    (message &amp;quot;Result: %s&amp;quot; result)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 &lt;code&gt;async-start&lt;/code&gt; 함수는 두 개의 함수를 인자로 넘긴다. 첫 인자가 비동기로 호출할 함수이고 두 번째 인자는 비동기 실행 결과를 받아서 동작하는 함수다. 즉 위의 예의 경우 my-function이라는 함수가 비동기로 호출된 후 이 함수의 결과가 두 번째 인자의 함수에 첫 인자로 전달된다.&lt;/p&gt;
&lt;p&gt;만약 결과를 받을 필요가 없다면 무시(ignore) 심볼을 남겨주자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(async-start
  (lambda () (my-function)) 
  'ignore)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;쉴 시간 주기&lt;/h2&gt;
&lt;p&gt;이 항목은 비동기 처리 자체와는 관계가 없지만 약간의 덤이다. &lt;/p&gt;
&lt;p&gt;단순 비동기 호출이라도 과도한 작업은 당연하게도 이맥스를 얼려버리는 현상이 나타날 수밖에 없다. 이를 피하기 위해선 비동기 코드의 루프에서 쉴 시간을 조금씩 주는 편이 좋다. 예를 들자면 &lt;code&gt;sleep-for&lt;/code&gt; 함수가 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(sleep-for 1)  ;; wait for 1 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;쉬게만 한다면 위의 코드로도 충분하겠지만 좀 더 깔끔하게(?) 쉬려면 &lt;code&gt;sit-for&lt;/code&gt;를 사용하는 편이 좋다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(sit-for 1)  ;; redisplay and wait for 1 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sit-for&lt;/code&gt;는 &lt;code&gt;sleep-for&lt;/code&gt;와 비슷하지만 화면을 한번 갱신시켜 준다는 점이 특징이다.  그 외에 입력이 가능하게 되면 멈추는 등 비동기 작업 용도로는 &lt;code&gt;sleep-for&lt;/code&gt;에 비해 약간읜 전문적(?)인 느낌이다.&lt;/p&gt;
&lt;p&gt;참고로 쉬는 시간은 초(seconds) 단위인데 소수점 단위도 된다. 즉 0.1초나 0.01초 정도로 짧게 쉬는 것도 가능하다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/jwiegley/emacs-async" target="_blank"&gt;emacs-async📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-sharp-quote-sign.md.html"&gt;Emacs Lisp에서 샤프 작은따옴표(#') 기호의 의미&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/emacs-lisp-async-call.html</guid>
      <pubDate>Mon, 08 Jul 2024 14:41:00 +0900</pubDate>
    </item>
    <item>
      <title>한 주 간의 애플 소식들 24-07-07</title>
      <link>https://seorenn.github.io/log/20240707-00.html</link>
      <description>&lt;h2&gt;개발자 베타 릴리즈 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS 14.6 beta 2&lt;/li&gt;
&lt;li&gt;iOS 17.6 beta 2&lt;/li&gt;
&lt;li&gt;iPadOS 17.6 beta 2&lt;/li&gt;
&lt;li&gt;visionOS 1.3 beta 2&lt;/li&gt;
&lt;li&gt;watchOS 10.6 beta 2&lt;/li&gt;
&lt;li&gt;tvOS 17.6 beta 2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;모두 개발자 베타 형식으로 공개되어 수일 후 공공 베타로 전환되었다. 이전 베타와의 차이점은 버그 수정 외에 알려진 내역이 없다. 애초에 이 버전대는 마이너 업데이트 버전 형식을 띠고 있지만 사실상 버그 픽스 업데이트로 평가되고 있다.&lt;/p&gt;
&lt;h2&gt;일반적인 소식들&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AI 관련 소식들&lt;/strong&gt;&lt;br/&gt;
애플지능이 비전프로에도 언젠가 지원될 것 같다. 하지만 의외로 가장 유용할 것으로 보이는 홈팟에는 지원 가능성이 보이지 않는다. 사유로는 너무 적은 RAM이 꼽히는 듯하다. 그보다 더 성능 좋은 아이폰 14 이하 제품도 지원 안 되니 당연할 지도 모르겠다. 한편 물 건너 간 것으로 평가되던 구글과의 협업설이 다시 나오기 시작했다. 그리고 애플은 OpenAI 이사회 참관인(Observer) 자격을 얻었다고 한다. 애플지능 일부 기능의 유료화 가능성도 제기되고 있다. &lt;a href="../log/20240611-00.html"&gt;WWDC24&lt;/a&gt;를 통해 소개된 애플지능 기능은 일제히 가을에 보기는 힘들 것 같고 일부는 내년에야 볼 수 있을 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;구형이 된 제품들&lt;/strong&gt;&lt;br/&gt;
애플은 아이폰 X, 1세대 홈팟, 1세대 에어팟을 소위 '빈티지'로 분류했다. 빈티지의 경우 수리나 소프트웨어 지원이 끊기는 것은 아니지만 보통 2년 후에는 '구식' 제품으로 분류되어 공식 지원이 끝나게 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFC 확장 가능?&lt;/strong&gt;&lt;br/&gt;
애플도 회원으로 있는 NFC 포럼에서는 여러 기능의 확장에 대해 의견이 오가고 있는 모양이다. 아직 애플은 아이폰이나 애플워치의 NFC를 개방하지도 않고 그래서 굉장히 제한적인 기능만 사용할 수 있는데, 유럽에서의 NFC 개방 움직임과 함께 이런 기능의 확장이 도입된다면 당연히 좋을 것이다. 애플도 회원사인 만큼 표준화가 된다면 애플도 이에 동의했다는 의미일 테고 말이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EU 파편화?&lt;/strong&gt;&lt;br/&gt;
EU 내에서 visionOS 1.2부터 대체 결제 옵션을 사용할 수 있다고 한다. 다른 OS들은 이미 지원하고 있었고 visionOS가 좀 늦었을 뿐이었다. 외부 결제를 쓸 수 있다 하더라도 애플 측에 수수료를 내야 하는 것은 여전히 특이하긴 하다. 하여간 유럽은 뭔가가 많이 다르다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;macOS 15 Sequoia, iOS 18, iPadOS 18&lt;/strong&gt;&lt;br/&gt;
macOS 15에 HDMI Passthrough가 지원되는데 주로 Dolby Atmos 오디오 재생을 위한 용도 같다. iOS 18의 날씨 앱도 조금씩 개선되는 듯하다. iPadOS 18에서는 이모티콘 입력이 개선된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;수리용이성&lt;/strong&gt;&lt;br/&gt;
뉴욕에서 수리권 준수 점검으로 애플의 제품 3개가 검사되었는데, 의외로 수리용이성에서 아이폰 15는 A 등급을 받았다. M3 맥북프로는 C 등급, 비전프로는 최악의 F 등급을 받았다. 다만 비전프로의 경우는 아직 수리 매뉴얼이나 부품 등을 구할 수 없다는 점이 최하 등급 받게 만든 이유인 듯하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;뒤끝이 긴 애플?&lt;/strong&gt;&lt;br/&gt;
에픽이 유럽 지역에서 자체 앱스토어를 통해 게임 업데이트를 제출했다는 소식이 얼마 전 전해졌었는데, 이제는 애플이 이를 고의로 지연시켰다고 에픽이 애플을 비난하는 소식이 알려졌다. 다만 현재 애플은 에픽의 대체 앱스토어 및 앱을 승인했다.&lt;/p&gt;
&lt;h2&gt;각종 루머 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;비전프로의 염가판에는 당연하겠지만 크기가 크고 (즉 집적도가 낮고) 낮은 해상도의 디스플레이가 지원될 것 같다.&lt;/li&gt;
&lt;li&gt;아이폰 16 프로의 디스플레이는 밝기와 수명 개선을 위해 삼성의 M14 OLED 패널을 채택할 것으로 보인다. 카메라에는 5배 광학 줌이 지원될 것으로 보인다.&lt;/li&gt;
&lt;li&gt;아이폰 16 시리즈의 카메라 센서 공급망 개편에 관한 루머가 나왔다. 소문으론 삼성전자의 부품이 추가되지 않을까 예상되는 듯하다.&lt;/li&gt;
&lt;li&gt;일부에서 M4를 탑재한 일명 애플 TV 프로 제품을 출시해야 한다고 주장하는 듯하다. 일종의 게임 콘솔을 겸해서다.&lt;/li&gt;
&lt;li&gt;M5는 칩을 3차원으로 쌓는 TSMC의 SoIC 기술을 사용할 것으로 보인다.&lt;/li&gt;
&lt;li&gt;신형 아이패드로 유추되는 기기 식별자 4종이 발견되었다고 한다.&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;h2&gt;개발자 베타 릴리즈 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS 14.6 beta 2&lt;/li&gt;
&lt;li&gt;iOS 17.6 beta 2&lt;/li&gt;
&lt;li&gt;iPadOS 17.6 beta 2&lt;/li&gt;
&lt;li&gt;visionOS 1.3 beta 2&lt;/li&gt;
&lt;li&gt;watchOS 10.6 beta 2&lt;/li&gt;
&lt;li&gt;tvOS 17.6 beta 2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;모두 개발자 베타 형식으로 공개되어 수일 후 공공 베타로 전환되었다. 이전 베타와의 차이점은 버그 수정 외에 알려진 내역이 없다. 애초에 이 버전대는 마이너 업데이트 버전 형식을 띠고 있지만 사실상 버그 픽스 업데이트로 평가되고 있다.&lt;/p&gt;
&lt;h2&gt;일반적인 소식들&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AI 관련 소식들&lt;/strong&gt;&lt;br/&gt;
애플지능이 비전프로에도 언젠가 지원될 것 같다. 하지만 의외로 가장 유용할 것으로 보이는 홈팟에는 지원 가능성이 보이지 않는다. 사유로는 너무 적은 RAM이 꼽히는 듯하다. 그보다 더 성능 좋은 아이폰 14 이하 제품도 지원 안 되니 당연할 지도 모르겠다. 한편 물 건너 간 것으로 평가되던 구글과의 협업설이 다시 나오기 시작했다. 그리고 애플은 OpenAI 이사회 참관인(Observer) 자격을 얻었다고 한다. 애플지능 일부 기능의 유료화 가능성도 제기되고 있다. &lt;a href="../log/20240611-00.html"&gt;WWDC24&lt;/a&gt;를 통해 소개된 애플지능 기능은 일제히 가을에 보기는 힘들 것 같고 일부는 내년에야 볼 수 있을 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;구형이 된 제품들&lt;/strong&gt;&lt;br/&gt;
애플은 아이폰 X, 1세대 홈팟, 1세대 에어팟을 소위 '빈티지'로 분류했다. 빈티지의 경우 수리나 소프트웨어 지원이 끊기는 것은 아니지만 보통 2년 후에는 '구식' 제품으로 분류되어 공식 지원이 끝나게 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFC 확장 가능?&lt;/strong&gt;&lt;br/&gt;
애플도 회원으로 있는 NFC 포럼에서는 여러 기능의 확장에 대해 의견이 오가고 있는 모양이다. 아직 애플은 아이폰이나 애플워치의 NFC를 개방하지도 않고 그래서 굉장히 제한적인 기능만 사용할 수 있는데, 유럽에서의 NFC 개방 움직임과 함께 이런 기능의 확장이 도입된다면 당연히 좋을 것이다. 애플도 회원사인 만큼 표준화가 된다면 애플도 이에 동의했다는 의미일 테고 말이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EU 파편화?&lt;/strong&gt;&lt;br/&gt;
EU 내에서 visionOS 1.2부터 대체 결제 옵션을 사용할 수 있다고 한다. 다른 OS들은 이미 지원하고 있었고 visionOS가 좀 늦었을 뿐이었다. 외부 결제를 쓸 수 있다 하더라도 애플 측에 수수료를 내야 하는 것은 여전히 특이하긴 하다. 하여간 유럽은 뭔가가 많이 다르다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;macOS 15 Sequoia, iOS 18, iPadOS 18&lt;/strong&gt;&lt;br/&gt;
macOS 15에 HDMI Passthrough가 지원되는데 주로 Dolby Atmos 오디오 재생을 위한 용도 같다. iOS 18의 날씨 앱도 조금씩 개선되는 듯하다. iPadOS 18에서는 이모티콘 입력이 개선된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;수리용이성&lt;/strong&gt;&lt;br/&gt;
뉴욕에서 수리권 준수 점검으로 애플의 제품 3개가 검사되었는데, 의외로 수리용이성에서 아이폰 15는 A 등급을 받았다. M3 맥북프로는 C 등급, 비전프로는 최악의 F 등급을 받았다. 다만 비전프로의 경우는 아직 수리 매뉴얼이나 부품 등을 구할 수 없다는 점이 최하 등급 받게 만든 이유인 듯하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;뒤끝이 긴 애플?&lt;/strong&gt;&lt;br/&gt;
에픽이 유럽 지역에서 자체 앱스토어를 통해 게임 업데이트를 제출했다는 소식이 얼마 전 전해졌었는데, 이제는 애플이 이를 고의로 지연시켰다고 에픽이 애플을 비난하는 소식이 알려졌다. 다만 현재 애플은 에픽의 대체 앱스토어 및 앱을 승인했다.&lt;/p&gt;
&lt;h2&gt;각종 루머 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;비전프로의 염가판에는 당연하겠지만 크기가 크고 (즉 집적도가 낮고) 낮은 해상도의 디스플레이가 지원될 것 같다.&lt;/li&gt;
&lt;li&gt;아이폰 16 프로의 디스플레이는 밝기와 수명 개선을 위해 삼성의 M14 OLED 패널을 채택할 것으로 보인다. 카메라에는 5배 광학 줌이 지원될 것으로 보인다.&lt;/li&gt;
&lt;li&gt;아이폰 16 시리즈의 카메라 센서 공급망 개편에 관한 루머가 나왔다. 소문으론 삼성전자의 부품이 추가되지 않을까 예상되는 듯하다.&lt;/li&gt;
&lt;li&gt;일부에서 M4를 탑재한 일명 애플 TV 프로 제품을 출시해야 한다고 주장하는 듯하다. 일종의 게임 콘솔을 겸해서다.&lt;/li&gt;
&lt;li&gt;M5는 칩을 3차원으로 쌓는 TSMC의 SoIC 기술을 사용할 것으로 보인다.&lt;/li&gt;
&lt;li&gt;신형 아이패드로 유추되는 기기 식별자 4종이 발견되었다고 한다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240707-00.html</guid>
      <pubDate>Sun, 07 Jul 2024 21:10:00 +0900</pubDate>
    </item>
    <item>
      <title>Git에서 페이저 비활성화 하기</title>
      <link>https://seorenn.github.io/article/git-disable-pager.html</link>
      <description>&lt;p&gt;Git에서 페이저를 임시로 혹은 설정으로 비활성화 하는 방법을 간단히 알아보자.&lt;/p&gt;
&lt;h2&gt;페이저(Pager)&lt;/h2&gt;
&lt;p&gt;페이저(pager)란 less나 more 같은 CLI 도구로 터미널에서 로그나 변경사항을 볼 때 내용을 끊어서 볼 수 있게 해주거나 스크롤을 할 수 있게 해주는 등 긴 내용의 텍스트를 터미널에서 편하게 볼 수 있게 해주는 도구다.&lt;/p&gt;
&lt;p&gt;Git에서는 브랜치 목록이나 변경사항(diff) 등 여러 부분에서 기본적으로 페이저를 사용하도록 동작한다.&lt;/p&gt;
&lt;h2&gt;페이저 임시로 비활성화 하기&lt;/h2&gt;
&lt;p&gt;페이저는 편한 도구이지만 특정 상황, 예를 들어 다른 UNIX 유틸리티로 파이프를 통해 내용을 넘기려 할 때는 오히려 방해가 되는 요소다. 이런 경우는 페이저를 비활성화 하면 오히려 도움이 된다.&lt;/p&gt;
&lt;p&gt;페이저 비활성화는 &lt;code&gt;--no-pager&lt;/code&gt;라는 옵션으로 간단히 할 수 있다. 예를 들어 코드 변경 사항을 페이저 없이 보는 커맨드는 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git --no-pager diff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 &lt;code&gt;--no-pager&lt;/code&gt; 옵션은 위치에 따라 동작하지 않거나 없는 옵션이라고 하기도 하니 순서에 주의하자. 어쨌거나 필요한 커맨드 마다 매번 이 옵션을 입력하는 것은 번거롭기는 하다.&lt;/p&gt;
&lt;h2&gt;페이저 비활성화 설정하기&lt;/h2&gt;
&lt;p&gt;아예 페이저를 안 쓰겠다면 설정에서 비활성화 하는 방법이 있다.&lt;/p&gt;
&lt;p&gt;예를 들어 변경사항(diff) 커맨드에서 페이저를 비활성화 하고 싶다면 아래와 같이 설정할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git config --global pager.diff false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 외에도 다양한 설정이 있으므로 필요한 부분은 찾아보자.&lt;/p&gt;
&lt;p&gt;다만 Git을 터미널에서 쓰는 경우가 잦다면 추천하기는 좀 힘든 설정 같다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;Git에서 페이저를 임시로 혹은 설정으로 비활성화 하는 방법을 간단히 알아보자.&lt;/p&gt;
&lt;h2&gt;페이저(Pager)&lt;/h2&gt;
&lt;p&gt;페이저(pager)란 less나 more 같은 CLI 도구로 터미널에서 로그나 변경사항을 볼 때 내용을 끊어서 볼 수 있게 해주거나 스크롤을 할 수 있게 해주는 등 긴 내용의 텍스트를 터미널에서 편하게 볼 수 있게 해주는 도구다.&lt;/p&gt;
&lt;p&gt;Git에서는 브랜치 목록이나 변경사항(diff) 등 여러 부분에서 기본적으로 페이저를 사용하도록 동작한다.&lt;/p&gt;
&lt;h2&gt;페이저 임시로 비활성화 하기&lt;/h2&gt;
&lt;p&gt;페이저는 편한 도구이지만 특정 상황, 예를 들어 다른 UNIX 유틸리티로 파이프를 통해 내용을 넘기려 할 때는 오히려 방해가 되는 요소다. 이런 경우는 페이저를 비활성화 하면 오히려 도움이 된다.&lt;/p&gt;
&lt;p&gt;페이저 비활성화는 &lt;code&gt;--no-pager&lt;/code&gt;라는 옵션으로 간단히 할 수 있다. 예를 들어 코드 변경 사항을 페이저 없이 보는 커맨드는 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git --no-pager diff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 &lt;code&gt;--no-pager&lt;/code&gt; 옵션은 위치에 따라 동작하지 않거나 없는 옵션이라고 하기도 하니 순서에 주의하자. 어쨌거나 필요한 커맨드 마다 매번 이 옵션을 입력하는 것은 번거롭기는 하다.&lt;/p&gt;
&lt;h2&gt;페이저 비활성화 설정하기&lt;/h2&gt;
&lt;p&gt;아예 페이저를 안 쓰겠다면 설정에서 비활성화 하는 방법이 있다.&lt;/p&gt;
&lt;p&gt;예를 들어 변경사항(diff) 커맨드에서 페이저를 비활성화 하고 싶다면 아래와 같이 설정할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git config --global pager.diff false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 외에도 다양한 설정이 있으므로 필요한 부분은 찾아보자.&lt;/p&gt;
&lt;p&gt;다만 Git을 터미널에서 쓰는 경우가 잦다면 추천하기는 좀 힘든 설정 같다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/git-disable-pager.html</guid>
      <pubDate>Sat, 06 Jul 2024 23:04:00 +0900</pubDate>
    </item>
    <item>
      <title>미국 임금 및 고용 지표는 정말 뭔가를 가리키는 듯</title>
      <link>https://seorenn.github.io/log/20240705-00.html</link>
      <description>&lt;p&gt;어제에 이어 오늘도 고용과 관련해 상당히 중요한 지표들이 발표되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 6월 평균 시간당 임금 MoM 0.3% (-0.1%), YoY 3.9% (-0.2%)&lt;/li&gt;
&lt;li&gt;미국 6월 비농업고용지수 206K (-12K) 예상치 상회&lt;/li&gt;
&lt;li&gt;미국 6월 실업률 4.1% (+0.1%) 예상치 상회&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;전반적으로 고용시장의 둔화가 어제에 이어 또 나타났다. 비농업고용지수가 예상치를 상회하긴 했지만 그래도 이전에 비해 악화된 것은 사실이다.&lt;/p&gt;
&lt;p&gt;특히 실업률이 튀는 것은 가볍게 볼 일은 아닐 것 같다. 왠지 오르는 속도가 빨라졌다는 느낌도 든다.&lt;/p&gt;
&lt;p&gt;연준의 책무가 물가와 고용이기 때문에 점점 금리 인하의 명분이 쌓여가고 있다. 채권 금리들도 일제히 떨어지며 입을 맞추는 것 같다. 그 덕분인지 오늘 ATH를 찍는 빅테크 종목들이 제법 보인다. 물론 정확한 방향은 아직은 모르는 일이고 유독 빅테크 위주로만 오르고 있다는 점에서도 그렇게 긍정적인 것은 또 아닌 것 같기도 하다.&lt;/p&gt;
&lt;p&gt;국장에는 좋은 분위기만 전달 되었으면 좋겠는데 많이 불안해 보인다. 러셀2000도 하락하고 있고 AI 관련주들도 하락하는 모양이다. 미리 마음의 준비(?)를 하고 있자. &lt;em&gt;내가 왜 오늘 삼성전자에 들어갔을까...&lt;/em&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;어제에 이어 오늘도 고용과 관련해 상당히 중요한 지표들이 발표되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 6월 평균 시간당 임금 MoM 0.3% (-0.1%), YoY 3.9% (-0.2%)&lt;/li&gt;
&lt;li&gt;미국 6월 비농업고용지수 206K (-12K) 예상치 상회&lt;/li&gt;
&lt;li&gt;미국 6월 실업률 4.1% (+0.1%) 예상치 상회&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;전반적으로 고용시장의 둔화가 어제에 이어 또 나타났다. 비농업고용지수가 예상치를 상회하긴 했지만 그래도 이전에 비해 악화된 것은 사실이다.&lt;/p&gt;
&lt;p&gt;특히 실업률이 튀는 것은 가볍게 볼 일은 아닐 것 같다. 왠지 오르는 속도가 빨라졌다는 느낌도 든다.&lt;/p&gt;
&lt;p&gt;연준의 책무가 물가와 고용이기 때문에 점점 금리 인하의 명분이 쌓여가고 있다. 채권 금리들도 일제히 떨어지며 입을 맞추는 것 같다. 그 덕분인지 오늘 ATH를 찍는 빅테크 종목들이 제법 보인다. 물론 정확한 방향은 아직은 모르는 일이고 유독 빅테크 위주로만 오르고 있다는 점에서도 그렇게 긍정적인 것은 또 아닌 것 같기도 하다.&lt;/p&gt;
&lt;p&gt;국장에는 좋은 분위기만 전달 되었으면 좋겠는데 많이 불안해 보인다. 러셀2000도 하락하고 있고 AI 관련주들도 하락하는 모양이다. 미리 마음의 준비(?)를 하고 있자. &lt;em&gt;내가 왜 오늘 삼성전자에 들어갔을까...&lt;/em&gt;&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240705-00.html</guid>
      <pubDate>Fri, 05 Jul 2024 23:35:00 +0900</pubDate>
    </item>
    <item>
      <title>Git에서 작업 내역을 임시로 저장하고 복원하기</title>
      <link>https://seorenn.github.io/article/git-stash.html</link>
      <description>&lt;p&gt;Git 저장소로 관리하는 프로젝트 작업 중 원래 소스를 참조해야 해서 현재의 작업 내용을 잠깐 어딘가 보관해 두고 수정된 내역을 다시 원래대로 돌리고 싶을 때가 있다. 이럴 때는 stash 커맨드를 사용할 수 있는데 어떻게 사용하는지 대충 정리해 보자.&lt;/p&gt;
&lt;h2&gt;Git Stash&lt;/h2&gt;
&lt;p&gt;Git의 Stash 기능은 이름처럼 임시 영역에 무언가를 넣어두는(stash) 명령이다. 넣는 것은 '변경 사항' 뿐이기 때문에 이 명령을 실행하면 현재 저장소의 브랜치는 수정하기 전 상태로 돌아간다는 것이 특징이다. 그 외에 임시 영역은 브랜치와 무관하게 보관된다는 특징 또한 가지고 있다. &lt;/p&gt;
&lt;p&gt;당연하겠지만 Stash는 작업 중(dirty)인 내역만 임시 영역으로 옮기고, 커밋된 부분이나 저장소에 포함되지 않은(untracked) 파일은 옮기지 않는다. 따라서 커밋하기 전에 수정 전의 코드를 사용해야 할 일이 있을 때 유용하게 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;그 외에 여러 기능이 제공되지만 이 글에서는 기본적인 사용법과 개인적으로 종종 사용하는 방법에 대해서만 정리한다.&lt;/p&gt;
&lt;h2&gt;작업 내역을 임시 영역으로 옮기기&lt;/h2&gt;
&lt;p&gt;현재 작업 내역 중 커밋되지 않은 변경점들은 &lt;code&gt;stash&lt;/code&gt; 명령을 이용해 임시 영역으로 옮길 수 있다. 이러면 마치 농땡이(?)를 피운 양 현재 브랜치의 작업 내역이 싹 초기화된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-m&lt;/code&gt;으로 옵션으로 커밋과 비슷하게 메시지를 남길 수도 있으니 참고하자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash -m &amp;quot;is this correct way?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;특정 파일만 임시 영역에 옮기고 싶은 경우&lt;/h2&gt;
&lt;p&gt;Git 2.13 부터 &lt;code&gt;stash push&lt;/code&gt; 명령이 새롭게 생겼다. 이 명령을 이용하면 파일 단위로 임시 영역으로 변경점들을 옮길 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash push foo/bar/file
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;임시 영역 목록 보기&lt;/h2&gt;
&lt;p&gt;임시 영역에 보관된 내역들은 &lt;code&gt;stash list&lt;/code&gt; 커맨드로 대충 확인할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash list
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;임시 영역의 내용물 보기&lt;/h2&gt;
&lt;p&gt;임시 영역에 보관된 변경 사항이 어떤지 대충 확인할 때는 &lt;code&gt;show&lt;/code&gt; 커맨드를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash show [stash_name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;당연하겠지만 stash_nam을 생략하면 모든 사항이 표시된다.&lt;/p&gt;
&lt;h2&gt;임시 영역과 현재 브랜치와 비교하기&lt;/h2&gt;
&lt;p&gt;임시 영역의 들어간 내용들과 현재 브랜치와의 차이점(diff)을 보려면 &lt;code&gt;show&lt;/code&gt; 커맨드에 &lt;code&gt;-p&lt;/code&gt; 옵션을 붙여보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash show -p [stash_name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;역시 stash_name 부분은 생략할 수 있다.&lt;/p&gt;
&lt;h2&gt;임시 영역의 변경사항을 현재 브랜치에 적용하기&lt;/h2&gt;
&lt;p&gt;볼 일(?)이 다 끝나고 임시 영역의 내용을 현재 브랜치로 다시 가져오려면 &lt;code&gt;pop&lt;/code&gt; 명령을 활용해보자. 이 경우 임시 영역의 내용은 사라진다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git pop [stash_name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stash_name을 생략하면 모든 임시 영역의 변경 사항들이 그대로 적용된다. 당연하겠지만 커밋 되기 전의 상태를 의미한다.&lt;/p&gt;
&lt;h2&gt;임시 영역을 초기화하지 않고 적용하기&lt;/h2&gt;
&lt;p&gt;만약 임시 영역의 내용을 현재 브랜치에 적용할 때 임시 영역에서 지우지 않길 원한다면 &lt;code&gt;apply&lt;/code&gt; 커맨드를 활용해 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash apply [stash_name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;자주 쓸 일은 없겠지만 여러 브랜치에 비슷한 변경 사항을 적용해서 커밋하기 전에 시험해 볼 때는 유용할 수도 있다.&lt;/p&gt;
&lt;h2&gt;임시 영역의 변경사항 버리기&lt;/h2&gt;
&lt;p&gt;임시로 보관된 변경사항들을 지워버릴 때는 &lt;code&gt;drop&lt;/code&gt; 명령을 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash drop [stash_name]
&lt;/code&gt;&lt;/pre&gt;</description>
      <content:encoded>&lt;p&gt;Git 저장소로 관리하는 프로젝트 작업 중 원래 소스를 참조해야 해서 현재의 작업 내용을 잠깐 어딘가 보관해 두고 수정된 내역을 다시 원래대로 돌리고 싶을 때가 있다. 이럴 때는 stash 커맨드를 사용할 수 있는데 어떻게 사용하는지 대충 정리해 보자.&lt;/p&gt;
&lt;h2&gt;Git Stash&lt;/h2&gt;
&lt;p&gt;Git의 Stash 기능은 이름처럼 임시 영역에 무언가를 넣어두는(stash) 명령이다. 넣는 것은 '변경 사항' 뿐이기 때문에 이 명령을 실행하면 현재 저장소의 브랜치는 수정하기 전 상태로 돌아간다는 것이 특징이다. 그 외에 임시 영역은 브랜치와 무관하게 보관된다는 특징 또한 가지고 있다. &lt;/p&gt;
&lt;p&gt;당연하겠지만 Stash는 작업 중(dirty)인 내역만 임시 영역으로 옮기고, 커밋된 부분이나 저장소에 포함되지 않은(untracked) 파일은 옮기지 않는다. 따라서 커밋하기 전에 수정 전의 코드를 사용해야 할 일이 있을 때 유용하게 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;그 외에 여러 기능이 제공되지만 이 글에서는 기본적인 사용법과 개인적으로 종종 사용하는 방법에 대해서만 정리한다.&lt;/p&gt;
&lt;h2&gt;작업 내역을 임시 영역으로 옮기기&lt;/h2&gt;
&lt;p&gt;현재 작업 내역 중 커밋되지 않은 변경점들은 &lt;code&gt;stash&lt;/code&gt; 명령을 이용해 임시 영역으로 옮길 수 있다. 이러면 마치 농땡이(?)를 피운 양 현재 브랜치의 작업 내역이 싹 초기화된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-m&lt;/code&gt;으로 옵션으로 커밋과 비슷하게 메시지를 남길 수도 있으니 참고하자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash -m &amp;quot;is this correct way?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;특정 파일만 임시 영역에 옮기고 싶은 경우&lt;/h2&gt;
&lt;p&gt;Git 2.13 부터 &lt;code&gt;stash push&lt;/code&gt; 명령이 새롭게 생겼다. 이 명령을 이용하면 파일 단위로 임시 영역으로 변경점들을 옮길 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash push foo/bar/file
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;임시 영역 목록 보기&lt;/h2&gt;
&lt;p&gt;임시 영역에 보관된 내역들은 &lt;code&gt;stash list&lt;/code&gt; 커맨드로 대충 확인할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash list
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;임시 영역의 내용물 보기&lt;/h2&gt;
&lt;p&gt;임시 영역에 보관된 변경 사항이 어떤지 대충 확인할 때는 &lt;code&gt;show&lt;/code&gt; 커맨드를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash show [stash_name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;당연하겠지만 stash_nam을 생략하면 모든 사항이 표시된다.&lt;/p&gt;
&lt;h2&gt;임시 영역과 현재 브랜치와 비교하기&lt;/h2&gt;
&lt;p&gt;임시 영역의 들어간 내용들과 현재 브랜치와의 차이점(diff)을 보려면 &lt;code&gt;show&lt;/code&gt; 커맨드에 &lt;code&gt;-p&lt;/code&gt; 옵션을 붙여보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash show -p [stash_name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;역시 stash_name 부분은 생략할 수 있다.&lt;/p&gt;
&lt;h2&gt;임시 영역의 변경사항을 현재 브랜치에 적용하기&lt;/h2&gt;
&lt;p&gt;볼 일(?)이 다 끝나고 임시 영역의 내용을 현재 브랜치로 다시 가져오려면 &lt;code&gt;pop&lt;/code&gt; 명령을 활용해보자. 이 경우 임시 영역의 내용은 사라진다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git pop [stash_name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stash_name을 생략하면 모든 임시 영역의 변경 사항들이 그대로 적용된다. 당연하겠지만 커밋 되기 전의 상태를 의미한다.&lt;/p&gt;
&lt;h2&gt;임시 영역을 초기화하지 않고 적용하기&lt;/h2&gt;
&lt;p&gt;만약 임시 영역의 내용을 현재 브랜치에 적용할 때 임시 영역에서 지우지 않길 원한다면 &lt;code&gt;apply&lt;/code&gt; 커맨드를 활용해 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash apply [stash_name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;자주 쓸 일은 없겠지만 여러 브랜치에 비슷한 변경 사항을 적용해서 커밋하기 전에 시험해 볼 때는 유용할 수도 있다.&lt;/p&gt;
&lt;h2&gt;임시 영역의 변경사항 버리기&lt;/h2&gt;
&lt;p&gt;임시로 보관된 변경사항들을 지워버릴 때는 &lt;code&gt;drop&lt;/code&gt; 명령을 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;git stash drop [stash_name]
&lt;/code&gt;&lt;/pre&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/git-stash.html</guid>
      <pubDate>Fri, 05 Jul 2024 16:18:00 +0900</pubDate>
    </item>
    <item>
      <title>이제 미국도 정말 경기 침체를 걱정하는 단계인가?</title>
      <link>https://seorenn.github.io/log/20240704-00.html</link>
      <description>&lt;p&gt;육아에 지쳐 쓰러져 있는 동안 미국 노동시장과 관련된 정말 중요한 지표들이 나왔었나 보다. 적당히 정리해 보자.&lt;/p&gt;
&lt;p&gt;가장 먼저 전전일 발표된 JOLTs다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 5월 노동부 JOLTs: 8140M (+221M) 예상치 상회&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 보면 노동시장이 다시 회복하기 시작한 것처럼 보이지만 추세를 보면 하락세가 꺾인 것은 아니라서 반전이라고 보기엔 힘든 지표 같다. 이를 증명이나 하듯 전일 발표된 지표가 뭔가를 보여준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 6월 ADP 비농업부문 고용 변화: 150K (-7K) 예상치 하회&lt;/li&gt;
&lt;li&gt;미국 연속 실업수당청구건수: 1858K (+26K) 예상치 상회&lt;/li&gt;
&lt;li&gt;미국 신규 실업수당청구건수: 238K (+4K) 예상치 상회&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ADP 지표나 실업수당으로 간접 유추해보면 노동시장이 둔화되고 있는 것처럼 보인다. JOLTs 지표를 하락 추세로 보는 게 합당하다고 뒷받침 하고 있다.&lt;/p&gt;
&lt;p&gt;그리고 또 충격의 지표가 하나 더 있다. 바로 그동안 강력하던 서비스 물가를 간접적으로 알려주던 서비스업 PMI다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 6월 서비스 PMI: 55.3 (+0.5) 예상치 상회&lt;/li&gt;
&lt;li&gt;미국 6월 ISM 비제조업 PMI: 48.8 (-5) 예상치 하회&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;서비스업 PMI의 두 지표는 좀 상반되게 나왔지만, 영향력이 큰 ISM쪽 지표는 아예 위축세로 크게 하락한 모습을 보이며 좀 충격을 주는 듯하다. 물론 설문 조사로 만들어지는 지표기 때문에 객관성은 좀 떨어지겠지만 적어도 시장 분위기를 느끼기엔 더없이 좋은 지표기도 하다.&lt;/p&gt;
&lt;p&gt;안 그래도 여기에 GDP 예측치도 떨어지고 있고 뭔가가 느껴진다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;많은 화살표가 일제히 미국의 경기 침체 쪽을 가리키는 느낌이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러면 적어도 주식시장에선 안 좋은 분위기가 느껴...져야 정상이겠지만 금리 인하 기대를 키우는 쪽으로 건드리며 오히려 좋은 분위기가 느껴지는 것 같기도 하다. 뭐... 침체는 그렇게 좋은 건 아니니 무작정 좋다고 보긴 무리겠지만 말이다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;육아에 지쳐 쓰러져 있는 동안 미국 노동시장과 관련된 정말 중요한 지표들이 나왔었나 보다. 적당히 정리해 보자.&lt;/p&gt;
&lt;p&gt;가장 먼저 전전일 발표된 JOLTs다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 5월 노동부 JOLTs: 8140M (+221M) 예상치 상회&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 보면 노동시장이 다시 회복하기 시작한 것처럼 보이지만 추세를 보면 하락세가 꺾인 것은 아니라서 반전이라고 보기엔 힘든 지표 같다. 이를 증명이나 하듯 전일 발표된 지표가 뭔가를 보여준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 6월 ADP 비농업부문 고용 변화: 150K (-7K) 예상치 하회&lt;/li&gt;
&lt;li&gt;미국 연속 실업수당청구건수: 1858K (+26K) 예상치 상회&lt;/li&gt;
&lt;li&gt;미국 신규 실업수당청구건수: 238K (+4K) 예상치 상회&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ADP 지표나 실업수당으로 간접 유추해보면 노동시장이 둔화되고 있는 것처럼 보인다. JOLTs 지표를 하락 추세로 보는 게 합당하다고 뒷받침 하고 있다.&lt;/p&gt;
&lt;p&gt;그리고 또 충격의 지표가 하나 더 있다. 바로 그동안 강력하던 서비스 물가를 간접적으로 알려주던 서비스업 PMI다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 6월 서비스 PMI: 55.3 (+0.5) 예상치 상회&lt;/li&gt;
&lt;li&gt;미국 6월 ISM 비제조업 PMI: 48.8 (-5) 예상치 하회&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;서비스업 PMI의 두 지표는 좀 상반되게 나왔지만, 영향력이 큰 ISM쪽 지표는 아예 위축세로 크게 하락한 모습을 보이며 좀 충격을 주는 듯하다. 물론 설문 조사로 만들어지는 지표기 때문에 객관성은 좀 떨어지겠지만 적어도 시장 분위기를 느끼기엔 더없이 좋은 지표기도 하다.&lt;/p&gt;
&lt;p&gt;안 그래도 여기에 GDP 예측치도 떨어지고 있고 뭔가가 느껴진다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;많은 화살표가 일제히 미국의 경기 침체 쪽을 가리키는 느낌이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러면 적어도 주식시장에선 안 좋은 분위기가 느껴...져야 정상이겠지만 금리 인하 기대를 키우는 쪽으로 건드리며 오히려 좋은 분위기가 느껴지는 것 같기도 하다. 뭐... 침체는 그렇게 좋은 건 아니니 무작정 좋다고 보긴 무리겠지만 말이다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240704-00.html</guid>
      <pubDate>Thu, 04 Jul 2024 11:54:00 +0900</pubDate>
    </item>
    <item>
      <title>Cargo로 빌드 시 no external crate 오류 해결하기</title>
      <link>https://seorenn.github.io/article/rust-no-external-crate.html</link>
      <description>&lt;p&gt;Cargo로 Rust 프로젝트를 빌드할 때 특정 패키지를 사용하려는 코드에서 'unresolved import' 혹은 'no external crate' 오류가 발생했을 때의 원인과 해결 방법을 알아보자.&lt;/p&gt;
&lt;h2&gt;문제&lt;/h2&gt;
&lt;p&gt;특수한 상황 때문에 빌드 스크립트를 써야 할 때가 있었다. 이럴 때는 &lt;code&gt;build.rs&lt;/code&gt;라는 파일을 만들어 여기에 몇 가지 추가 빌드 스크립트를 작성할 수 있다. 그리고 이런 빌드 스크립트 작성에도 도움을 주는 여러 외부 패키지가 있다.&lt;/p&gt;
&lt;p&gt;어쨌든 다시 특수한 상황으로 빌드 스크립트를 작성해야 해서 빌드용으로 사용할 어떤 패키지 - 여기서는 임의로 somemod라고 이름 지은 패키지 - 를 의존성으로 추가했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ cargo add somemod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 실제로 존재하지는 않는 패키지다. 어쨌든 이를 &lt;code&gt;build.rs&lt;/code&gt;에서 쓰겠다고 명시해 줬다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rust"&gt;// build.rs
use somemod;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 빌드를 시도해 보니 오류가 떴다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ cargo build
   Compiling myproject v0.1.0 (/foo/bar/project/myproject)
error[E0432]: unresolved import `somemod`
 --&amp;gt; build.rs:1:5
  |
1 | use somemod;
  |     ^^^^^ no external crate `somemod`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;대략 두 가지 메시지가 뜬다. 하나는 'unresolved import'이고 다른 하나는 'no external crate' 오류다. 의미상으로 보면 어차피 같은 오류라고 봐도 될 것 같다.&lt;/p&gt;
&lt;h2&gt;해결하기&lt;/h2&gt;
&lt;p&gt;이 오류 때문에 좀 삽질을 했었는데 '빌드 의존성은 런타임 의존성과는 별도'라는 점을 모르고 있었다는 점이었다. 위의 경우 별도의 명시 없이 somemod라는 모듈을 add 명령으로 의존성으로 추가했더니 해당 패키지는 아래와 같이 &lt;code&gt;Cargo.toml&lt;/code&gt;에 일반 의존성으로 기입되어 있었다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[dependencies]
somemod = &amp;quot;1.0.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 예시로 든 somemod 패키지는 빌드할 때 필요한 의존성이다. 따라서 오류를 해결하려면 이 패키지를 다음과 같이 빌드 의존성(Build Dependencies) 쪽으로 옮겨서 확실하게 명시해 주면 될 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[build-dependencies]
somemod = &amp;quot;1.0.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;build-dependencies&lt;/code&gt; 섹션은 없으면 그냥 만들면 된다.&lt;/p&gt;
&lt;p&gt;이후 &lt;code&gt;cargo build&lt;/code&gt;를 실행시키니 별 문제 없이 잘 실행되었다.&lt;/p&gt;
&lt;p&gt;오늘도 이렇게 삽질을 하며 한 가지 사실을 배워간다. 빌드 의존성 문제는 어떤 언어든 어떤 프레임워크든 늘 겪는 문제인데 왜 이렇게 익숙해지지 않는지 모르겠다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;Cargo로 Rust 프로젝트를 빌드할 때 특정 패키지를 사용하려는 코드에서 'unresolved import' 혹은 'no external crate' 오류가 발생했을 때의 원인과 해결 방법을 알아보자.&lt;/p&gt;
&lt;h2&gt;문제&lt;/h2&gt;
&lt;p&gt;특수한 상황 때문에 빌드 스크립트를 써야 할 때가 있었다. 이럴 때는 &lt;code&gt;build.rs&lt;/code&gt;라는 파일을 만들어 여기에 몇 가지 추가 빌드 스크립트를 작성할 수 있다. 그리고 이런 빌드 스크립트 작성에도 도움을 주는 여러 외부 패키지가 있다.&lt;/p&gt;
&lt;p&gt;어쨌든 다시 특수한 상황으로 빌드 스크립트를 작성해야 해서 빌드용으로 사용할 어떤 패키지 - 여기서는 임의로 somemod라고 이름 지은 패키지 - 를 의존성으로 추가했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ cargo add somemod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 실제로 존재하지는 않는 패키지다. 어쨌든 이를 &lt;code&gt;build.rs&lt;/code&gt;에서 쓰겠다고 명시해 줬다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rust"&gt;// build.rs
use somemod;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 빌드를 시도해 보니 오류가 떴다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ cargo build
   Compiling myproject v0.1.0 (/foo/bar/project/myproject)
error[E0432]: unresolved import `somemod`
 --&amp;gt; build.rs:1:5
  |
1 | use somemod;
  |     ^^^^^ no external crate `somemod`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;대략 두 가지 메시지가 뜬다. 하나는 'unresolved import'이고 다른 하나는 'no external crate' 오류다. 의미상으로 보면 어차피 같은 오류라고 봐도 될 것 같다.&lt;/p&gt;
&lt;h2&gt;해결하기&lt;/h2&gt;
&lt;p&gt;이 오류 때문에 좀 삽질을 했었는데 '빌드 의존성은 런타임 의존성과는 별도'라는 점을 모르고 있었다는 점이었다. 위의 경우 별도의 명시 없이 somemod라는 모듈을 add 명령으로 의존성으로 추가했더니 해당 패키지는 아래와 같이 &lt;code&gt;Cargo.toml&lt;/code&gt;에 일반 의존성으로 기입되어 있었다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[dependencies]
somemod = &amp;quot;1.0.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 예시로 든 somemod 패키지는 빌드할 때 필요한 의존성이다. 따라서 오류를 해결하려면 이 패키지를 다음과 같이 빌드 의존성(Build Dependencies) 쪽으로 옮겨서 확실하게 명시해 주면 될 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[build-dependencies]
somemod = &amp;quot;1.0.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;build-dependencies&lt;/code&gt; 섹션은 없으면 그냥 만들면 된다.&lt;/p&gt;
&lt;p&gt;이후 &lt;code&gt;cargo build&lt;/code&gt;를 실행시키니 별 문제 없이 잘 실행되었다.&lt;/p&gt;
&lt;p&gt;오늘도 이렇게 삽질을 하며 한 가지 사실을 배워간다. 빌드 의존성 문제는 어떤 언어든 어떤 프레임워크든 늘 겪는 문제인데 왜 이렇게 익숙해지지 않는지 모르겠다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/rust-no-external-crate.html</guid>
      <pubDate>Tue, 02 Jul 2024 23:41:00 +0900</pubDate>
    </item>
    <item>
      <title>macOS에서 한영전환키를 Emacs에서도 사용하기 (Hammerspoon)</title>
      <link>https://seorenn.github.io/article/macos-emacs-korean-inputmethod-hotkey-hammerspoon.html</link>
      <description>&lt;blockquote&gt;
&lt;p&gt;이 글의 해법은 어느 정도 시간이 지나면 먹통이 되는 문제가 있어 다른 방법을 연구 중입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;과거에는 좀 달랐지만 언제부턴가 macOS에서 한영전환키를 누르며 이 키 입력이 Emacs에 닿지 않게 되었다. 그래서 Emacs 내장 한글 입력기로 전환하기 위해서는 &lt;code&gt;C-\&lt;/code&gt; 등 다른 단축키를 이용해야 했다. 하지만 헷갈려서 내장 입력기 전환은 거의 사용하지 않았고 macOS 자체 입력기를 쓰는 것도 그다지 무리는 없어서 쓰고는 있었다.&lt;/p&gt;
&lt;p&gt;그런데 최근 macOS의 한글입력기 문제인지 아니면 Emacs 29 최신 버전의 문제인지 아니면 Evil과의 환상 조합 오작동인지 하여간 한글 입력이 조합 도중 씹히거나 사라졌다가 나중에 다시 나타나는 등 요상한 문제를 겪기 시작했다.&lt;/p&gt;
&lt;p&gt;결국 근본적인 해결이 필요할 것 같아 방법을 찾아보다 기존에 종종 사용하던 Hammerspoon을 통해 해결할 수 있을 것 같아 약간의 삽질을 하다 겨우 성공하였다.&lt;/p&gt;
&lt;h2&gt;문제 해결하기&lt;/h2&gt;
&lt;p&gt;이 방법은 'Emacs를 쓸 때는 시스템의 한영전환키를 씹어버리고 Emacs 내장입력기 전환 키로 바꿔서 던지는 식'으로 동작하는 Hammerspoon용 LUA 코드로 구현했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lua"&gt;local englishIMID = &amp;quot;com.apple.keylayout.ABC&amp;quot;

function setEnglishInputMethod()
    local source = hs.keycodes.currentSourceID()
    if not (source == englishIMID) then
        hs.keycodes.currentSourceID(englishIMID)
    end
end

hs.eventtap.new({hs.eventtap.event.types.keyDown, hs.eventtap.event.types.systemDefined}, function(event)
    local type = event:getType()
    local flags = event:getFlags()
    local keycode = event:getKeyCode()
    local app = hs.application.frontmostApplication()
    if type == hs.eventtap.event.types.keyDown and app:bundleID() == &amp;quot;org.gnu.Emacs&amp;quot; then
        if flags.shift and keycode == hs.keycodes.map.space then
            setEnglishInputMethod()
            -- remap to C-\
            hs.eventtap.event.newKeyEvent(hs.keycodes.map.ctrl, true):post()
            hs.eventtap.event.newKeyEvent(&amp;quot;\\&amp;quot;, true):post()
            hs.eventtap.event.newKeyEvent(&amp;quot;\\&amp;quot;, false):post()
            hs.eventtap.event.newKeyEvent(hs.keycodes.map.ctrl, false):post()
            return true
        else
            return false
        end
    else
        return false
    end
end):start()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bundle ID나 단축키 이름만 잘 바꾸면 어떤 앱이든 원하는 대로 단축키를 바꿀 수 있다. 그저 키 바꿔치기를 하는 경우에는 &lt;code&gt;return&lt;/code&gt; 값에 주의하면 된다. &lt;code&gt;true&lt;/code&gt;를 반환하면 기존에 입력된 키 스트로크를 무시시켜 버리기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setEnglishInputMethod()&lt;/code&gt; 함수는 주제에는 조금 벗어나 보이겠지만 중요한 문제를 예방하기 위해 사용한다. 예를 들어 macOS의 입력기가 한국어인 상태로 Emacs에 진입했다간 영문모드로 전환할 수 없는 불상사가 생기기 때문이 이를 막기 위해 시스템 입력기를 영어로 바꾸는 코드다. 만약 영문 입력기를 별도로 설치한 다른 것을 쓴다면 해당 입력기 ID로 고쳐주자.&lt;/p&gt;</description>
      <content:encoded>&lt;blockquote&gt;
&lt;p&gt;이 글의 해법은 어느 정도 시간이 지나면 먹통이 되는 문제가 있어 다른 방법을 연구 중입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;과거에는 좀 달랐지만 언제부턴가 macOS에서 한영전환키를 누르며 이 키 입력이 Emacs에 닿지 않게 되었다. 그래서 Emacs 내장 한글 입력기로 전환하기 위해서는 &lt;code&gt;C-\&lt;/code&gt; 등 다른 단축키를 이용해야 했다. 하지만 헷갈려서 내장 입력기 전환은 거의 사용하지 않았고 macOS 자체 입력기를 쓰는 것도 그다지 무리는 없어서 쓰고는 있었다.&lt;/p&gt;
&lt;p&gt;그런데 최근 macOS의 한글입력기 문제인지 아니면 Emacs 29 최신 버전의 문제인지 아니면 Evil과의 환상 조합 오작동인지 하여간 한글 입력이 조합 도중 씹히거나 사라졌다가 나중에 다시 나타나는 등 요상한 문제를 겪기 시작했다.&lt;/p&gt;
&lt;p&gt;결국 근본적인 해결이 필요할 것 같아 방법을 찾아보다 기존에 종종 사용하던 Hammerspoon을 통해 해결할 수 있을 것 같아 약간의 삽질을 하다 겨우 성공하였다.&lt;/p&gt;
&lt;h2&gt;문제 해결하기&lt;/h2&gt;
&lt;p&gt;이 방법은 'Emacs를 쓸 때는 시스템의 한영전환키를 씹어버리고 Emacs 내장입력기 전환 키로 바꿔서 던지는 식'으로 동작하는 Hammerspoon용 LUA 코드로 구현했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lua"&gt;local englishIMID = &amp;quot;com.apple.keylayout.ABC&amp;quot;

function setEnglishInputMethod()
    local source = hs.keycodes.currentSourceID()
    if not (source == englishIMID) then
        hs.keycodes.currentSourceID(englishIMID)
    end
end

hs.eventtap.new({hs.eventtap.event.types.keyDown, hs.eventtap.event.types.systemDefined}, function(event)
    local type = event:getType()
    local flags = event:getFlags()
    local keycode = event:getKeyCode()
    local app = hs.application.frontmostApplication()
    if type == hs.eventtap.event.types.keyDown and app:bundleID() == &amp;quot;org.gnu.Emacs&amp;quot; then
        if flags.shift and keycode == hs.keycodes.map.space then
            setEnglishInputMethod()
            -- remap to C-\
            hs.eventtap.event.newKeyEvent(hs.keycodes.map.ctrl, true):post()
            hs.eventtap.event.newKeyEvent(&amp;quot;\\&amp;quot;, true):post()
            hs.eventtap.event.newKeyEvent(&amp;quot;\\&amp;quot;, false):post()
            hs.eventtap.event.newKeyEvent(hs.keycodes.map.ctrl, false):post()
            return true
        else
            return false
        end
    else
        return false
    end
end):start()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bundle ID나 단축키 이름만 잘 바꾸면 어떤 앱이든 원하는 대로 단축키를 바꿀 수 있다. 그저 키 바꿔치기를 하는 경우에는 &lt;code&gt;return&lt;/code&gt; 값에 주의하면 된다. &lt;code&gt;true&lt;/code&gt;를 반환하면 기존에 입력된 키 스트로크를 무시시켜 버리기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setEnglishInputMethod()&lt;/code&gt; 함수는 주제에는 조금 벗어나 보이겠지만 중요한 문제를 예방하기 위해 사용한다. 예를 들어 macOS의 입력기가 한국어인 상태로 Emacs에 진입했다간 영문모드로 전환할 수 없는 불상사가 생기기 때문이 이를 막기 위해 시스템 입력기를 영어로 바꾸는 코드다. 만약 영문 입력기를 별도로 설치한 다른 것을 쓴다면 해당 입력기 ID로 고쳐주자.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/macos-emacs-korean-inputmethod-hotkey-hammerspoon.html</guid>
      <pubDate>Mon, 01 Jul 2024 23:32:00 +0900</pubDate>
    </item>
    <item>
      <title>AI 산업의 미래</title>
      <link>https://seorenn.github.io/article/future-of-ai-industry.html</link>
      <description>&lt;p&gt;AI에 대한 관심과 투자가 한참인 지금, 과연 AI 산업의 미래는 밝기만 할까? 투자자 입장에서 그리고 엔지니어 입장에서 규제와 산업에 가해질 압력과 그 미래에 대해 상상해보자. 일부 근거는 사설 등을 기반으로 하지만 일부는 뇌피셜 이라는 점을 참고하자.&lt;/p&gt;
&lt;h2&gt;부작용이 생길 수 있는 이슈들&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;제대로 지켜지지 않는 저작권&lt;/strong&gt;&lt;br/&gt;
지금도 크게 이슈가 되고 있는 부분으로 무단 학습 및 그 자료를 바탕으로 한 추론에서 저작권이 무시되고 있다는 점이다. 대기업이면 모르겠지만 중소기업으로까지 대상을 확대하면 규제가 아니고서는 제대로 지켜지긴 힘든 것이 현실이다. 개인적으로 가장 규제가 강하게 걸리리라 생각되는 부분이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI 하드웨어 독점&lt;/strong&gt;&lt;br/&gt;
현재는 Nvidia 독점인 상태인데, 이 점도 추후 반독점법의 영향을 받을 수 있을까? 물론 후발주자들의 페이스에 따라 영향은 달라질 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI 플랫폼 독점&lt;/strong&gt;&lt;br/&gt;
Nvidia가 하드웨어와 동시에 Nvidia는 CUDA 같은 플랫폼 역시도 독점 중인 상황인라 역시 반독점법의 영향에 관해 생각해야 할 것 같다. 이런 개발용 플랫폼은 후발 주자가 잘 따라와도 쉽게 교체하기 힘든 부분이기도 하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전성비&lt;/strong&gt;&lt;br/&gt;
AI 서비스 운영을 위한 서버 인프라의 전기 소모량은 천문학적인 수준인데 이를 해결할 좋은 방법이 있을까? 전기 소모를 줄이거나 혹은 친환경발전의 비중을 크게 높여야 할 것이다. 물론 대규모 투자가 필요한 분야지만 제대로 극복을 못하면 규제의 대상이 될 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;개인정보 유출 및 프라이버시 침해&lt;/strong&gt;&lt;br/&gt;
민감한 개인정보가 사생활 정보를 어떻게 걸러낼 것인가 혹은 이에 관한 규제가 도입될 것인가? 지금도 벌어지고 있는 프라이버시 침해는 결국 규제가 아니면 후순위로 밀릴 주제일 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;비리의 도구&lt;/strong&gt;&lt;br/&gt;
편향된 학습 자료 혹은 추론 유도 등 AI를 이용한 비리나 범죄 가능성도 생각해 보자. 특히 AI의 신뢰도가 높아진다면 더더욱 AI로 만들어진 자료를 맹신하게 될 터라 범죄의 표적이 될 가능성도 높다고 보인다.&lt;/p&gt;
&lt;h2&gt;현실은 어떨까?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://n.news.naver.com/article/025/0003287118" target="_blank"&gt;"수십억 달러 벌금 낼 수도"…세계 첫 AI 규제법, 유럽 초안 통과📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.etnews.com/20230623000193" target="_blank"&gt;AI규율 국제적 논의 본격화…개인정보위, 주요 정책방향 제시📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/297787" target="_blank"&gt;‘AI’와 관련된 잘못된 생각📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/297781" target="_blank"&gt;윈도우 코파일럿··· 아직은 혼란한 AI 비서📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/297991" target="_blank"&gt;AI 규제에 동조하는 마이크로소프트의 속내📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/298669" target="_blank"&gt;미 코미디언 사라 실버맨, 오픈AI와 메타에 저작권 침해 소송 제기📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://news.einfomax.co.kr/news/articleView.html?idxno=4274101" target="_blank"&gt;바 연준 금융당국 부의장 "AI, 불법 대출 관행 부추길 위험"📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/301939" target="_blank"&gt;높아지는 AI 규제 요청의 목소리··· “규제 없으면 솔루션 업체 아닌 기업이 책임질지도”📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/302215" target="_blank"&gt;영국, AI를 장기적 보안 위협으로 공식화📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/302239" target="_blank"&gt;허용과 권장? 금지와 모니터링?··· 4인의 CIO가 말하는 '셰도우 AI와 씨름하기'📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.khan.co.kr/national/national-general/article/202308311635001" target="_blank"&gt;온신협, “AI의 뉴스 무단 사용은 저작권 침해”📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.axios.com/2023/09/21/chatgpt-lawsuit-openai-writers" target="_blank"&gt;George R.R. Martin, John Grisham and other writers sue over ChatGPT📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/308569" target="_blank"&gt;어설픈 기사로 조롱거리 된 AI 기자 外··· 'AI 재난' 9선📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://seorenn.tistory.com/536" target="_blank"&gt;생성형 AI로 매출 증대?📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/311551" target="_blank"&gt;내 저작물을 지켜라··· 생성형 AI에 '독 푸는' 도구의 등장📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/312226" target="_blank"&gt;EU 이어 미국도 AI 규제 본격화··· 바이든 ‘AI 행정 명령’에 대한 업계 평가는?📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.infostockdaily.co.kr/news/articleView.html?idxno=196623" target="_blank"&gt;오픈AI(OpenAI)와 마이크로소프트(MSFT) 상대로 저작권 침해 집단 소송📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/323224" target="_blank"&gt;오픈AI의 논리는 결국 ‘복사, 절도, 붙여넣기’📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://v.daum.net/v/20240307134553826" target="_blank"&gt;주요 4개 AI 모델 중 GPT-4, 저작권 침해 최악📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.etnews.com/20240311000237" target="_blank"&gt;엔비디아도 저작권 소송… 작가들 “AI 모델 학습에 무단 이용”📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/329335" target="_blank"&gt;유럽의회, 세계 첫 AI 규제법 승인··· 기업에 미치는 영향은?📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://news.einfomax.co.kr/news/articleView.html?idxno=4315303" target="_blank"&gt;"데이터 무단 사용"…오픈AI, 저작권 소송 잇따라📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/344152" target="_blank"&gt;“AI 답변에 광고 붙이고 수수료 지급할 것” 퍼플렉시티, 콘텐츠 제작자 위한 수익 공유 프로그램 공개📎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;AI에 대한 관심과 투자가 한참인 지금, 과연 AI 산업의 미래는 밝기만 할까? 투자자 입장에서 그리고 엔지니어 입장에서 규제와 산업에 가해질 압력과 그 미래에 대해 상상해보자. 일부 근거는 사설 등을 기반으로 하지만 일부는 뇌피셜 이라는 점을 참고하자.&lt;/p&gt;
&lt;h2&gt;부작용이 생길 수 있는 이슈들&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;제대로 지켜지지 않는 저작권&lt;/strong&gt;&lt;br/&gt;
지금도 크게 이슈가 되고 있는 부분으로 무단 학습 및 그 자료를 바탕으로 한 추론에서 저작권이 무시되고 있다는 점이다. 대기업이면 모르겠지만 중소기업으로까지 대상을 확대하면 규제가 아니고서는 제대로 지켜지긴 힘든 것이 현실이다. 개인적으로 가장 규제가 강하게 걸리리라 생각되는 부분이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI 하드웨어 독점&lt;/strong&gt;&lt;br/&gt;
현재는 Nvidia 독점인 상태인데, 이 점도 추후 반독점법의 영향을 받을 수 있을까? 물론 후발주자들의 페이스에 따라 영향은 달라질 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI 플랫폼 독점&lt;/strong&gt;&lt;br/&gt;
Nvidia가 하드웨어와 동시에 Nvidia는 CUDA 같은 플랫폼 역시도 독점 중인 상황인라 역시 반독점법의 영향에 관해 생각해야 할 것 같다. 이런 개발용 플랫폼은 후발 주자가 잘 따라와도 쉽게 교체하기 힘든 부분이기도 하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전성비&lt;/strong&gt;&lt;br/&gt;
AI 서비스 운영을 위한 서버 인프라의 전기 소모량은 천문학적인 수준인데 이를 해결할 좋은 방법이 있을까? 전기 소모를 줄이거나 혹은 친환경발전의 비중을 크게 높여야 할 것이다. 물론 대규모 투자가 필요한 분야지만 제대로 극복을 못하면 규제의 대상이 될 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;개인정보 유출 및 프라이버시 침해&lt;/strong&gt;&lt;br/&gt;
민감한 개인정보가 사생활 정보를 어떻게 걸러낼 것인가 혹은 이에 관한 규제가 도입될 것인가? 지금도 벌어지고 있는 프라이버시 침해는 결국 규제가 아니면 후순위로 밀릴 주제일 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;비리의 도구&lt;/strong&gt;&lt;br/&gt;
편향된 학습 자료 혹은 추론 유도 등 AI를 이용한 비리나 범죄 가능성도 생각해 보자. 특히 AI의 신뢰도가 높아진다면 더더욱 AI로 만들어진 자료를 맹신하게 될 터라 범죄의 표적이 될 가능성도 높다고 보인다.&lt;/p&gt;
&lt;h2&gt;현실은 어떨까?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://n.news.naver.com/article/025/0003287118" target="_blank"&gt;"수십억 달러 벌금 낼 수도"…세계 첫 AI 규제법, 유럽 초안 통과📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.etnews.com/20230623000193" target="_blank"&gt;AI규율 국제적 논의 본격화…개인정보위, 주요 정책방향 제시📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/297787" target="_blank"&gt;‘AI’와 관련된 잘못된 생각📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/297781" target="_blank"&gt;윈도우 코파일럿··· 아직은 혼란한 AI 비서📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/297991" target="_blank"&gt;AI 규제에 동조하는 마이크로소프트의 속내📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/298669" target="_blank"&gt;미 코미디언 사라 실버맨, 오픈AI와 메타에 저작권 침해 소송 제기📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://news.einfomax.co.kr/news/articleView.html?idxno=4274101" target="_blank"&gt;바 연준 금융당국 부의장 "AI, 불법 대출 관행 부추길 위험"📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/301939" target="_blank"&gt;높아지는 AI 규제 요청의 목소리··· “규제 없으면 솔루션 업체 아닌 기업이 책임질지도”📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/302215" target="_blank"&gt;영국, AI를 장기적 보안 위협으로 공식화📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/302239" target="_blank"&gt;허용과 권장? 금지와 모니터링?··· 4인의 CIO가 말하는 '셰도우 AI와 씨름하기'📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.khan.co.kr/national/national-general/article/202308311635001" target="_blank"&gt;온신협, “AI의 뉴스 무단 사용은 저작권 침해”📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.axios.com/2023/09/21/chatgpt-lawsuit-openai-writers" target="_blank"&gt;George R.R. Martin, John Grisham and other writers sue over ChatGPT📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/308569" target="_blank"&gt;어설픈 기사로 조롱거리 된 AI 기자 外··· 'AI 재난' 9선📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://seorenn.tistory.com/536" target="_blank"&gt;생성형 AI로 매출 증대?📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/311551" target="_blank"&gt;내 저작물을 지켜라··· 생성형 AI에 '독 푸는' 도구의 등장📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/312226" target="_blank"&gt;EU 이어 미국도 AI 규제 본격화··· 바이든 ‘AI 행정 명령’에 대한 업계 평가는?📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.infostockdaily.co.kr/news/articleView.html?idxno=196623" target="_blank"&gt;오픈AI(OpenAI)와 마이크로소프트(MSFT) 상대로 저작권 침해 집단 소송📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/323224" target="_blank"&gt;오픈AI의 논리는 결국 ‘복사, 절도, 붙여넣기’📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://v.daum.net/v/20240307134553826" target="_blank"&gt;주요 4개 AI 모델 중 GPT-4, 저작권 침해 최악📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.etnews.com/20240311000237" target="_blank"&gt;엔비디아도 저작권 소송… 작가들 “AI 모델 학습에 무단 이용”📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/329335" target="_blank"&gt;유럽의회, 세계 첫 AI 규제법 승인··· 기업에 미치는 영향은?📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://news.einfomax.co.kr/news/articleView.html?idxno=4315303" target="_blank"&gt;"데이터 무단 사용"…오픈AI, 저작권 소송 잇따라📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ciokorea.com/news/344152" target="_blank"&gt;“AI 답변에 광고 붙이고 수수료 지급할 것” 퍼플렉시티, 콘텐츠 제작자 위한 수익 공유 프로그램 공개📎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/future-of-ai-industry.html</guid>
      <pubDate>Mon, 01 Jul 2024 15:12:00 +0900</pubDate>
    </item>
    <item>
      <title>한 주간의 애플 소식 모음 24-06-30</title>
      <link>https://seorenn.github.io/log/20240630-00.html</link>
      <description>&lt;h2&gt;개발자 베타 릴리즈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15 (Sequoia) beta 2: 아이폰 미러링 지원 추가, 헤드폰 조정 기능 추가, 맥앱스토어 앱 설치 빈 공간 요구 개선 등&lt;/li&gt;
&lt;li&gt;iOS 18 beta 2: 아이폰 미러링 지원, SharePlay 지원 추가, 메시지 RCS 토글 추가, 비밀번호 앱 개선, 지도 검색 개선 등&lt;/li&gt;
&lt;li&gt;iPadOS 18 beta 2: EU DMA 지원 추가 등&lt;/li&gt;
&lt;li&gt;visionOS 2 beta 2: Bora Bora 환경 추가, 새로운 제스처 추가, 키보드 폐쇄 등&lt;/li&gt;
&lt;li&gt;watchOS 11 beta 2: Vitals 앱 추가, Fitness 앱 개선, Smart Stack 기능 개선 등&lt;/li&gt;
&lt;li&gt;tvOS 18 beta 2: 대화 및 자막 개선, InSight 기능 추가&lt;/li&gt;
&lt;li&gt;Safari Technology Preview 197&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;일반적인 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;애플의 AI 파트너십 대상 후보에 구글과 OpenAI에 이어 메타도 포함된 것으로 알려졌다. 하지만 곧 애플에 의해 거부되었다는 루머도 전해졌다.&lt;/li&gt;
&lt;li&gt;EU는 결국 애플이 DMA를 위반했다며 조사를 시작한 듯하다. 특히 사이드로딩이나 대체 앱스토어의 수수료 부과 문제를 크게 문제 삼는 듯하다.&lt;/li&gt;
&lt;li&gt;애플이 아이폰 생산 공정 자동화를 통해 인력을 절반으로 줄이는 방안을 추진 중이라 한다.&lt;/li&gt;
&lt;li&gt;애플의 비접촉 결제 서비스인 Tap to Pay가 독일에도 진출한다.&lt;/li&gt;
&lt;li&gt;애플이 대만에 데이터센터를 구축한다고 한다. 투자 금액은 4조 3천억 원 이상이 될 것으로 보인다. &lt;em&gt;지진과 중국은 괜찮을까?&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;애플은 이제 유럽에서도 자가 수리 진단 서비스를 시작했다.&lt;/li&gt;
&lt;li&gt;헝가리에서 이상한 요금이 청구되는 등 애플페이가 무작위로 오작동하는 사례가 보고되었다.&lt;/li&gt;
&lt;li&gt;비전프로가 중국, 홍콩, 일본, 싱가포르에 출시되었다. 호주, 캐나다, 프랑스, 독일, 영국 등에선 비전프로의 사전 주문이 개시되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;루머들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;애플이 아이폰 배터리 교체를 좀 더 쉽게 할 수 있는 방법을 개발 중이라는 보고서가 나왔다. 우선 대상 모델은 아이폰 16인 것 같다.&lt;/li&gt;
&lt;li&gt;iOS 19는 벌써 개발이 시작 되었는데 Luck이라는 코드네임을 가지는 것으로 보인다. 비슷하게 macOS 16은 Cheer, watchOS 12는 Nepali, visionOS 3는 Discovery라는 코드네임을 가지는 것으로 보인다. 물론 코드네임은 실 사용에는 별 의미가 없다.&lt;/li&gt;
&lt;li&gt;카메라가 탑재된 에어팟 발패 가능성에 대한 소문이 있다. 2026년을 목표로 한다는 듯하다. 카메라는 적외선 카메라로 에어팟 사용성이나 공간감 개선을 위한 센서 역할을 하게 될 것 같은 느낌이다.&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;h2&gt;개발자 베타 릴리즈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15 (Sequoia) beta 2: 아이폰 미러링 지원 추가, 헤드폰 조정 기능 추가, 맥앱스토어 앱 설치 빈 공간 요구 개선 등&lt;/li&gt;
&lt;li&gt;iOS 18 beta 2: 아이폰 미러링 지원, SharePlay 지원 추가, 메시지 RCS 토글 추가, 비밀번호 앱 개선, 지도 검색 개선 등&lt;/li&gt;
&lt;li&gt;iPadOS 18 beta 2: EU DMA 지원 추가 등&lt;/li&gt;
&lt;li&gt;visionOS 2 beta 2: Bora Bora 환경 추가, 새로운 제스처 추가, 키보드 폐쇄 등&lt;/li&gt;
&lt;li&gt;watchOS 11 beta 2: Vitals 앱 추가, Fitness 앱 개선, Smart Stack 기능 개선 등&lt;/li&gt;
&lt;li&gt;tvOS 18 beta 2: 대화 및 자막 개선, InSight 기능 추가&lt;/li&gt;
&lt;li&gt;Safari Technology Preview 197&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;일반적인 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;애플의 AI 파트너십 대상 후보에 구글과 OpenAI에 이어 메타도 포함된 것으로 알려졌다. 하지만 곧 애플에 의해 거부되었다는 루머도 전해졌다.&lt;/li&gt;
&lt;li&gt;EU는 결국 애플이 DMA를 위반했다며 조사를 시작한 듯하다. 특히 사이드로딩이나 대체 앱스토어의 수수료 부과 문제를 크게 문제 삼는 듯하다.&lt;/li&gt;
&lt;li&gt;애플이 아이폰 생산 공정 자동화를 통해 인력을 절반으로 줄이는 방안을 추진 중이라 한다.&lt;/li&gt;
&lt;li&gt;애플의 비접촉 결제 서비스인 Tap to Pay가 독일에도 진출한다.&lt;/li&gt;
&lt;li&gt;애플이 대만에 데이터센터를 구축한다고 한다. 투자 금액은 4조 3천억 원 이상이 될 것으로 보인다. &lt;em&gt;지진과 중국은 괜찮을까?&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;애플은 이제 유럽에서도 자가 수리 진단 서비스를 시작했다.&lt;/li&gt;
&lt;li&gt;헝가리에서 이상한 요금이 청구되는 등 애플페이가 무작위로 오작동하는 사례가 보고되었다.&lt;/li&gt;
&lt;li&gt;비전프로가 중국, 홍콩, 일본, 싱가포르에 출시되었다. 호주, 캐나다, 프랑스, 독일, 영국 등에선 비전프로의 사전 주문이 개시되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;루머들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;애플이 아이폰 배터리 교체를 좀 더 쉽게 할 수 있는 방법을 개발 중이라는 보고서가 나왔다. 우선 대상 모델은 아이폰 16인 것 같다.&lt;/li&gt;
&lt;li&gt;iOS 19는 벌써 개발이 시작 되었는데 Luck이라는 코드네임을 가지는 것으로 보인다. 비슷하게 macOS 16은 Cheer, watchOS 12는 Nepali, visionOS 3는 Discovery라는 코드네임을 가지는 것으로 보인다. 물론 코드네임은 실 사용에는 별 의미가 없다.&lt;/li&gt;
&lt;li&gt;카메라가 탑재된 에어팟 발패 가능성에 대한 소문이 있다. 2026년을 목표로 한다는 듯하다. 카메라는 적외선 카메라로 에어팟 사용성이나 공간감 개선을 위한 센서 역할을 하게 될 것 같은 느낌이다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240630-00.html</guid>
      <pubDate>Sun, 30 Jun 2024 21:58:00 +0900</pubDate>
    </item>
    <item>
      <title>Emacs Lisp에서 샤프 작은따옴표(#') 기호의 의미</title>
      <link>https://seorenn.github.io/article/emacs-lisp-sharp-quote-sign.md.html</link>
      <description>&lt;p&gt;Emacs Lisp 코드에서 샤프(&lt;code&gt;#&lt;/code&gt;, sharpsign)와 작은따옴표(&lt;code&gt;'&lt;/code&gt;, single-quote)를 붙인 기호가 종종 쓰이는데 무슨 의미인지 대충 알아보자.&lt;/p&gt;
&lt;h2&gt;많이 쓰이는 예&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#'&lt;/code&gt; 기호는 보통 함수 핸들러를 전달할 때 많이 보인다. 아래의 예는 개인적으로 사용하는 설정 코드에서의 예인데 Doom Emacs 전용 코드도 일부 포함되어 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(add-to-list 'treemacs-ignored-file-predicates #'treemacs-ignore-local-cache))
(add-hook 'kill-emacs-hook #'my-exit-function)

;; Doom Emacs config.el
(add-hook! 'markdown-mode-hook #'my-text-styles)
(map! &amp;quot;C-c a l&amp;quot; #'my-miracle-function)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 &lt;code&gt;#'&lt;/code&gt;가 붙어있는 심볼들이 모두 함수일 것 같은 기분이라면 바로 정답이다.&lt;/p&gt;
&lt;h2&gt;Function Abbreviation&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#'&lt;/code&gt;로 샤프와 작은따옴표를 붙여 쓰면 Function Quote 즉 함수 인용이라는 기능이 된다. 다른 말로 Function Abbreviation이라다 표현하기도 한다. 다른 언어에선 콜백 혹은 핸들러 정도의 의미와 비슷하다. 예를 들자면 이런 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(defun do-what (f)
  (funcall f &amp;quot;This is the what!&amp;quot;))

(do-what #'message)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 예에서 &lt;code&gt;do-what&lt;/code&gt;이라는 함수의 첫번째 인자로 함수를 전달하기 위해 &lt;code&gt;#'&lt;/code&gt;가 함수 이름 앞에 붙어있다. 이렇게 함수를 어딘가 전달해야 할 때 &lt;code&gt;#'&lt;/code&gt;가 종종 사용된다.&lt;/p&gt;
&lt;h2&gt;그래서 무슨 차이일까?&lt;/h2&gt;
&lt;p&gt;사실 위 모든 예제에서 &lt;code&gt;#'&lt;/code&gt;을 그냥 &lt;code&gt;'&lt;/code&gt;으로 바꿔도 아무 문제 없이 동작한다. 함수 인용이든 인용이든 둘 다 인용이니 말이다.&lt;/p&gt;
&lt;p&gt;그렇다면 &lt;code&gt;#'&lt;/code&gt;는 도대체 왜 쓰는 걸까?&lt;/p&gt;
&lt;p&gt;개인적인 추측이지만 &lt;strong&gt;명시적인 표현&lt;/strong&gt; 때문에 쓴다고 생각된다. 즉 여기에는 반드시 함수 인용이 들어와야 할 자리이고 그래서 함수를 인용해서 넘긴다는 의미로 &lt;code&gt;#'&lt;/code&gt;을 명확하게 표기한다고 생각한다. &lt;/p&gt;
&lt;p&gt;다르게 말해서 &lt;code&gt;#'&lt;/code&gt;를 표시한 자리에 함수가 아닌 다른 심볼이나 리스트 등을 넣으면 안 된다는 말이 된다. 실제로 여기에 함수가 아닌 것을 넣으면 호출 시점에서 에러가 발생한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(funcall #'(1 2 3) &amp;quot;parameter&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;함수가 와야 할 자리에 리스트가 들어가 있으니 "Invalid Function"이라는 오류가 발생한다.&lt;/p&gt;
&lt;p&gt;결국 &lt;code&gt;#'&lt;/code&gt;는 가독성을 좋게 만들기 위한 Lisp 만의 특수한 꾸밈 요소라고 생각된다. 물론 다른 언어에만 익숙한 사람이 보면 &lt;code&gt;'&lt;/code&gt;든 &lt;code&gt;#'&lt;/code&gt;든 암호 같은 건 마찬가지 겠지만 말이다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-funcall-and-apply.html"&gt;Emacs Lisp에서 funcall과 apply의 차이&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;Emacs Lisp 코드에서 샤프(&lt;code&gt;#&lt;/code&gt;, sharpsign)와 작은따옴표(&lt;code&gt;'&lt;/code&gt;, single-quote)를 붙인 기호가 종종 쓰이는데 무슨 의미인지 대충 알아보자.&lt;/p&gt;
&lt;h2&gt;많이 쓰이는 예&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#'&lt;/code&gt; 기호는 보통 함수 핸들러를 전달할 때 많이 보인다. 아래의 예는 개인적으로 사용하는 설정 코드에서의 예인데 Doom Emacs 전용 코드도 일부 포함되어 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(add-to-list 'treemacs-ignored-file-predicates #'treemacs-ignore-local-cache))
(add-hook 'kill-emacs-hook #'my-exit-function)

;; Doom Emacs config.el
(add-hook! 'markdown-mode-hook #'my-text-styles)
(map! &amp;quot;C-c a l&amp;quot; #'my-miracle-function)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 &lt;code&gt;#'&lt;/code&gt;가 붙어있는 심볼들이 모두 함수일 것 같은 기분이라면 바로 정답이다.&lt;/p&gt;
&lt;h2&gt;Function Abbreviation&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#'&lt;/code&gt;로 샤프와 작은따옴표를 붙여 쓰면 Function Quote 즉 함수 인용이라는 기능이 된다. 다른 말로 Function Abbreviation이라다 표현하기도 한다. 다른 언어에선 콜백 혹은 핸들러 정도의 의미와 비슷하다. 예를 들자면 이런 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(defun do-what (f)
  (funcall f &amp;quot;This is the what!&amp;quot;))

(do-what #'message)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 예에서 &lt;code&gt;do-what&lt;/code&gt;이라는 함수의 첫번째 인자로 함수를 전달하기 위해 &lt;code&gt;#'&lt;/code&gt;가 함수 이름 앞에 붙어있다. 이렇게 함수를 어딘가 전달해야 할 때 &lt;code&gt;#'&lt;/code&gt;가 종종 사용된다.&lt;/p&gt;
&lt;h2&gt;그래서 무슨 차이일까?&lt;/h2&gt;
&lt;p&gt;사실 위 모든 예제에서 &lt;code&gt;#'&lt;/code&gt;을 그냥 &lt;code&gt;'&lt;/code&gt;으로 바꿔도 아무 문제 없이 동작한다. 함수 인용이든 인용이든 둘 다 인용이니 말이다.&lt;/p&gt;
&lt;p&gt;그렇다면 &lt;code&gt;#'&lt;/code&gt;는 도대체 왜 쓰는 걸까?&lt;/p&gt;
&lt;p&gt;개인적인 추측이지만 &lt;strong&gt;명시적인 표현&lt;/strong&gt; 때문에 쓴다고 생각된다. 즉 여기에는 반드시 함수 인용이 들어와야 할 자리이고 그래서 함수를 인용해서 넘긴다는 의미로 &lt;code&gt;#'&lt;/code&gt;을 명확하게 표기한다고 생각한다. &lt;/p&gt;
&lt;p&gt;다르게 말해서 &lt;code&gt;#'&lt;/code&gt;를 표시한 자리에 함수가 아닌 다른 심볼이나 리스트 등을 넣으면 안 된다는 말이 된다. 실제로 여기에 함수가 아닌 것을 넣으면 호출 시점에서 에러가 발생한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(funcall #'(1 2 3) &amp;quot;parameter&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;함수가 와야 할 자리에 리스트가 들어가 있으니 "Invalid Function"이라는 오류가 발생한다.&lt;/p&gt;
&lt;p&gt;결국 &lt;code&gt;#'&lt;/code&gt;는 가독성을 좋게 만들기 위한 Lisp 만의 특수한 꾸밈 요소라고 생각된다. 물론 다른 언어에만 익숙한 사람이 보면 &lt;code&gt;'&lt;/code&gt;든 &lt;code&gt;#'&lt;/code&gt;든 암호 같은 건 마찬가지 겠지만 말이다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-funcall-and-apply.html"&gt;Emacs Lisp에서 funcall과 apply의 차이&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/emacs-lisp-sharp-quote-sign.md.html</guid>
      <pubDate>Sat, 29 Jun 2024 15:44:00 +0900</pubDate>
    </item>
    <item>
      <title>미국 5월 PCE도 잘 나온 듯</title>
      <link>https://seorenn.github.io/log/20240628-00.html</link>
      <description>&lt;p&gt;오늘은 대명절(?)인 PCE가 발표되는 날이다. 물론 미국이고 5월달 지표다. 대충 요렇게 나왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;헤드라인 PCE MoM 0% (-0.3%), YoY 2.6% (-0.1%)&lt;/li&gt;
&lt;li&gt;근원 PCE MoM 0.1% (-0.2%), YoY 2.6% (-0.2%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;전부 예상에 부합했다. 심지어 근원 PCE MoM의 전달 수치가 상향 조정되면서 더 극적인 연출이 이뤄진 느낌이다. 물론 완전히 0은 아니고 반올림이 이뤄지면서 0으로 표시된 것 뿐이겠지만 말이다.&lt;/p&gt;
&lt;p&gt;이와중에 개인지출이나 개인소득도 전달 대비 더 늘어나서 미묘하면서도 좋은 분위기를 만들어 줄 것 같은 느낌적인 느낌이다.&lt;/p&gt;
&lt;p&gt;현재로써는 주식시장 선물시장도 나쁘지 않은 반응이 나타나는 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FedWatch" src="../upload/202406282329-f3e07644.png" /&gt;
&lt;em&gt;FedWatch&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;일단 7월이나 9월 인하 확률이 살짝 높아진 것 같은 느낌이 드는데 이전 수치를 저장을 안 해놨더니 확실하진 않다. &lt;/p&gt;
&lt;p&gt;어쨌든 좋은 느낌이다. 연준에게도 딱히 나쁜 느낌은 아닐 것 같기도 하다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;오늘은 대명절(?)인 PCE가 발표되는 날이다. 물론 미국이고 5월달 지표다. 대충 요렇게 나왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;헤드라인 PCE MoM 0% (-0.3%), YoY 2.6% (-0.1%)&lt;/li&gt;
&lt;li&gt;근원 PCE MoM 0.1% (-0.2%), YoY 2.6% (-0.2%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;전부 예상에 부합했다. 심지어 근원 PCE MoM의 전달 수치가 상향 조정되면서 더 극적인 연출이 이뤄진 느낌이다. 물론 완전히 0은 아니고 반올림이 이뤄지면서 0으로 표시된 것 뿐이겠지만 말이다.&lt;/p&gt;
&lt;p&gt;이와중에 개인지출이나 개인소득도 전달 대비 더 늘어나서 미묘하면서도 좋은 분위기를 만들어 줄 것 같은 느낌적인 느낌이다.&lt;/p&gt;
&lt;p&gt;현재로써는 주식시장 선물시장도 나쁘지 않은 반응이 나타나는 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FedWatch" src="../upload/202406282329-f3e07644.png" /&gt;
&lt;em&gt;FedWatch&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;일단 7월이나 9월 인하 확률이 살짝 높아진 것 같은 느낌이 드는데 이전 수치를 저장을 안 해놨더니 확실하진 않다. &lt;/p&gt;
&lt;p&gt;어쨌든 좋은 느낌이다. 연준에게도 딱히 나쁜 느낌은 아닐 것 같기도 하다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240628-00.html</guid>
      <pubDate>Fri, 28 Jun 2024 23:32:00 +0900</pubDate>
    </item>
    <item>
      <title>Emacs Lisp에서 funcall과 apply의 차이</title>
      <link>https://seorenn.github.io/article/emacs-lisp-funcall-and-apply.html</link>
      <description>&lt;p&gt;Emacs Lisp에서 함수를 매개변수로 받아서 자유롭게 호출하기 위해 &lt;code&gt;funcall&lt;/code&gt;과 &lt;code&gt;apply&lt;/code&gt;가 쓰이는데 이 둘이 어떻게 다른지 간단히 정리해 보자. &lt;/p&gt;
&lt;p&gt;이 둘은 사실 용도는 동일하고 그저 사용법만 다르다고 봐도 될 것 같다.&lt;/p&gt;
&lt;h2&gt;funcall&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;funcall&lt;/code&gt;은 첫 매개변수로 입력된 함수를 나머지 매개변수를 이용해 호출시키고 결과를 반환하는 함수다. 예를 들자면 아래와 같이 호출할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(funcall #'+ 1 2 3)
;; =&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드는 &lt;code&gt;(+ 1 2 3)&lt;/code&gt;을 호출하는 것과 동일하다.&lt;/p&gt;
&lt;h2&gt;apply&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;도 첫 매개변수로 입력된 함수를 호출하는데 여기에 전달될 매개변수를 리스트로 전달 받는다는 차이가 있다. 예를 들자면 아래와 같이 호출할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(apply #'+ '(1 2 3))
;; =&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드도 &lt;code&gt;(+ 1 2 3)&lt;/code&gt;을 호출하는 것과 동일하다.&lt;/p&gt;
&lt;h2&gt;정리&lt;/h2&gt;
&lt;p&gt;즉 &lt;code&gt;funcall&lt;/code&gt;과 &lt;code&gt;apply&lt;/code&gt;의 결정적 차이는 매개변수(parameters)를 매개변수 리스트로 넘길 것이냐 아니면 별도의 순수 리스트 인스턴스로 넘길 것이냐 정도로 정리할 수 있을 것 같다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-sharp-quote-sign.md.html"&gt;Emacs Lisp에서 샤프 작은따옴표(#') 기호의 의미&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;Emacs Lisp에서 함수를 매개변수로 받아서 자유롭게 호출하기 위해 &lt;code&gt;funcall&lt;/code&gt;과 &lt;code&gt;apply&lt;/code&gt;가 쓰이는데 이 둘이 어떻게 다른지 간단히 정리해 보자. &lt;/p&gt;
&lt;p&gt;이 둘은 사실 용도는 동일하고 그저 사용법만 다르다고 봐도 될 것 같다.&lt;/p&gt;
&lt;h2&gt;funcall&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;funcall&lt;/code&gt;은 첫 매개변수로 입력된 함수를 나머지 매개변수를 이용해 호출시키고 결과를 반환하는 함수다. 예를 들자면 아래와 같이 호출할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(funcall #'+ 1 2 3)
;; =&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드는 &lt;code&gt;(+ 1 2 3)&lt;/code&gt;을 호출하는 것과 동일하다.&lt;/p&gt;
&lt;h2&gt;apply&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;도 첫 매개변수로 입력된 함수를 호출하는데 여기에 전달될 매개변수를 리스트로 전달 받는다는 차이가 있다. 예를 들자면 아래와 같이 호출할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(apply #'+ '(1 2 3))
;; =&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드도 &lt;code&gt;(+ 1 2 3)&lt;/code&gt;을 호출하는 것과 동일하다.&lt;/p&gt;
&lt;h2&gt;정리&lt;/h2&gt;
&lt;p&gt;즉 &lt;code&gt;funcall&lt;/code&gt;과 &lt;code&gt;apply&lt;/code&gt;의 결정적 차이는 매개변수(parameters)를 매개변수 리스트로 넘길 것이냐 아니면 별도의 순수 리스트 인스턴스로 넘길 것이냐 정도로 정리할 수 있을 것 같다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-sharp-quote-sign.md.html"&gt;Emacs Lisp에서 샤프 작은따옴표(#') 기호의 의미&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/emacs-lisp-funcall-and-apply.html</guid>
      <pubDate>Fri, 28 Jun 2024 15:44:00 +0900</pubDate>
    </item>
    <item>
      <title>의존성 실타래 풀다가 화병 나겠네</title>
      <link>https://seorenn.github.io/log/20240627-00.html</link>
      <description>&lt;p&gt;&lt;img alt="불어터진 자장면 코드" src="../upload/202406271528-56066a1e.jpg" /&gt;
&lt;em&gt;파스타 코드 보다는 불어터진 자장면 코드가 더 어울릴 듯 (태경 김/Pixabay)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;한 회사의 오래된 프로젝트가 너무 오래된 SDK를 참조하고 있는데 계속 놔두면 자른다(?)고 해서 이걸 업그레이드 하려고 여럿 건드려 보고 있는 중이다.&lt;/p&gt;
&lt;p&gt;그런데 이 과정에서 큰 지뢰를 밟아버렸다. 사용하던 의존성이 구버전 SDK와 엮여 있던 것이 많아서였다. 그래도 이왕 밟은 거 죽기는 싫으니 지뢰를 하나씩 해체해 나간다.&lt;/p&gt;
&lt;p&gt;우선은 SDK 버전을 올린 후 부족한 부분을 따라가 본다. 의존성들의 버전을 하나씩 올려보면서 문제가 해결되는지 확인해본다. 문제는 이 과정에서 연달아서 버전이 안 맞아서 꼬이는 현상들이 하나 둘 계속 얽혀져 뽑혀나온다.&lt;/p&gt;
&lt;p&gt;불행히도 지뢰를 해체해 나가던 도중 거기에 연결된 또다른 폭탄을 하나 발견한다. 겨우 의존성 문제를 풀어가나 싶더니 거기서 누군가 버전업이 안 되던 패키지를 직접 뜯어고친 비공식 저장소의 의존성이 튀어나왔다.&lt;/p&gt;
&lt;p&gt;여기에 얽힌 의존성의 버전 꼬임을 또 하나하나 해결해 간다. 의존성 버전 체크는 한 번에 하나씩 밖에 안 되기 때문에 지속적으로 체크하고 수정하고를 반복해 나가야 했다. 심각하게 스트레스를 받았다. 그래도 어떻게 해결을 하긴 했댜.&lt;/p&gt;
&lt;p&gt;이제 다 해결 되었을까 싶었지만 불행히도 지뢰에 또다른 폭탄이 연결된 것을 발견한다. 그런데 이번에 발견된 폭탄에는 워낙 옛날에 만들어서 어떻게 해체해야 할지 알 수 없는 부품이 하나 연결되어 있었다. 2년이나 넘게 방치된 패키지였다.&lt;/p&gt;
&lt;p&gt;어쩔 수 없이 그 부품을 복제해서 직접 뜯어고쳐야 되게 생겼다. 하지만 그 부품 안에는 또 오래되어서 관리가 안 되는 부품이 또 들어있었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아 모르겠다. 하기 싫다. 살려줘. 사람 살려.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;과거 어떤 회사 면접에서 '써드파티 의존성을 늘리는 것을 경계하는 편'이라고 이야기했다가 좀 둘러서 까인 적이 있었다. 그때 내가 잘못된 것일까 라고 생각하며 조금씩 써드파티 패키지에의 의존을 조금씩 늘려가보고 있기는 하다.&lt;/p&gt;
&lt;p&gt;하지만 이런 지뢰를 밟아 보면 '빨리 만들 수 있다고 써드파티 의존성을 늘려가는 게 과연 정답일까?'라고 좀 심각하게 고민해 봐야 할 것 같다. 특히 그 프로젝트가 내가 참여하지 않더라도 오히려 더 고민해 보라고 권하고 싶다. 유지보수라는 것도 상당히 중요한 일인데 의존성 옹호론자들은 너무 안일한 것이 아닐까.&lt;/p&gt;
&lt;p&gt;물론 지속적으로 관리되어온 프로젝트는 별 지장 없이 여전히 잘 관리될 수는 있다. 내가 처음부터 지금까지 계속 관리하는 코드들은 별 문제가 없다. 써드파티 패키지를 안 쓰는 것도 아님에도 말이다. SDK든 개발툴이든 뭐든 최신버전으로 바로 올려서 문제가 보이면 바로 수정하고 있으니 말이다.&lt;/p&gt;
&lt;p&gt;하지만 내가 처음부터 끝까지 지속적으로 꾸준히 관리되어 올 수 있는 일은 극수소일 뿐일 것이다.&lt;/p&gt;
&lt;p&gt;그러니까 하고 싶은 말은 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;불가피한 경우를 제외하곤 써드파티 의존성은 자제하는 편이 정신건강에 더 나을 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;정도일 것 같다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;img alt="불어터진 자장면 코드" src="../upload/202406271528-56066a1e.jpg" /&gt;
&lt;em&gt;파스타 코드 보다는 불어터진 자장면 코드가 더 어울릴 듯 (태경 김/Pixabay)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;한 회사의 오래된 프로젝트가 너무 오래된 SDK를 참조하고 있는데 계속 놔두면 자른다(?)고 해서 이걸 업그레이드 하려고 여럿 건드려 보고 있는 중이다.&lt;/p&gt;
&lt;p&gt;그런데 이 과정에서 큰 지뢰를 밟아버렸다. 사용하던 의존성이 구버전 SDK와 엮여 있던 것이 많아서였다. 그래도 이왕 밟은 거 죽기는 싫으니 지뢰를 하나씩 해체해 나간다.&lt;/p&gt;
&lt;p&gt;우선은 SDK 버전을 올린 후 부족한 부분을 따라가 본다. 의존성들의 버전을 하나씩 올려보면서 문제가 해결되는지 확인해본다. 문제는 이 과정에서 연달아서 버전이 안 맞아서 꼬이는 현상들이 하나 둘 계속 얽혀져 뽑혀나온다.&lt;/p&gt;
&lt;p&gt;불행히도 지뢰를 해체해 나가던 도중 거기에 연결된 또다른 폭탄을 하나 발견한다. 겨우 의존성 문제를 풀어가나 싶더니 거기서 누군가 버전업이 안 되던 패키지를 직접 뜯어고친 비공식 저장소의 의존성이 튀어나왔다.&lt;/p&gt;
&lt;p&gt;여기에 얽힌 의존성의 버전 꼬임을 또 하나하나 해결해 간다. 의존성 버전 체크는 한 번에 하나씩 밖에 안 되기 때문에 지속적으로 체크하고 수정하고를 반복해 나가야 했다. 심각하게 스트레스를 받았다. 그래도 어떻게 해결을 하긴 했댜.&lt;/p&gt;
&lt;p&gt;이제 다 해결 되었을까 싶었지만 불행히도 지뢰에 또다른 폭탄이 연결된 것을 발견한다. 그런데 이번에 발견된 폭탄에는 워낙 옛날에 만들어서 어떻게 해체해야 할지 알 수 없는 부품이 하나 연결되어 있었다. 2년이나 넘게 방치된 패키지였다.&lt;/p&gt;
&lt;p&gt;어쩔 수 없이 그 부품을 복제해서 직접 뜯어고쳐야 되게 생겼다. 하지만 그 부품 안에는 또 오래되어서 관리가 안 되는 부품이 또 들어있었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아 모르겠다. 하기 싫다. 살려줘. 사람 살려.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;과거 어떤 회사 면접에서 '써드파티 의존성을 늘리는 것을 경계하는 편'이라고 이야기했다가 좀 둘러서 까인 적이 있었다. 그때 내가 잘못된 것일까 라고 생각하며 조금씩 써드파티 패키지에의 의존을 조금씩 늘려가보고 있기는 하다.&lt;/p&gt;
&lt;p&gt;하지만 이런 지뢰를 밟아 보면 '빨리 만들 수 있다고 써드파티 의존성을 늘려가는 게 과연 정답일까?'라고 좀 심각하게 고민해 봐야 할 것 같다. 특히 그 프로젝트가 내가 참여하지 않더라도 오히려 더 고민해 보라고 권하고 싶다. 유지보수라는 것도 상당히 중요한 일인데 의존성 옹호론자들은 너무 안일한 것이 아닐까.&lt;/p&gt;
&lt;p&gt;물론 지속적으로 관리되어온 프로젝트는 별 지장 없이 여전히 잘 관리될 수는 있다. 내가 처음부터 지금까지 계속 관리하는 코드들은 별 문제가 없다. 써드파티 패키지를 안 쓰는 것도 아님에도 말이다. SDK든 개발툴이든 뭐든 최신버전으로 바로 올려서 문제가 보이면 바로 수정하고 있으니 말이다.&lt;/p&gt;
&lt;p&gt;하지만 내가 처음부터 끝까지 지속적으로 꾸준히 관리되어 올 수 있는 일은 극수소일 뿐일 것이다.&lt;/p&gt;
&lt;p&gt;그러니까 하고 싶은 말은 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;불가피한 경우를 제외하곤 써드파티 의존성은 자제하는 편이 정신건강에 더 나을 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;정도일 것 같다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240627-00.html</guid>
      <pubDate>Thu, 27 Jun 2024 15:29:00 +0900</pubDate>
    </item>
    <item>
      <title>Emacs Lisp의 alist 사용법 간단 정리</title>
      <link>https://seorenn.github.io/article/emacs-lisp-alist.html</link>
      <description>&lt;h2&gt;alist&lt;/h2&gt;
&lt;p&gt;Emacs Lisp에서 alist는 Association List의 축약어로, 한국어로 직역하면 '연관 목록' 정도로 표현할 수 있는 자료구조다. 다른 언어에서 자주 취급되는 가장 비슷한 자료구조를 들자면 사전형(dictionary)가 비슷할 것 같고, Emacs Lisp 내에서는 용도 면에서 &lt;a href="../article/emacs-lisp-plist.html"&gt;plist&lt;/a&gt;와도 좀 비슷한 편이다. 참고로 plist와는 다르게 alist는 Common Lisp과 사용법이 비슷한 편이다.&lt;/p&gt;
&lt;p&gt;alist의 데이터는 키와 값이 점(&lt;code&gt;.&lt;/code&gt;)으로 구분되는 형식으로 표현된다. 혹은 &lt;code&gt;cons&lt;/code&gt;라는 함수를 이용해 키와 값을 연속으로 배열하기도 한다. 예제로 아래의 두 줄은 같은 키와 문자열 값을 표현하는 두 가지 방식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;'(key . &amp;quot;value&amp;quot;)
(cons ('key &amp;quot;value'))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 키와 값의 쌍 데이터는 &lt;code&gt;car&lt;/code&gt; 혹은 &lt;code&gt;cdr&lt;/code&gt; 같은 함수를 이용해 키와 값을 분리해 낼 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(cdr '(name . &amp;quot;Conrad&amp;quot;))
;; =&amp;gt; Conrad
(car '(name . &amp;quot;Conrad&amp;quot;))
;; =&amp;gt; name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사실 좀 미묘한게 앞과 뒤 어떤 게 키일까 정의할 수는 없다. 왜냐하면 alist는 키나 값 개념 자체가 없고 둘 다 기준으로 사용할 수 있기 때문이다. 다만 &lt;strong&gt;일반적으로 키-값(key-value) 순서가 많이 쓰여서 여기에 맞춰지는 경우가 많을 뿐&lt;/strong&gt;이다. 이 글의 예시에서도 키-값 순서로 사용함에 주의하자.&lt;/p&gt;
&lt;h2&gt;alist 생성&lt;/h2&gt;
&lt;p&gt;alist를 생성하는 방법 중 자주 사용되는 방법으로 &lt;a href="../article/emacs-lisp-single-quote.html"&gt;인용(quote)&lt;/a&gt;을 이용한 축약 표현이 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mycard
      '((name . &amp;quot;Conrad&amp;quot;)
        (age . 20)
        (phone . &amp;quot;82-10-1234-5678&amp;quot;)
        (address . &amp;quot;Earth, Milkyway, Laniakea Supercluster&amp;quot;)
        (:memo . &amp;quot;Lazy Human&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 외에 &lt;code&gt;cons&lt;/code&gt;를 이용할 경우는 아래와 같은 식으로도 표현할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mycard
      (list (cons 'name &amp;quot;Conrad&amp;quot;)
            (cons 'age 20)
            (cons 'phone &amp;quot;82-10-1234-5678&amp;quot;)
            (cons 'address &amp;quot;Earth, Milkyway, Laniakea Supercluster&amp;quot;)
            (cons :memo &amp;quot;Lazy Human&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;둘 다 동일한 데이터를 생성하기 때문에 원하는 방식을 사용하면 된다.&lt;/p&gt;
&lt;p&gt;이 외에 약간 독특하게 키 리스트와 값 리스트를 이용해 alist를 생성하고 싶다면 &lt;code&gt;cl-pairlis&lt;/code&gt; 함수를 사용해보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(cl-pairlis '(key1 key2 key3) '(&amp;quot;value1&amp;quot; &amp;quot;value2&amp;quot; &amp;quot;value3&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Common Lisp의 함수이기 때문에 Common Lisp에서는 'cl-' 접두어를 때어내고 &lt;code&gt;pairlis&lt;/code&gt; 함수를 쓰면 될 거라 예상된다.&lt;/p&gt;
&lt;h2&gt;특정 키의 데이터 쌍 및 값 얻기&lt;/h2&gt;
&lt;p&gt;특정 키의 데이터를 읽기 위해서는 &lt;code&gt;assoc&lt;/code&gt; 함수를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(assoc 'name mycard)
;; =&amp;gt; (name . Conrad)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;assoc&lt;/code&gt;의 경우 다른 언어와는 다르게 값 만을 읽는게 아니라 키와 값이 연결된 데이터 한 쌍을 얻을 수 있다. 그래서 값 만을 얻기 위해서 앞서 언급한 &lt;code&gt;cdr&lt;/code&gt; 함수를 추가로 이용해야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(cdr (assoc 'name mycard))
;; =&amp;gt; Conrad
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 &lt;code&gt;cdr&lt;/code&gt;과 &lt;code&gt;assoc&lt;/code&gt;의 조합은 사실 &lt;code&gt;alist-get&lt;/code&gt;이라는 함수 하나로 해결하는 것도 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(alist-get 'name mycard)
;; =&amp;gt; Conrad
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 외에도 &lt;code&gt;assoc&lt;/code&gt;와 비슷하지만 비교 함수가 다른 &lt;code&gt;assq&lt;/code&gt; 등도 있으니 필요하다면 레퍼런스를 찾아보자.&lt;/p&gt;
&lt;h2&gt;특정 값으로 데이터 쌍 및 키 얻기&lt;/h2&gt;
&lt;p&gt;보통 사전형 자료구조에선 쉽게(?) 허용하지 않는 alist의 특수한 기능으로 값을 이용해 데이터 쌍을 얻을 수 있는 방법을 제공한다. &lt;code&gt;assoc&lt;/code&gt;의 뒤집어진(reversed?) 형태인 &lt;code&gt;rassoc&lt;/code&gt; 함수를 사용한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(rassoc 20 mycard)
;; =&amp;gt; (age . 20)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이번에도 키와 값 쌍을 얻을 수 있는데 여기서 키를 분리해 내고 싶다면 앞서 언급한 &lt;code&gt;car&lt;/code&gt; 함수를 이용해 뽑아낼 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(car (rassoc 20 mycard))
;; =&amp;gt; age
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 키-값 기반의 데이터를 운용할 때는 아무래도 키 기준을 사용하는 경우가 대부분이라 이 기능을 쓰게 될 일이 있을지는 잘 모르겠다.&lt;/p&gt;
&lt;h2&gt;alist에 데이터 쌍 추가하기&lt;/h2&gt;
&lt;p&gt;이미 만들어진 alist 인스턴스에 새로운 키-값 쌍을 추가하는 대표적인 방법으로 Emacs 설정 중 자주 볼 수 있는 &lt;code&gt;add-to-list&lt;/code&gt; 함수를 사용할 수 있다. 예를 들어 아래는 mycard라는 alist를 생성하고 여기에 nick과 job이라는 두 개의 키와 값을 추가하는 예제다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mycard
      '((name . &amp;quot;Conrad&amp;quot;)
        (age . 20)
        (phone . &amp;quot;82-10-1234-5678&amp;quot;)
        (address . &amp;quot;Earth, Milkyway, Laniakea Supercluster&amp;quot;)
        (:memo . &amp;quot;Lazy Human&amp;quot;)))
(add-to-list 'mycard (cons 'nick &amp;quot;Seorenn&amp;quot;))
(add-to-list 'mycard '(job &amp;quot;Untitled&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그밖에 &lt;code&gt;push&lt;/code&gt; 함수를 사용할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(push (cons 'nick &amp;quot;Seorenn&amp;quot;) mycard)
(push '(job . &amp;quot;Untitled&amp;quot;) mycard)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 &lt;code&gt;add-to-list&lt;/code&gt;나 &lt;code&gt;push&lt;/code&gt; 함수는 리스트에 끼워 넣기만 하기 때문에 해당 키의 값을 변경하는 용도로는 사용할 수 없다. 애초에 alist는 키 개념이 없기도 하고 따라서 키를 중복시키는 것도 가능하다.&lt;/p&gt;
&lt;p&gt;이 외에 일반 리스트처럼 &lt;code&gt;append&lt;/code&gt;도 쓸 수 있지 않을까 예상된다.&lt;/p&gt;
&lt;h2&gt;alist에서 데이터 쌍 삭제하기&lt;/h2&gt;
&lt;p&gt;alist에서 특정 키를 가진 데이터 쌍을 모두 삭제하기 위해서 &lt;code&gt;assq-delete-all&lt;/code&gt; 함수를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(assq-delete-all 'job mycard)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;왜 -all이라는 접미어가 붙어있을까는 유니크 키 개념이 없다는 점 때문이라고 생각하면 된다. 중복되는 키가 있을 수 있기 때문에 몽땅 지워버린다는 의미 또한 충분히 있을 수 있다.&lt;/p&gt;
&lt;h2&gt;alist에서 특정 키의 값 수정하기&lt;/h2&gt;
&lt;p&gt;가장 간단한 방법으로 &lt;code&gt;setf&lt;/code&gt; 함수를 이용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;;; (setf (alist-get KEY ALIST) NEW-VALUE)
(setf (alist-get 'nick mycard) &amp;quot;another nick name&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용법은 주석에 적은 대로다. 약간 복잡한 것 같지만 키의 데이터 쌍을 다 삭제하고 다시 추가하는 것보다는 간단할 것 같다.&lt;/p&gt;
&lt;p&gt;코드 상으론 동작이 약간 이해되지 않는데, 아마도 &lt;code&gt;setf&lt;/code&gt;는 레퍼런스 혹은 포인터가 가 가리키는 메모리의 값을 갱신하는 것 같은 느낌이다.&lt;/p&gt;
&lt;h2&gt;마무리 및 관련된 글들&lt;/h2&gt;
&lt;p&gt;사실 소개 수준의 짧은 글을 쓰려고 했는데 예제가 생각보다 길어졌다. alist는 사전형이나 해시테이블과는 다르게 '연관된 데이터 묶음'에 가깝기 때문에 그 부분을 더 설명할 수밖에 없었던 것 같다. 그래서인지 이 외애도 많은 내용이 존재한다. 예를 들자면 테스트 함수 같은 개념도 있다. 상당히 많은 기능이 더 있으니 궁금하다면 링크된 관련글에서 내용을 더 찾아보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html" target="_blank"&gt;Association Lists📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-plist.html"&gt;Emacs Lisp의 plist 사용법 간단 정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;h2&gt;alist&lt;/h2&gt;
&lt;p&gt;Emacs Lisp에서 alist는 Association List의 축약어로, 한국어로 직역하면 '연관 목록' 정도로 표현할 수 있는 자료구조다. 다른 언어에서 자주 취급되는 가장 비슷한 자료구조를 들자면 사전형(dictionary)가 비슷할 것 같고, Emacs Lisp 내에서는 용도 면에서 &lt;a href="../article/emacs-lisp-plist.html"&gt;plist&lt;/a&gt;와도 좀 비슷한 편이다. 참고로 plist와는 다르게 alist는 Common Lisp과 사용법이 비슷한 편이다.&lt;/p&gt;
&lt;p&gt;alist의 데이터는 키와 값이 점(&lt;code&gt;.&lt;/code&gt;)으로 구분되는 형식으로 표현된다. 혹은 &lt;code&gt;cons&lt;/code&gt;라는 함수를 이용해 키와 값을 연속으로 배열하기도 한다. 예제로 아래의 두 줄은 같은 키와 문자열 값을 표현하는 두 가지 방식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;'(key . &amp;quot;value&amp;quot;)
(cons ('key &amp;quot;value'))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 키와 값의 쌍 데이터는 &lt;code&gt;car&lt;/code&gt; 혹은 &lt;code&gt;cdr&lt;/code&gt; 같은 함수를 이용해 키와 값을 분리해 낼 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(cdr '(name . &amp;quot;Conrad&amp;quot;))
;; =&amp;gt; Conrad
(car '(name . &amp;quot;Conrad&amp;quot;))
;; =&amp;gt; name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사실 좀 미묘한게 앞과 뒤 어떤 게 키일까 정의할 수는 없다. 왜냐하면 alist는 키나 값 개념 자체가 없고 둘 다 기준으로 사용할 수 있기 때문이다. 다만 &lt;strong&gt;일반적으로 키-값(key-value) 순서가 많이 쓰여서 여기에 맞춰지는 경우가 많을 뿐&lt;/strong&gt;이다. 이 글의 예시에서도 키-값 순서로 사용함에 주의하자.&lt;/p&gt;
&lt;h2&gt;alist 생성&lt;/h2&gt;
&lt;p&gt;alist를 생성하는 방법 중 자주 사용되는 방법으로 &lt;a href="../article/emacs-lisp-single-quote.html"&gt;인용(quote)&lt;/a&gt;을 이용한 축약 표현이 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mycard
      '((name . &amp;quot;Conrad&amp;quot;)
        (age . 20)
        (phone . &amp;quot;82-10-1234-5678&amp;quot;)
        (address . &amp;quot;Earth, Milkyway, Laniakea Supercluster&amp;quot;)
        (:memo . &amp;quot;Lazy Human&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 외에 &lt;code&gt;cons&lt;/code&gt;를 이용할 경우는 아래와 같은 식으로도 표현할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mycard
      (list (cons 'name &amp;quot;Conrad&amp;quot;)
            (cons 'age 20)
            (cons 'phone &amp;quot;82-10-1234-5678&amp;quot;)
            (cons 'address &amp;quot;Earth, Milkyway, Laniakea Supercluster&amp;quot;)
            (cons :memo &amp;quot;Lazy Human&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;둘 다 동일한 데이터를 생성하기 때문에 원하는 방식을 사용하면 된다.&lt;/p&gt;
&lt;p&gt;이 외에 약간 독특하게 키 리스트와 값 리스트를 이용해 alist를 생성하고 싶다면 &lt;code&gt;cl-pairlis&lt;/code&gt; 함수를 사용해보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(cl-pairlis '(key1 key2 key3) '(&amp;quot;value1&amp;quot; &amp;quot;value2&amp;quot; &amp;quot;value3&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Common Lisp의 함수이기 때문에 Common Lisp에서는 'cl-' 접두어를 때어내고 &lt;code&gt;pairlis&lt;/code&gt; 함수를 쓰면 될 거라 예상된다.&lt;/p&gt;
&lt;h2&gt;특정 키의 데이터 쌍 및 값 얻기&lt;/h2&gt;
&lt;p&gt;특정 키의 데이터를 읽기 위해서는 &lt;code&gt;assoc&lt;/code&gt; 함수를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(assoc 'name mycard)
;; =&amp;gt; (name . Conrad)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;assoc&lt;/code&gt;의 경우 다른 언어와는 다르게 값 만을 읽는게 아니라 키와 값이 연결된 데이터 한 쌍을 얻을 수 있다. 그래서 값 만을 얻기 위해서 앞서 언급한 &lt;code&gt;cdr&lt;/code&gt; 함수를 추가로 이용해야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(cdr (assoc 'name mycard))
;; =&amp;gt; Conrad
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 &lt;code&gt;cdr&lt;/code&gt;과 &lt;code&gt;assoc&lt;/code&gt;의 조합은 사실 &lt;code&gt;alist-get&lt;/code&gt;이라는 함수 하나로 해결하는 것도 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(alist-get 'name mycard)
;; =&amp;gt; Conrad
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 외에도 &lt;code&gt;assoc&lt;/code&gt;와 비슷하지만 비교 함수가 다른 &lt;code&gt;assq&lt;/code&gt; 등도 있으니 필요하다면 레퍼런스를 찾아보자.&lt;/p&gt;
&lt;h2&gt;특정 값으로 데이터 쌍 및 키 얻기&lt;/h2&gt;
&lt;p&gt;보통 사전형 자료구조에선 쉽게(?) 허용하지 않는 alist의 특수한 기능으로 값을 이용해 데이터 쌍을 얻을 수 있는 방법을 제공한다. &lt;code&gt;assoc&lt;/code&gt;의 뒤집어진(reversed?) 형태인 &lt;code&gt;rassoc&lt;/code&gt; 함수를 사용한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(rassoc 20 mycard)
;; =&amp;gt; (age . 20)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이번에도 키와 값 쌍을 얻을 수 있는데 여기서 키를 분리해 내고 싶다면 앞서 언급한 &lt;code&gt;car&lt;/code&gt; 함수를 이용해 뽑아낼 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(car (rassoc 20 mycard))
;; =&amp;gt; age
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 키-값 기반의 데이터를 운용할 때는 아무래도 키 기준을 사용하는 경우가 대부분이라 이 기능을 쓰게 될 일이 있을지는 잘 모르겠다.&lt;/p&gt;
&lt;h2&gt;alist에 데이터 쌍 추가하기&lt;/h2&gt;
&lt;p&gt;이미 만들어진 alist 인스턴스에 새로운 키-값 쌍을 추가하는 대표적인 방법으로 Emacs 설정 중 자주 볼 수 있는 &lt;code&gt;add-to-list&lt;/code&gt; 함수를 사용할 수 있다. 예를 들어 아래는 mycard라는 alist를 생성하고 여기에 nick과 job이라는 두 개의 키와 값을 추가하는 예제다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mycard
      '((name . &amp;quot;Conrad&amp;quot;)
        (age . 20)
        (phone . &amp;quot;82-10-1234-5678&amp;quot;)
        (address . &amp;quot;Earth, Milkyway, Laniakea Supercluster&amp;quot;)
        (:memo . &amp;quot;Lazy Human&amp;quot;)))
(add-to-list 'mycard (cons 'nick &amp;quot;Seorenn&amp;quot;))
(add-to-list 'mycard '(job &amp;quot;Untitled&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그밖에 &lt;code&gt;push&lt;/code&gt; 함수를 사용할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(push (cons 'nick &amp;quot;Seorenn&amp;quot;) mycard)
(push '(job . &amp;quot;Untitled&amp;quot;) mycard)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 &lt;code&gt;add-to-list&lt;/code&gt;나 &lt;code&gt;push&lt;/code&gt; 함수는 리스트에 끼워 넣기만 하기 때문에 해당 키의 값을 변경하는 용도로는 사용할 수 없다. 애초에 alist는 키 개념이 없기도 하고 따라서 키를 중복시키는 것도 가능하다.&lt;/p&gt;
&lt;p&gt;이 외에 일반 리스트처럼 &lt;code&gt;append&lt;/code&gt;도 쓸 수 있지 않을까 예상된다.&lt;/p&gt;
&lt;h2&gt;alist에서 데이터 쌍 삭제하기&lt;/h2&gt;
&lt;p&gt;alist에서 특정 키를 가진 데이터 쌍을 모두 삭제하기 위해서 &lt;code&gt;assq-delete-all&lt;/code&gt; 함수를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(assq-delete-all 'job mycard)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;왜 -all이라는 접미어가 붙어있을까는 유니크 키 개념이 없다는 점 때문이라고 생각하면 된다. 중복되는 키가 있을 수 있기 때문에 몽땅 지워버린다는 의미 또한 충분히 있을 수 있다.&lt;/p&gt;
&lt;h2&gt;alist에서 특정 키의 값 수정하기&lt;/h2&gt;
&lt;p&gt;가장 간단한 방법으로 &lt;code&gt;setf&lt;/code&gt; 함수를 이용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;;; (setf (alist-get KEY ALIST) NEW-VALUE)
(setf (alist-get 'nick mycard) &amp;quot;another nick name&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용법은 주석에 적은 대로다. 약간 복잡한 것 같지만 키의 데이터 쌍을 다 삭제하고 다시 추가하는 것보다는 간단할 것 같다.&lt;/p&gt;
&lt;p&gt;코드 상으론 동작이 약간 이해되지 않는데, 아마도 &lt;code&gt;setf&lt;/code&gt;는 레퍼런스 혹은 포인터가 가 가리키는 메모리의 값을 갱신하는 것 같은 느낌이다.&lt;/p&gt;
&lt;h2&gt;마무리 및 관련된 글들&lt;/h2&gt;
&lt;p&gt;사실 소개 수준의 짧은 글을 쓰려고 했는데 예제가 생각보다 길어졌다. alist는 사전형이나 해시테이블과는 다르게 '연관된 데이터 묶음'에 가깝기 때문에 그 부분을 더 설명할 수밖에 없었던 것 같다. 그래서인지 이 외애도 많은 내용이 존재한다. 예를 들자면 테스트 함수 같은 개념도 있다. 상당히 많은 기능이 더 있으니 궁금하다면 링크된 관련글에서 내용을 더 찾아보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html" target="_blank"&gt;Association Lists📎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-plist.html"&gt;Emacs Lisp의 plist 사용법 간단 정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/emacs-lisp-alist.html</guid>
      <pubDate>Thu, 27 Jun 2024 10:24:00 +0900</pubDate>
    </item>
    <item>
      <title>Emacs Lisp의 plist 사용법 간단 정리</title>
      <link>https://seorenn.github.io/article/emacs-lisp-plist.html</link>
      <description>&lt;h2&gt;plist&lt;/h2&gt;
&lt;p&gt;Emacs Lisp에서 plist는 'Property List'의 축약어로 다른 언어의 사전형(dictionary type)과 비슷한 기능의 자료구조를 제공한다. 참고로 Common Lisp에도 동일한 자료형은 있으나 사용법은 조금 다른 것 같다.&lt;/p&gt;
&lt;p&gt;기본적으로 plist 자료구조는 단순 리스트에 키와 값이 연속으로 나열되는 구조라 표현에서 상당히 간결한 편이다.&lt;/p&gt;
&lt;h2&gt;plist 인스턴스 생성&lt;/h2&gt;
&lt;p&gt;plist 데이터를 생성하는 방법은 일반 리스트와 동일하다. 단지 요소 배치를 키와 값 순서대로 나열해야 한다는 특징이 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mycard
      '(name &amp;quot;Conrad&amp;quot;
        age 20
        phone &amp;quot;82-10-1234-5678&amp;quot;
        address &amp;quot;Earth, Milkyway, Laniakea Supercluster&amp;quot;
        :memo &amp;quot;Lazy Human&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 키와 값을 나열하면 plist 형식의 인스턴스가 생성된다.&lt;/p&gt;
&lt;p&gt;위의 예에서 약간 특이하게 &lt;code&gt;:memo&lt;/code&gt;만 앞에 콜론(&lt;code&gt;:&lt;/code&gt;)이 붙어있는데 Emacs Lisp에서 심볼을 표현하는 문법이며 이런 형식도 쓸 수 있다는 것을 알려주기 위함이지 다른 의미가 있는 것은 아니다.&lt;/p&gt;
&lt;h2&gt;plist에서 키의 값 읽기&lt;/h2&gt;
&lt;p&gt;plist 데이터에서 특정 키의 값을 읽을 때는 &lt;code&gt;plist-get&lt;/code&gt; 함수를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(plist-get mycard 'name)
;; -&amp;gt; &amp;quot;Conrad&amp;quot;
(plist-get mycard :memo)
;; -&amp;gt; &amp;quot;Lazy Human&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;plist에서 키의 값 쓰기&lt;/h2&gt;
&lt;p&gt;plist 데이터에 키와 값을 추가로 쓰거나 업데이트하기 위해서는 &lt;code&gt;plist-put&lt;/code&gt; 함수를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(plist-put mycard 'gender &amp;quot;etc&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-alist.html"&gt;Emacs Lisp의 alist 사용법 간단 정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;h2&gt;plist&lt;/h2&gt;
&lt;p&gt;Emacs Lisp에서 plist는 'Property List'의 축약어로 다른 언어의 사전형(dictionary type)과 비슷한 기능의 자료구조를 제공한다. 참고로 Common Lisp에도 동일한 자료형은 있으나 사용법은 조금 다른 것 같다.&lt;/p&gt;
&lt;p&gt;기본적으로 plist 자료구조는 단순 리스트에 키와 값이 연속으로 나열되는 구조라 표현에서 상당히 간결한 편이다.&lt;/p&gt;
&lt;h2&gt;plist 인스턴스 생성&lt;/h2&gt;
&lt;p&gt;plist 데이터를 생성하는 방법은 일반 리스트와 동일하다. 단지 요소 배치를 키와 값 순서대로 나열해야 한다는 특징이 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mycard
      '(name &amp;quot;Conrad&amp;quot;
        age 20
        phone &amp;quot;82-10-1234-5678&amp;quot;
        address &amp;quot;Earth, Milkyway, Laniakea Supercluster&amp;quot;
        :memo &amp;quot;Lazy Human&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 키와 값을 나열하면 plist 형식의 인스턴스가 생성된다.&lt;/p&gt;
&lt;p&gt;위의 예에서 약간 특이하게 &lt;code&gt;:memo&lt;/code&gt;만 앞에 콜론(&lt;code&gt;:&lt;/code&gt;)이 붙어있는데 Emacs Lisp에서 심볼을 표현하는 문법이며 이런 형식도 쓸 수 있다는 것을 알려주기 위함이지 다른 의미가 있는 것은 아니다.&lt;/p&gt;
&lt;h2&gt;plist에서 키의 값 읽기&lt;/h2&gt;
&lt;p&gt;plist 데이터에서 특정 키의 값을 읽을 때는 &lt;code&gt;plist-get&lt;/code&gt; 함수를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(plist-get mycard 'name)
;; -&amp;gt; &amp;quot;Conrad&amp;quot;
(plist-get mycard :memo)
;; -&amp;gt; &amp;quot;Lazy Human&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;plist에서 키의 값 쓰기&lt;/h2&gt;
&lt;p&gt;plist 데이터에 키와 값을 추가로 쓰거나 업데이트하기 위해서는 &lt;code&gt;plist-put&lt;/code&gt; 함수를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(plist-put mycard 'gender &amp;quot;etc&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-alist.html"&gt;Emacs Lisp의 alist 사용법 간단 정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/emacs-lisp-plist.html</guid>
      <pubDate>Wed, 26 Jun 2024 23:12:00 +0900</pubDate>
    </item>
    <item>
      <title>Emacs Lisp에서 인용된 리스트 요소들 현실화(?) 하기</title>
      <link>https://seorenn.github.io/article/emacs-lisp-eval-quoted-list-elements.html</link>
      <description>&lt;p&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;작은따옴표&lt;/a&gt; 글에서 정리했다시피 Emacs Lisp에서 인용(quote) 즉 작은따옴표(&lt;code&gt;'&lt;/code&gt;) 등을 이용해 리스트를 표현하면 내부의 값들이 입력된 그대로 들어가 있게 된다. 예를 들자면 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(defun doubled (v)
  (* v 2))

(setq mylist '((doubled 2) (doubled 4) (doubled 8)))

;; mylist = ((doubled 2) (doubled 4) (doubled 8))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경우 예시 하단의 주석에서 처럼 mylist에는 &lt;code&gt;(2 4 8)&lt;/code&gt;과 같은 값으로 구성된 리스트가 아니라 각 요소로 지정된 함수가 실행되기 전 상태로 그대로 구성되어 있는 모습을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;의도에 따라 다르겠지만, 만약 각 요소에 배정된 명령이 실행된 값으로 리스트를 구성하고자 한다면 어떻게 해야 할까? 왜냐하면 이런 리스트의 요소들은 하나씩 꺼내서 &lt;code&gt;eval&lt;/code&gt;로 돌려보지 않으면 실제 값을 알 수가 없으니 말이다.&lt;/p&gt;
&lt;h2&gt;해결하기&lt;/h2&gt;
&lt;p&gt;이럴 때를 위해 역따옴표(&lt;code&gt;`&lt;/code&gt;)와 쉼표(&lt;code&gt;,&lt;/code&gt;) 기호를 활용할 수 있다. 역따옴표도 작은따옴표과 같이 인용(quote) 용도이며 리스트를 구성할 때 작은따옴표 대신 동일하게 사용할 수 있으나 쉼표와 조합되면 조금 특수한 능력을 발휘할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(defun doubled (v)
  (* v 2))

(setq mylist `(,(doubled 2) ,(doubled 4) ,(doubled 8)))

;; mylist = (4 8 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 역따옴표로 구성되는 각 요소들은 앞에 쉼표가 붙어있는 경우 원본 코드가 아닌 그 코드가 실행(eval)된 형태로 구성된다. &lt;/p&gt;
&lt;p&gt;앞서 이야기 했다시피 쉼표가 앞에 붙은 요소만 실행되며 따라서 일부만 실행되기 전의 값으로 구성하는 것도 가능하다. 예를 들어 아래와 같이 가운데 요소에서만 쉼표를 빼보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mylist `(,(doubled 2) (doubled 4) ,(doubled 8)))

;; mylist = (4 (doubled 4) 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 식으로 역따옴표로 구성한 리스트에서 쉼표가 빠진 요소는 실행되기 전의 코드로 그대로 리스트에 포함된다. 즉 역따옴표는 쉼표를 안 쓰면 기존 작은따옴표를 이용한 인용과 동일하게 동작한다.&lt;/p&gt;
&lt;h2&gt;대안&lt;/h2&gt;
&lt;p&gt;인용(quote)과 리스트 함수(&lt;code&gt;list&lt;/code&gt;)가 무엇이 다른지 알고 있다면 다른 선택지를 선택할 수도 있다. 인용 형식이 아니라 &lt;code&gt;list&lt;/code&gt; 함수를 이용해 구성하면 알아서 실행된 값을 리스트 구성에 그대로 이용할 수 있기 때문이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mylist (list (doubled 2) (doubled 4) (doubled 8)))

;; mylist = (4 8 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다만 이 경우는 직접 리스트를 구성할 수 있는 경우일 테고 다른 함수의 결과에서 리스트를 받아와야 할 때는 이런 경우가 아닐 수도 있다. 따라서 역따옴표와 쉼표를 활용하는 방법은 꼭 알아둬야 할 지도 모른다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;작은따옴표&lt;/a&gt; 글에서 정리했다시피 Emacs Lisp에서 인용(quote) 즉 작은따옴표(&lt;code&gt;'&lt;/code&gt;) 등을 이용해 리스트를 표현하면 내부의 값들이 입력된 그대로 들어가 있게 된다. 예를 들자면 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(defun doubled (v)
  (* v 2))

(setq mylist '((doubled 2) (doubled 4) (doubled 8)))

;; mylist = ((doubled 2) (doubled 4) (doubled 8))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경우 예시 하단의 주석에서 처럼 mylist에는 &lt;code&gt;(2 4 8)&lt;/code&gt;과 같은 값으로 구성된 리스트가 아니라 각 요소로 지정된 함수가 실행되기 전 상태로 그대로 구성되어 있는 모습을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;의도에 따라 다르겠지만, 만약 각 요소에 배정된 명령이 실행된 값으로 리스트를 구성하고자 한다면 어떻게 해야 할까? 왜냐하면 이런 리스트의 요소들은 하나씩 꺼내서 &lt;code&gt;eval&lt;/code&gt;로 돌려보지 않으면 실제 값을 알 수가 없으니 말이다.&lt;/p&gt;
&lt;h2&gt;해결하기&lt;/h2&gt;
&lt;p&gt;이럴 때를 위해 역따옴표(&lt;code&gt;`&lt;/code&gt;)와 쉼표(&lt;code&gt;,&lt;/code&gt;) 기호를 활용할 수 있다. 역따옴표도 작은따옴표과 같이 인용(quote) 용도이며 리스트를 구성할 때 작은따옴표 대신 동일하게 사용할 수 있으나 쉼표와 조합되면 조금 특수한 능력을 발휘할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(defun doubled (v)
  (* v 2))

(setq mylist `(,(doubled 2) ,(doubled 4) ,(doubled 8)))

;; mylist = (4 8 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 역따옴표로 구성되는 각 요소들은 앞에 쉼표가 붙어있는 경우 원본 코드가 아닌 그 코드가 실행(eval)된 형태로 구성된다. &lt;/p&gt;
&lt;p&gt;앞서 이야기 했다시피 쉼표가 앞에 붙은 요소만 실행되며 따라서 일부만 실행되기 전의 값으로 구성하는 것도 가능하다. 예를 들어 아래와 같이 가운데 요소에서만 쉼표를 빼보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mylist `(,(doubled 2) (doubled 4) ,(doubled 8)))

;; mylist = (4 (doubled 4) 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 식으로 역따옴표로 구성한 리스트에서 쉼표가 빠진 요소는 실행되기 전의 코드로 그대로 리스트에 포함된다. 즉 역따옴표는 쉼표를 안 쓰면 기존 작은따옴표를 이용한 인용과 동일하게 동작한다.&lt;/p&gt;
&lt;h2&gt;대안&lt;/h2&gt;
&lt;p&gt;인용(quote)과 리스트 함수(&lt;code&gt;list&lt;/code&gt;)가 무엇이 다른지 알고 있다면 다른 선택지를 선택할 수도 있다. 인용 형식이 아니라 &lt;code&gt;list&lt;/code&gt; 함수를 이용해 구성하면 알아서 실행된 값을 리스트 구성에 그대로 이용할 수 있기 때문이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq mylist (list (doubled 2) (doubled 4) (doubled 8)))

;; mylist = (4 8 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다만 이 경우는 직접 리스트를 구성할 수 있는 경우일 테고 다른 함수의 결과에서 리스트를 받아와야 할 때는 이런 경우가 아닐 수도 있다. 따라서 역따옴표와 쉼표를 활용하는 방법은 꼭 알아둬야 할 지도 모른다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-single-quote.html"&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/emacs-lisp-eval-quoted-list-elements.html</guid>
      <pubDate>Tue, 25 Jun 2024 21:46:00 +0900</pubDate>
    </item>
    <item>
      <title>Emacs Lisp에서 작은따옴표의 의미</title>
      <link>https://seorenn.github.io/article/emacs-lisp-single-quote.html</link>
      <description>&lt;p&gt;Emacs Lisp 코드를 보면 작은따옴표가 종종 보이는데 유독 한 쌍이 아니라 한 개씩만 보여서 상당히 혼란스러웠었다. 왜냐하면 다른 언어에서 작은따옴표는 문자 혹은 문자열을 둘러싸는 특수 기호로 쓰이니 말이다.&lt;/p&gt;
&lt;p&gt;즉 Emacs Lisp에서 작은따옴표는 다른 언어들과는 다른 의미로 쓰인다. 도대체 이 작은따옴표는 무슨 의미일까?&lt;/p&gt;
&lt;h2&gt;Emacs Lisp에서 순수한 데이터 리스트 표현하기&lt;/h2&gt;
&lt;p&gt;Common Lisp을 포함하여 Emacs Lisp에서 모든 요소는 리스트로 표현된다. 그리고 리스트의 특징 중 하나로 첫 요소는 바로 함수여야 한다는 점이 있다.&lt;/p&gt;
&lt;p&gt;그래서 순수한 데이터 리스트를 표현할 때는 약간의 문제가 있다. 아래의 예를 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(print (1 2 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드의 의도는 &lt;code&gt;(1 2 3)&lt;/code&gt;이라는 리스트를 콘솔에 표시하고 싶은 것인데, 블행히도 '1이라는 함수는 없다'는 식의 오류가 발생하는 코드다. 앞서 이야기 했다시피 Lisp에서 리스트의 첫 요소는 함수여야 하기 때문이다.&lt;/p&gt;
&lt;p&gt;만약 순수한 데이터 리스트로 &lt;code&gt;(1 2 3)&lt;/code&gt;을 표현하려면 어떻게 해야 할까? &lt;/p&gt;
&lt;p&gt;대략 두 가지 방법이 있는데 하나는 &lt;code&gt;list&lt;/code&gt;라는 함수를 이용해 인스턴스를 생성하는 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(print (list 1 2 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같이 하면 의도대로 동작하는 것을 확인할 수 있다. &lt;/p&gt;
&lt;p&gt;두가지라고 했으니 나머지 하나가 남았다. 그 나머지가 이 글의 주제와 관련이 있다.&lt;/p&gt;
&lt;h2&gt;Emacs Lisp에서 작은따옴표의 용도&lt;/h2&gt;
&lt;p&gt;리스트 데이터를 표현하기 위해 &lt;code&gt;list&lt;/code&gt; 함수를 이용하는 것보다 더 직관적인 방법이 있는데 바로 이번 글의 주제인 작은따옴표를 써서 할 수 있다. 아래와 같은 식으로 말이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(print '(1 2 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 &lt;code&gt;list&lt;/code&gt; 함수를 이용한 경우와 동일하게 동작하면서도 코드 자체는 더 간결하게 느껴진다. 이게 바로 작은따옴표가 자주 쓰이는 용도다.&lt;/p&gt;
&lt;p&gt;사실 작은따옴표는 &lt;code&gt;quote&lt;/code&gt;라는 함수라고 이해하면 된다. 위와 코드는 아래 코드와 동일하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(print (quote 1 2 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그렇다면 "작은따옴표는 데이터 리스트를 표현하기 위해 사용하는구나"라고 이해하면 될까? 틀린 건 아니겠지만 원칙적으로 맞지는 않는 설명이다.&lt;/p&gt;
&lt;h2&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/h2&gt;
&lt;p&gt;Emacs Lisp에서 작은따옴표(&lt;code&gt;'&lt;/code&gt;, single quote)는 사실은 "실행시키지 않는다"는 의미로 대충 둘러대는 게 맞을 것 같다. 이 작은따옴표로 인용된 리스트는 리스트 자체를 그대로 표현하는 것이기 때문이다.&lt;/p&gt;
&lt;p&gt;약간 비슷하지만 다른 예를 보자. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(defun doubled (x)
  (+ x x))

(print '(doubled 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드가 실행되면 어떻게 될까? 별로 생각할 필요 없이 그대로 &lt;code&gt;(doubled 2)&lt;/code&gt;가 출력된다. 작은따옴표로 인용된 리스트는 별도의 처리가 없으면 그대로 표현될 뿐이다.&lt;/p&gt;
&lt;p&gt;이번에는 아예 이상한(?) 영단어를 요소로 리스트를 구성해 봤다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(print '(aaa bbb ccc))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드에서 참조하는 &lt;code&gt;aaa&lt;/code&gt;, &lt;code&gt;bbb&lt;/code&gt;, &lt;code&gt;ccc&lt;/code&gt;는 정의되지 않은 심볼이다. 따라서 실행시키면 오류가 나야 할 것 같다. &lt;/p&gt;
&lt;p&gt;하지만 위 코드는 &lt;code&gt;(aaa bbb ccc)&lt;/code&gt;를 그대로 출력할 뿐 오류가 나지 않는다. 왜냐하면 해당 리스트의 각 요소는 아직 실체화되지 않았기 때문이다.&lt;/p&gt;
&lt;p&gt;결과적으로 &lt;code&gt;list&lt;/code&gt; 함수를 이용해 생성한 순수 데이터 리스트와 작은따옴표를 이용해 생성한 인용(quote)된 리스트는 결과적으로는 동일하게 사용할 수 있지만 &lt;strong&gt;본질적으로는 다르다&lt;/strong&gt;는 말이다. 그저 작은따옴표를 데이터 리스트를 표현하는 데 자주 사용할 뿐이다.&lt;/p&gt;
&lt;p&gt;참고로 작은따옴표나 &lt;code&gt;quote&lt;/code&gt;로 인용된 리스트는 &lt;code&gt;eval&lt;/code&gt;로 일반 리스트화 하는 것도 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(eval '(1 2 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;'1이라는 함수는 없다'는 오류가 발생한다. 제일 처음의 이야기다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-eval-quoted-list-elements.html"&gt;Emacs Lisp에서 인용된 리스트 요소들 현실화(?) 하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-sharp-quote-sign.md.html"&gt;Emacs Lisp에서 샤프 작은따옴표(#') 기호의 의미&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;Emacs Lisp 코드를 보면 작은따옴표가 종종 보이는데 유독 한 쌍이 아니라 한 개씩만 보여서 상당히 혼란스러웠었다. 왜냐하면 다른 언어에서 작은따옴표는 문자 혹은 문자열을 둘러싸는 특수 기호로 쓰이니 말이다.&lt;/p&gt;
&lt;p&gt;즉 Emacs Lisp에서 작은따옴표는 다른 언어들과는 다른 의미로 쓰인다. 도대체 이 작은따옴표는 무슨 의미일까?&lt;/p&gt;
&lt;h2&gt;Emacs Lisp에서 순수한 데이터 리스트 표현하기&lt;/h2&gt;
&lt;p&gt;Common Lisp을 포함하여 Emacs Lisp에서 모든 요소는 리스트로 표현된다. 그리고 리스트의 특징 중 하나로 첫 요소는 바로 함수여야 한다는 점이 있다.&lt;/p&gt;
&lt;p&gt;그래서 순수한 데이터 리스트를 표현할 때는 약간의 문제가 있다. 아래의 예를 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(print (1 2 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드의 의도는 &lt;code&gt;(1 2 3)&lt;/code&gt;이라는 리스트를 콘솔에 표시하고 싶은 것인데, 블행히도 '1이라는 함수는 없다'는 식의 오류가 발생하는 코드다. 앞서 이야기 했다시피 Lisp에서 리스트의 첫 요소는 함수여야 하기 때문이다.&lt;/p&gt;
&lt;p&gt;만약 순수한 데이터 리스트로 &lt;code&gt;(1 2 3)&lt;/code&gt;을 표현하려면 어떻게 해야 할까? &lt;/p&gt;
&lt;p&gt;대략 두 가지 방법이 있는데 하나는 &lt;code&gt;list&lt;/code&gt;라는 함수를 이용해 인스턴스를 생성하는 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(print (list 1 2 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같이 하면 의도대로 동작하는 것을 확인할 수 있다. &lt;/p&gt;
&lt;p&gt;두가지라고 했으니 나머지 하나가 남았다. 그 나머지가 이 글의 주제와 관련이 있다.&lt;/p&gt;
&lt;h2&gt;Emacs Lisp에서 작은따옴표의 용도&lt;/h2&gt;
&lt;p&gt;리스트 데이터를 표현하기 위해 &lt;code&gt;list&lt;/code&gt; 함수를 이용하는 것보다 더 직관적인 방법이 있는데 바로 이번 글의 주제인 작은따옴표를 써서 할 수 있다. 아래와 같은 식으로 말이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(print '(1 2 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 &lt;code&gt;list&lt;/code&gt; 함수를 이용한 경우와 동일하게 동작하면서도 코드 자체는 더 간결하게 느껴진다. 이게 바로 작은따옴표가 자주 쓰이는 용도다.&lt;/p&gt;
&lt;p&gt;사실 작은따옴표는 &lt;code&gt;quote&lt;/code&gt;라는 함수라고 이해하면 된다. 위와 코드는 아래 코드와 동일하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(print (quote 1 2 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그렇다면 "작은따옴표는 데이터 리스트를 표현하기 위해 사용하는구나"라고 이해하면 될까? 틀린 건 아니겠지만 원칙적으로 맞지는 않는 설명이다.&lt;/p&gt;
&lt;h2&gt;Emacs Lisp에서 작은따옴표의 의미&lt;/h2&gt;
&lt;p&gt;Emacs Lisp에서 작은따옴표(&lt;code&gt;'&lt;/code&gt;, single quote)는 사실은 "실행시키지 않는다"는 의미로 대충 둘러대는 게 맞을 것 같다. 이 작은따옴표로 인용된 리스트는 리스트 자체를 그대로 표현하는 것이기 때문이다.&lt;/p&gt;
&lt;p&gt;약간 비슷하지만 다른 예를 보자. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(defun doubled (x)
  (+ x x))

(print '(doubled 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드가 실행되면 어떻게 될까? 별로 생각할 필요 없이 그대로 &lt;code&gt;(doubled 2)&lt;/code&gt;가 출력된다. 작은따옴표로 인용된 리스트는 별도의 처리가 없으면 그대로 표현될 뿐이다.&lt;/p&gt;
&lt;p&gt;이번에는 아예 이상한(?) 영단어를 요소로 리스트를 구성해 봤다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(print '(aaa bbb ccc))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드에서 참조하는 &lt;code&gt;aaa&lt;/code&gt;, &lt;code&gt;bbb&lt;/code&gt;, &lt;code&gt;ccc&lt;/code&gt;는 정의되지 않은 심볼이다. 따라서 실행시키면 오류가 나야 할 것 같다. &lt;/p&gt;
&lt;p&gt;하지만 위 코드는 &lt;code&gt;(aaa bbb ccc)&lt;/code&gt;를 그대로 출력할 뿐 오류가 나지 않는다. 왜냐하면 해당 리스트의 각 요소는 아직 실체화되지 않았기 때문이다.&lt;/p&gt;
&lt;p&gt;결과적으로 &lt;code&gt;list&lt;/code&gt; 함수를 이용해 생성한 순수 데이터 리스트와 작은따옴표를 이용해 생성한 인용(quote)된 리스트는 결과적으로는 동일하게 사용할 수 있지만 &lt;strong&gt;본질적으로는 다르다&lt;/strong&gt;는 말이다. 그저 작은따옴표를 데이터 리스트를 표현하는 데 자주 사용할 뿐이다.&lt;/p&gt;
&lt;p&gt;참고로 작은따옴표나 &lt;code&gt;quote&lt;/code&gt;로 인용된 리스트는 &lt;code&gt;eval&lt;/code&gt;로 일반 리스트화 하는 것도 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(eval '(1 2 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;'1이라는 함수는 없다'는 오류가 발생한다. 제일 처음의 이야기다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-eval-quoted-list-elements.html"&gt;Emacs Lisp에서 인용된 리스트 요소들 현실화(?) 하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../article/emacs-lisp-sharp-quote-sign.md.html"&gt;Emacs Lisp에서 샤프 작은따옴표(#') 기호의 의미&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/emacs-lisp-single-quote.html</guid>
      <pubDate>Mon, 24 Jun 2024 23:02:00 +0900</pubDate>
    </item>
    <item>
      <title>한 주간의 애플 소식 모음 24-06-23</title>
      <link>https://seorenn.github.io/log/20240623-00.html</link>
      <description>&lt;h2&gt;소프트웨어 릴리즈 소식&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS 14.6 developer beta&lt;/li&gt;
&lt;li&gt;iOS 17.6 developer beta: TV 앱에 Catch Up 기능 도입 등&lt;/li&gt;
&lt;li&gt;iPadOS 17.6 developer beta&lt;/li&gt;
&lt;li&gt;visionOS 1.3 developer beta&lt;/li&gt;
&lt;li&gt;watchOS 10.6 developer beta&lt;/li&gt;
&lt;li&gt;tvOS 17.6 developer beta&lt;/li&gt;
&lt;li&gt;Final Cut Pro 10.8 for macOS&lt;/li&gt;
&lt;li&gt;Final Cut Pro 2 for iPad&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;각 OS들은 마이너 업데이트임에도 전반적으로 무슨 변화가 있었는지 알려지지는 않았다.&lt;/p&gt;
&lt;h2&gt;애플 플랫폼 OS 차기 버전의 새로운 소식&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;watchOS 11: 낮잠 감지 기능을 지원한다고 한다.&lt;/li&gt;
&lt;li&gt;iOS 18: 앱 개발 시 iOS의 번역 기능을 앱 내에 통합할 수 있게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;제품 루머들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;애플 워치 시리즈 10은 디스플레이가 전작에 비해 더 커지고 전체적인 두께도 더 얇아질 것 같다.&lt;/li&gt;
&lt;li&gt;애플은 비전프로의 차세대판 보다는 염가판 개발에 주력하는 모양이다. 비싼 가격이 가장 큰 단점으로 지적된 만큼 당연한 처사로 보인다.&lt;/li&gt;
&lt;li&gt;비전프로의 염가판은 아이폰이나 맥과의 연결을 필수로 할 지도 모르겠다. 즉 자체적으로 모든 기능을 구동하기엔 성능이 부족할 수도 있다는 말이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;기타&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;애플의 선구매 후불결제 서비스인 Apple Pay Later의 신규 서비스가 중단된다. 대안으로 Apple Pay 할부 대출을 사용할 수 있다고 한다. 미국 한정 이야기 같다.&lt;/li&gt;
&lt;li&gt;애플지능의 중국 내 서비스가 불투명한 모양이다. 아마도 애플 자체 클라우드 인프라 접근을 중국이 불허할 가능성이 높을 것 같다. 이에 애플은 중국 기업 AI 서비스와의 통합을 추진 중으로 알려졌지만 기능적 제한은 어쩔 수 없을 것 같다.&lt;/li&gt;
&lt;li&gt;유럽에서도 애플지능이나 미러링, 쉐어플레이 등등 몇몇 기능 지원이 불투명한 모양이다. 어처구니 없게도 유럽의 DMA 규제가 발목을 잡고 있는 듯하다.&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;h2&gt;소프트웨어 릴리즈 소식&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS 14.6 developer beta&lt;/li&gt;
&lt;li&gt;iOS 17.6 developer beta: TV 앱에 Catch Up 기능 도입 등&lt;/li&gt;
&lt;li&gt;iPadOS 17.6 developer beta&lt;/li&gt;
&lt;li&gt;visionOS 1.3 developer beta&lt;/li&gt;
&lt;li&gt;watchOS 10.6 developer beta&lt;/li&gt;
&lt;li&gt;tvOS 17.6 developer beta&lt;/li&gt;
&lt;li&gt;Final Cut Pro 10.8 for macOS&lt;/li&gt;
&lt;li&gt;Final Cut Pro 2 for iPad&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;각 OS들은 마이너 업데이트임에도 전반적으로 무슨 변화가 있었는지 알려지지는 않았다.&lt;/p&gt;
&lt;h2&gt;애플 플랫폼 OS 차기 버전의 새로운 소식&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;watchOS 11: 낮잠 감지 기능을 지원한다고 한다.&lt;/li&gt;
&lt;li&gt;iOS 18: 앱 개발 시 iOS의 번역 기능을 앱 내에 통합할 수 있게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;제품 루머들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;애플 워치 시리즈 10은 디스플레이가 전작에 비해 더 커지고 전체적인 두께도 더 얇아질 것 같다.&lt;/li&gt;
&lt;li&gt;애플은 비전프로의 차세대판 보다는 염가판 개발에 주력하는 모양이다. 비싼 가격이 가장 큰 단점으로 지적된 만큼 당연한 처사로 보인다.&lt;/li&gt;
&lt;li&gt;비전프로의 염가판은 아이폰이나 맥과의 연결을 필수로 할 지도 모르겠다. 즉 자체적으로 모든 기능을 구동하기엔 성능이 부족할 수도 있다는 말이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;기타&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;애플의 선구매 후불결제 서비스인 Apple Pay Later의 신규 서비스가 중단된다. 대안으로 Apple Pay 할부 대출을 사용할 수 있다고 한다. 미국 한정 이야기 같다.&lt;/li&gt;
&lt;li&gt;애플지능의 중국 내 서비스가 불투명한 모양이다. 아마도 애플 자체 클라우드 인프라 접근을 중국이 불허할 가능성이 높을 것 같다. 이에 애플은 중국 기업 AI 서비스와의 통합을 추진 중으로 알려졌지만 기능적 제한은 어쩔 수 없을 것 같다.&lt;/li&gt;
&lt;li&gt;유럽에서도 애플지능이나 미러링, 쉐어플레이 등등 몇몇 기능 지원이 불투명한 모양이다. 어처구니 없게도 유럽의 DMA 규제가 발목을 잡고 있는 듯하다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240623-00.html</guid>
      <pubDate>Sun, 23 Jun 2024 21:32:00 +0900</pubDate>
    </item>
    <item>
      <title>Emacs Lisp에서 setq와 setq-default의 차이</title>
      <link>https://seorenn.github.io/article/emacs-lisp-setq-default.html</link>
      <description>&lt;p&gt;Emacs를 세팅하다 보면 생소한 느낌의 단어를 자주 사용하게 되는데 그 중에 &lt;code&gt;setq&lt;/code&gt;와 &lt;code&gt;setq-default&lt;/code&gt;의 차이에 대해 알아보자.&lt;/p&gt;
&lt;h2&gt;버퍼 로컬 변수 개념&lt;/h2&gt;
&lt;p&gt;Emacs에는 '버퍼 로컬(buffer-local) 변수'라는 특별한 개념이 있다. 마치 해당 버퍼에 종속되는 전역 변수와 비슷한 느낌으로 설명할 수 있다.&lt;/p&gt;
&lt;p&gt;예를 들자면 &lt;code&gt;tab-width&lt;/code&gt; 가 대표적이다. 이 변수는 들여쓰기의 크기를 설정하는 변수로 각 버퍼의 메이저 모드마다 이 변수의 값이 다 다를 수 있다. 버퍼에 속한 로컬 변수이기 때문이다. 하지만 기초 값으로 사용되는 전역 변수도 따로 있다.&lt;/p&gt;
&lt;p&gt;이 '버퍼 로컬 변수' 개념만 이해하고 있다면 둘의 차이는 쉽게 구분할 수 있다.&lt;/p&gt;
&lt;h2&gt;setq&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;setq&lt;/code&gt;명령어는 Set eQual의 약자로 다른 언어에선 대입(assign)과 비슷한 의미의 명령이다. 이 명령은 만약 로컬 변수가 있다면 해당 변수의 값을 지정하고, 로컬 변수가 없다면 전역 변수에 지정하는 방식으로 동작한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq tab-width 8)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드는 현재 버퍼의 들여쓰기 레벨을 8로 설정하는 명령이다. 하지만 다른 메이저모드 버퍼에는 적용되지 않는다. 왜냐하면 &lt;code&gt;tab-width&lt;/code&gt;는 앞서 이야기 했다시피 버퍼 로컬 변수라는 특수한 변수이기 때문이다.&lt;/p&gt;
&lt;h2&gt;setq-default&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;setq-default&lt;/code&gt;는 버퍼 로컬 변수를 생략하고 무조건 전역 변수의 값을 지정하는 용도로 사용된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq-default tab-width 8)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드는 현재 버퍼가 아니라 모든 버퍼에서 참고하는 기본 들여쓰기 레벨을 설정하는 코드다. 따라서 새롭게 만들어지는 버퍼는 모두 이 값을 참조하여 들여쓰기 레벨을 결정한다. 물론 이후 &lt;code&gt;setq&lt;/code&gt;로 해당 버퍼 로컬 변수의 값이 바뀔 수는 있겠지만 말이다.&lt;/p&gt;
&lt;h2&gt;사족&lt;/h2&gt;
&lt;p&gt;default라는 이름에 집중하면 왠지 조금은 더 이해가 잘 되는 것 같다. 즉 기본값(default value)을 설정하기 위한 용도로 &lt;code&gt;setq-default&lt;/code&gt;가 쓰이는 것 같다. 뭔가 대단한 일을 하는 함수 같다.&lt;/p&gt;
&lt;p&gt;그렇다고 해도 보통 Lisp 코딩에서는 &lt;code&gt;setq&lt;/code&gt;가 압도적으로 많이 쓰인다. 로컬 변수에서도 사용하니 당연하다. 오히려 &lt;code&gt;setq-default&lt;/code&gt;를 쓸 일은 그다지 많지 않을 수도 있다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;Emacs를 세팅하다 보면 생소한 느낌의 단어를 자주 사용하게 되는데 그 중에 &lt;code&gt;setq&lt;/code&gt;와 &lt;code&gt;setq-default&lt;/code&gt;의 차이에 대해 알아보자.&lt;/p&gt;
&lt;h2&gt;버퍼 로컬 변수 개념&lt;/h2&gt;
&lt;p&gt;Emacs에는 '버퍼 로컬(buffer-local) 변수'라는 특별한 개념이 있다. 마치 해당 버퍼에 종속되는 전역 변수와 비슷한 느낌으로 설명할 수 있다.&lt;/p&gt;
&lt;p&gt;예를 들자면 &lt;code&gt;tab-width&lt;/code&gt; 가 대표적이다. 이 변수는 들여쓰기의 크기를 설정하는 변수로 각 버퍼의 메이저 모드마다 이 변수의 값이 다 다를 수 있다. 버퍼에 속한 로컬 변수이기 때문이다. 하지만 기초 값으로 사용되는 전역 변수도 따로 있다.&lt;/p&gt;
&lt;p&gt;이 '버퍼 로컬 변수' 개념만 이해하고 있다면 둘의 차이는 쉽게 구분할 수 있다.&lt;/p&gt;
&lt;h2&gt;setq&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;setq&lt;/code&gt;명령어는 Set eQual의 약자로 다른 언어에선 대입(assign)과 비슷한 의미의 명령이다. 이 명령은 만약 로컬 변수가 있다면 해당 변수의 값을 지정하고, 로컬 변수가 없다면 전역 변수에 지정하는 방식으로 동작한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq tab-width 8)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드는 현재 버퍼의 들여쓰기 레벨을 8로 설정하는 명령이다. 하지만 다른 메이저모드 버퍼에는 적용되지 않는다. 왜냐하면 &lt;code&gt;tab-width&lt;/code&gt;는 앞서 이야기 했다시피 버퍼 로컬 변수라는 특수한 변수이기 때문이다.&lt;/p&gt;
&lt;h2&gt;setq-default&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;setq-default&lt;/code&gt;는 버퍼 로컬 변수를 생략하고 무조건 전역 변수의 값을 지정하는 용도로 사용된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(setq-default tab-width 8)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드는 현재 버퍼가 아니라 모든 버퍼에서 참고하는 기본 들여쓰기 레벨을 설정하는 코드다. 따라서 새롭게 만들어지는 버퍼는 모두 이 값을 참조하여 들여쓰기 레벨을 결정한다. 물론 이후 &lt;code&gt;setq&lt;/code&gt;로 해당 버퍼 로컬 변수의 값이 바뀔 수는 있겠지만 말이다.&lt;/p&gt;
&lt;h2&gt;사족&lt;/h2&gt;
&lt;p&gt;default라는 이름에 집중하면 왠지 조금은 더 이해가 잘 되는 것 같다. 즉 기본값(default value)을 설정하기 위한 용도로 &lt;code&gt;setq-default&lt;/code&gt;가 쓰이는 것 같다. 뭔가 대단한 일을 하는 함수 같다.&lt;/p&gt;
&lt;p&gt;그렇다고 해도 보통 Lisp 코딩에서는 &lt;code&gt;setq&lt;/code&gt;가 압도적으로 많이 쓰인다. 로컬 변수에서도 사용하니 당연하다. 오히려 &lt;code&gt;setq-default&lt;/code&gt;를 쓸 일은 그다지 많지 않을 수도 있다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/emacs-lisp-setq-default.html</guid>
      <pubDate>Sat, 22 Jun 2024 23:08:00 +0900</pubDate>
    </item>
    <item>
      <title>Python-Markdown으로 마크다운 문서의 모든 링크 주소 추출하기</title>
      <link>https://seorenn.github.io/article/python-markdown-extract-links.html</link>
      <description>&lt;p&gt;&lt;a href="../article/python-markdown.html"&gt;Python-Markdown&lt;/a&gt; 패키지를 이용해 마크다운 문서에서 모든 링크의 URL 주소를 추출하는 방법을 직접 확장을 만들어서 구현해 보자.&lt;/p&gt;
&lt;p&gt;여러 방법이 있을 거라 생각되지만 이번에는 트리프로세서(Treeprocessor) 확장을 구현하는 방식을 보자. 트리프로세서 방식은 마크다운 문서를 파싱해서 HTML로 출력하기 전에 XML 트리 형태로 구축한 데이터를 직접 건드리는 방식을 의미한다.&lt;/p&gt;
&lt;p&gt;두 개의 클래스 구현이 필요한데 하나는 &lt;code&gt;Extension&lt;/code&gt;을 상속한 확장 클래스, 다른 하나는 &lt;code&gt;Treeprocessor&lt;/code&gt;를 상속받은 실제로 일을 하는 클래스다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class _LinkExtractor(Treeprocessor):
    def run(self, root):
        self.md.links = []
        for link in root.findall(&amp;quot;.//a&amp;quot;):
            href = link.get(&amp;quot;href&amp;quot;)
            if href not in self.md.links:
                self.md.links.append(href)


class LinkExtractorExtension(Extension):
    def extendMarkdown(self, md):
        link_ext = _LinkExtractor(md)
        md.treeprocessors.register(link_ext, &amp;quot;link_ext&amp;quot;, 20)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;_LinkExtractor&lt;/code&gt;가 실제로 트리프로세서를 건드리는 클래스다. 여기서 &lt;code&gt;findall&lt;/code&gt;을 통해 트리에서 모든 &lt;code&gt;a&lt;/code&gt; 태그를 찾아서 &lt;code&gt;href&lt;/code&gt; 속성 즉 URL 텍스트를 추출해서 리스트로 정리하는 방식이다. 다만 패턴이 조금 특이할 수도 있는데 이 글에서 언급하긴 양이 많기에 직접 관련 레퍼런스 문서를 찾아보자.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LinkExtractorExtension&lt;/code&gt;은 &lt;code&gt;_LinkExtractor&lt;/code&gt;를 Python-Markdown 확장으로 감싸주는 역할의 클래스다. 참고로 설명을 보면 알 수 있겠지만 트리 프로세서에 등록(register)하는 부분에서 20이라는 숫자가 표기되어 있는데 이 숫자는 우선순위다. 자체적으로 개발하는 확장의 처리 순서를 고려해야 한다면 이 우선순위도 주의 깊게 설정해야 할 것이다. 다만 확장이 많지 않다면 별 의미 없는 숫자일 수도 있다.&lt;/p&gt;
&lt;p&gt;이렇게 만들어진 확장을 이용해 마크다운 문서를 HTML로 변환하면 &lt;code&gt;Markdown&lt;/code&gt; 인스턴스의 &lt;code&gt;links&lt;/code&gt; 프로퍼티에 원하는 내용이 들어가게 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;md = markdown.Markdown(extensions=[LinkExtractorExtension()])
html = md.convert(text)
print(f&amp;quot;links = {md.links})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;당연하겠지만 &lt;code&gt;links&lt;/code&gt; 프로퍼티에 들어있는 내용은 URL 주소들의 문자열 리스트다.&lt;/p&gt;
&lt;p&gt;이런 식으로 트리프로세서 확장을 이용하면 마크다운 문서를 HTML로 해석한 뒤의 특수한 처리를 어느 정도는 자유롭게 구현할 수 있다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;a href="../article/python-markdown.html"&gt;Python-Markdown&lt;/a&gt; 패키지를 이용해 마크다운 문서에서 모든 링크의 URL 주소를 추출하는 방법을 직접 확장을 만들어서 구현해 보자.&lt;/p&gt;
&lt;p&gt;여러 방법이 있을 거라 생각되지만 이번에는 트리프로세서(Treeprocessor) 확장을 구현하는 방식을 보자. 트리프로세서 방식은 마크다운 문서를 파싱해서 HTML로 출력하기 전에 XML 트리 형태로 구축한 데이터를 직접 건드리는 방식을 의미한다.&lt;/p&gt;
&lt;p&gt;두 개의 클래스 구현이 필요한데 하나는 &lt;code&gt;Extension&lt;/code&gt;을 상속한 확장 클래스, 다른 하나는 &lt;code&gt;Treeprocessor&lt;/code&gt;를 상속받은 실제로 일을 하는 클래스다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class _LinkExtractor(Treeprocessor):
    def run(self, root):
        self.md.links = []
        for link in root.findall(&amp;quot;.//a&amp;quot;):
            href = link.get(&amp;quot;href&amp;quot;)
            if href not in self.md.links:
                self.md.links.append(href)


class LinkExtractorExtension(Extension):
    def extendMarkdown(self, md):
        link_ext = _LinkExtractor(md)
        md.treeprocessors.register(link_ext, &amp;quot;link_ext&amp;quot;, 20)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;_LinkExtractor&lt;/code&gt;가 실제로 트리프로세서를 건드리는 클래스다. 여기서 &lt;code&gt;findall&lt;/code&gt;을 통해 트리에서 모든 &lt;code&gt;a&lt;/code&gt; 태그를 찾아서 &lt;code&gt;href&lt;/code&gt; 속성 즉 URL 텍스트를 추출해서 리스트로 정리하는 방식이다. 다만 패턴이 조금 특이할 수도 있는데 이 글에서 언급하긴 양이 많기에 직접 관련 레퍼런스 문서를 찾아보자.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LinkExtractorExtension&lt;/code&gt;은 &lt;code&gt;_LinkExtractor&lt;/code&gt;를 Python-Markdown 확장으로 감싸주는 역할의 클래스다. 참고로 설명을 보면 알 수 있겠지만 트리 프로세서에 등록(register)하는 부분에서 20이라는 숫자가 표기되어 있는데 이 숫자는 우선순위다. 자체적으로 개발하는 확장의 처리 순서를 고려해야 한다면 이 우선순위도 주의 깊게 설정해야 할 것이다. 다만 확장이 많지 않다면 별 의미 없는 숫자일 수도 있다.&lt;/p&gt;
&lt;p&gt;이렇게 만들어진 확장을 이용해 마크다운 문서를 HTML로 변환하면 &lt;code&gt;Markdown&lt;/code&gt; 인스턴스의 &lt;code&gt;links&lt;/code&gt; 프로퍼티에 원하는 내용이 들어가게 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;md = markdown.Markdown(extensions=[LinkExtractorExtension()])
html = md.convert(text)
print(f&amp;quot;links = {md.links})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;당연하겠지만 &lt;code&gt;links&lt;/code&gt; 프로퍼티에 들어있는 내용은 URL 주소들의 문자열 리스트다.&lt;/p&gt;
&lt;p&gt;이런 식으로 트리프로세서 확장을 이용하면 마크다운 문서를 HTML로 해석한 뒤의 특수한 처리를 어느 정도는 자유롭게 구현할 수 있다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-markdown-extract-links.html</guid>
      <pubDate>Fri, 21 Jun 2024 23:32:00 +0900</pubDate>
    </item>
    <item>
      <title>macOS 사파리에서 전체화면 영상이 깜빡이는 증상 고치기</title>
      <link>https://seorenn.github.io/article/macos-safari-fix-video-blinks.html</link>
      <description>&lt;p&gt;macOS 사파리에서 유튜브나 넷플릭스를 전체화면으로 볼 때 화면이 깜빡이는 증상을 고쳐보자. 참고로 macOS 14 Sonoma에서도 해당되는 것을 확인했다.&lt;/p&gt;
&lt;h2&gt;증상 설명&lt;/h2&gt;
&lt;p&gt;꽤 오래 전부터 macOS의 사파리에서 전체화면으로 영상을 틀 경우 깜빡임 증상이 나타났다. 유튜브와 넷플릭스 두 군데에서만 확인했지만 사실상 모든 영상 소스에서 증상이 발생할 것으로 보인다.&lt;/p&gt;
&lt;p&gt;깜빡임은 1초에 1~2회 정도 굉장히 짧게 나타나기 때문에 의식하지 않는다면 딱히 시청에 지장을 줄 수준은 아니다. 하지만 의식하기 시작하면 굉장히 신경쓰이고 껄끄로운 증상임은 분명했다.&lt;/p&gt;
&lt;p&gt;당연하겠지만 사파리에서만 증상이 발생하며 크롬이나 파이어폭스 등에서는 별 문제가 없었다. 그래서 기본 브라우저를 사파리 외의 것으로 바꾸는 주요 원인이었다.&lt;/p&gt;
&lt;p&gt;개인적으로는 구형 인텔 맥프로에서 증상이 나타났으나 애플실리콘 M 시리즈를 탑재한 최신 맥에서도 증상을 느끼는 유저가 있는 모양이다. 따라서 모든 맥 시리즈를 대상으로 발생할 수 있는 문제로 추측된다.&lt;/p&gt;
&lt;h2&gt;해결하기&lt;/h2&gt;
&lt;p&gt;이 문제를 겪기 시작한 것이 수 년 전으로 굉장히 오래 되었기에 자포자기 하고 있었는데 의외의 자료를 발견하여 그대로 따라해 보기로 했다. 방법은 아주 간단하다. 설정을 열어 아래 루트로 들어가는 것으로 시작한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;시스템 설정 - 손쉬운 사용 - 디스플레이&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기서 &lt;strong&gt;포인터(마우스 커서) 항목의 포인터 크기 슬라이더를 움직여서 최대로 키웠다가 다시 원하는 크기로 조절&lt;/strong&gt;해 보자.&lt;/p&gt;
&lt;p&gt;&lt;img alt="손쉬운 사용 - 디스플레이" src="../upload/202406150044-b2554065.png" /&gt;&lt;/p&gt;
&lt;p&gt;이후 사파리에서 문제가 재현되는지 확인해 보자. 개인적으론는 넷플릭스를 시청해 봤는데 정말 문제가 해결되었다. 상당히 충격적(?)이고 만족스러운 결과다.&lt;/p&gt;
&lt;p&gt;참고로 슬라이더를 움직이는 방향이 정해진 것은 아닌 것 같고 그저 마우스 커서 크기를 변경하는 행위가 영향을 끼치는 것이 아닐까 생각된다.&lt;/p&gt;
&lt;p&gt;그나저나 어째서 마우스 커서 크기 조절이 깜빡임과 연관이 있는 것일까? 참으로 신기한 일일 따름이지만, 어쨌든 사이드이펙트가 이렇게나 무서운(?) 일이라는 것도 다시금 깨닫게 된다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;macOS 사파리에서 유튜브나 넷플릭스를 전체화면으로 볼 때 화면이 깜빡이는 증상을 고쳐보자. 참고로 macOS 14 Sonoma에서도 해당되는 것을 확인했다.&lt;/p&gt;
&lt;h2&gt;증상 설명&lt;/h2&gt;
&lt;p&gt;꽤 오래 전부터 macOS의 사파리에서 전체화면으로 영상을 틀 경우 깜빡임 증상이 나타났다. 유튜브와 넷플릭스 두 군데에서만 확인했지만 사실상 모든 영상 소스에서 증상이 발생할 것으로 보인다.&lt;/p&gt;
&lt;p&gt;깜빡임은 1초에 1~2회 정도 굉장히 짧게 나타나기 때문에 의식하지 않는다면 딱히 시청에 지장을 줄 수준은 아니다. 하지만 의식하기 시작하면 굉장히 신경쓰이고 껄끄로운 증상임은 분명했다.&lt;/p&gt;
&lt;p&gt;당연하겠지만 사파리에서만 증상이 발생하며 크롬이나 파이어폭스 등에서는 별 문제가 없었다. 그래서 기본 브라우저를 사파리 외의 것으로 바꾸는 주요 원인이었다.&lt;/p&gt;
&lt;p&gt;개인적으로는 구형 인텔 맥프로에서 증상이 나타났으나 애플실리콘 M 시리즈를 탑재한 최신 맥에서도 증상을 느끼는 유저가 있는 모양이다. 따라서 모든 맥 시리즈를 대상으로 발생할 수 있는 문제로 추측된다.&lt;/p&gt;
&lt;h2&gt;해결하기&lt;/h2&gt;
&lt;p&gt;이 문제를 겪기 시작한 것이 수 년 전으로 굉장히 오래 되었기에 자포자기 하고 있었는데 의외의 자료를 발견하여 그대로 따라해 보기로 했다. 방법은 아주 간단하다. 설정을 열어 아래 루트로 들어가는 것으로 시작한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;시스템 설정 - 손쉬운 사용 - 디스플레이&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기서 &lt;strong&gt;포인터(마우스 커서) 항목의 포인터 크기 슬라이더를 움직여서 최대로 키웠다가 다시 원하는 크기로 조절&lt;/strong&gt;해 보자.&lt;/p&gt;
&lt;p&gt;&lt;img alt="손쉬운 사용 - 디스플레이" src="../upload/202406150044-b2554065.png" /&gt;&lt;/p&gt;
&lt;p&gt;이후 사파리에서 문제가 재현되는지 확인해 보자. 개인적으론는 넷플릭스를 시청해 봤는데 정말 문제가 해결되었다. 상당히 충격적(?)이고 만족스러운 결과다.&lt;/p&gt;
&lt;p&gt;참고로 슬라이더를 움직이는 방향이 정해진 것은 아닌 것 같고 그저 마우스 커서 크기를 변경하는 행위가 영향을 끼치는 것이 아닐까 생각된다.&lt;/p&gt;
&lt;p&gt;그나저나 어째서 마우스 커서 크기 조절이 깜빡임과 연관이 있는 것일까? 참으로 신기한 일일 따름이지만, 어쨌든 사이드이펙트가 이렇게나 무서운(?) 일이라는 것도 다시금 깨닫게 된다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/macos-safari-fix-video-blinks.html</guid>
      <pubDate>Thu, 20 Jun 2024 23:33:00 +0900</pubDate>
    </item>
    <item>
      <title>엔비디아 시총 1위 달성을 배아파하며</title>
      <link>https://seorenn.github.io/log/20240619-00.html</link>
      <description>&lt;p&gt;장 중 엔비디아가 마이크로소프트와 애플을 밟고 전 세계 시가총액 1위가 되었을 때 '정말 이런 일이 현실이 될까'하며 반신반의했는데 결국 종가 기준으로도 1위가 되면서 진짜 현실이 되어버렸다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;엔비디아의 시총 1위 달성을 축하...는 못 하겠고 배아프다. 가장 큰 문제는 내가 엔비디아가 없다니 훌쩍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;엔비디아의 주가가 오르면서 늘 주가가 폭등하던 종목에 따라붙던 '버블'이라는 단어가 계속 보인다. 그런데 버블? 거품이야 터져도 그냥 "뿅" 하고 귀여운 소리를 내며 터질 것이다. 주식 종목에서 버블이 터지면 많은 이들이 돈을 잃을 테지만 그래도 참 귀여운 느낌의 단어다.&lt;/p&gt;
&lt;p&gt;이제 버블이라는 단어를 써도 되는 시기는 지나지 않았을까? 개인적으로는 '폭탄'이 적절하다고 본다. 안에 TNT를 계속 채울 수 있는 버블폭탄이다. 그리고 폭탄이 점점 커진다. 터지면 주변을 날려버리는 폭탄이 점점 더 커지고 있다. 터지는 소리는 상상도 하기 싫을 거다.&lt;/p&gt;
&lt;p&gt;아무리 매출이 실제로 좋다 한들 도대체 몇 년 치 매출을 미리 다 끌어다 써버리는 건지 이해가 안 될 뿐이다.&lt;/p&gt;
&lt;p&gt;어쨌든 엔비디아가 없는 사람은 터지든 말든 속편한 세상이 될 리는 없잖아! 엔비디아가 이끌던 AI 섹터 전체가 그 폭탄에 휩쓸릴 게 뻔하니 말이다. 애플과 마이크로소프트는 물론 나스닥 전체가 무너질 지도 모르는 일이니 말이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;결론: 언제든 팔 준비는 하고 살아야 할 듯하다.&lt;/p&gt;
&lt;/blockquote&gt;</description>
      <content:encoded>&lt;p&gt;장 중 엔비디아가 마이크로소프트와 애플을 밟고 전 세계 시가총액 1위가 되었을 때 '정말 이런 일이 현실이 될까'하며 반신반의했는데 결국 종가 기준으로도 1위가 되면서 진짜 현실이 되어버렸다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;엔비디아의 시총 1위 달성을 축하...는 못 하겠고 배아프다. 가장 큰 문제는 내가 엔비디아가 없다니 훌쩍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;엔비디아의 주가가 오르면서 늘 주가가 폭등하던 종목에 따라붙던 '버블'이라는 단어가 계속 보인다. 그런데 버블? 거품이야 터져도 그냥 "뿅" 하고 귀여운 소리를 내며 터질 것이다. 주식 종목에서 버블이 터지면 많은 이들이 돈을 잃을 테지만 그래도 참 귀여운 느낌의 단어다.&lt;/p&gt;
&lt;p&gt;이제 버블이라는 단어를 써도 되는 시기는 지나지 않았을까? 개인적으로는 '폭탄'이 적절하다고 본다. 안에 TNT를 계속 채울 수 있는 버블폭탄이다. 그리고 폭탄이 점점 커진다. 터지면 주변을 날려버리는 폭탄이 점점 더 커지고 있다. 터지는 소리는 상상도 하기 싫을 거다.&lt;/p&gt;
&lt;p&gt;아무리 매출이 실제로 좋다 한들 도대체 몇 년 치 매출을 미리 다 끌어다 써버리는 건지 이해가 안 될 뿐이다.&lt;/p&gt;
&lt;p&gt;어쨌든 엔비디아가 없는 사람은 터지든 말든 속편한 세상이 될 리는 없잖아! 엔비디아가 이끌던 AI 섹터 전체가 그 폭탄에 휩쓸릴 게 뻔하니 말이다. 애플과 마이크로소프트는 물론 나스닥 전체가 무너질 지도 모르는 일이니 말이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;결론: 언제든 팔 준비는 하고 살아야 할 듯하다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240619-00.html</guid>
      <pubDate>Wed, 19 Jun 2024 16:10:00 +0900</pubDate>
    </item>
    <item>
      <title>라인 강탈 사건, 결국 한국 정부는 구경만 하다 끝날 듯</title>
      <link>https://seorenn.github.io/log/20240618-00.html</link>
      <description>&lt;blockquote&gt;
&lt;p&gt;라인야후가 정기 주주총회에서 '탈네이버' 방침을 재확인했다. 연내 네이버 클라우드와 시스템 분리를 완료하고, 자회사는 당초계획인 2026년보다 앞당겨 시스템을 분리한다. (&lt;a href="https://www.etnews.com/20240618000282" target="_blank"&gt;출처📎&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;언제는 한일정부 양측에서 입을 맞추어 "지분 매각 명령이 아니라 그냥 행정지도"라더니 이게 도대체 무엇일까? 한국 정부는 도대체 뭐 하는 곳일까? 외교 분야에서 아무리 일본이나 미국과의 관계 개선이 우선시 된다 해도 자국 기업의 피해를 구경만 하고 있는 행위는 좋게 봐줄 수가 없다.&lt;/p&gt;
&lt;p&gt;이제 정말 얼마 안 남았다. 일본 정부의 라인 강탈 완료까지 말이다. 그리고 네이버는 동남아 시장에의 영향력을 강탈당한다.&lt;/p&gt;
&lt;p&gt;국가가 해야 할 가장 중요한 일이 도대체 무엇일까? 아무리 생각해도 라인 강탈을 막는 게 일본과의 관계 개선보다 더 중요하고 시급한 일인데 이해가 안 된다. 그런데 오히려 한국 정부의 태도를 보면 국민들 모르게 그냥 조용히 끝나기만을 기다리는 것 같다.&lt;/p&gt;
&lt;p&gt;어쨌든 그렇다면 네이버에게 남는 국제적인 사업은 이제 웹툰 뿐인 것일까? 대한민국 최고의 IT 기업이?&lt;/p&gt;
&lt;p&gt;기왕 이렇게 된 거 매각 대금이라도 좀 크게 뜯어내지 않으면 당사자가 아님에도 정말 기분 더러울 것 같다.&lt;/p&gt;</description>
      <content:encoded>&lt;blockquote&gt;
&lt;p&gt;라인야후가 정기 주주총회에서 '탈네이버' 방침을 재확인했다. 연내 네이버 클라우드와 시스템 분리를 완료하고, 자회사는 당초계획인 2026년보다 앞당겨 시스템을 분리한다. (&lt;a href="https://www.etnews.com/20240618000282" target="_blank"&gt;출처📎&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;언제는 한일정부 양측에서 입을 맞추어 "지분 매각 명령이 아니라 그냥 행정지도"라더니 이게 도대체 무엇일까? 한국 정부는 도대체 뭐 하는 곳일까? 외교 분야에서 아무리 일본이나 미국과의 관계 개선이 우선시 된다 해도 자국 기업의 피해를 구경만 하고 있는 행위는 좋게 봐줄 수가 없다.&lt;/p&gt;
&lt;p&gt;이제 정말 얼마 안 남았다. 일본 정부의 라인 강탈 완료까지 말이다. 그리고 네이버는 동남아 시장에의 영향력을 강탈당한다.&lt;/p&gt;
&lt;p&gt;국가가 해야 할 가장 중요한 일이 도대체 무엇일까? 아무리 생각해도 라인 강탈을 막는 게 일본과의 관계 개선보다 더 중요하고 시급한 일인데 이해가 안 된다. 그런데 오히려 한국 정부의 태도를 보면 국민들 모르게 그냥 조용히 끝나기만을 기다리는 것 같다.&lt;/p&gt;
&lt;p&gt;어쨌든 그렇다면 네이버에게 남는 국제적인 사업은 이제 웹툰 뿐인 것일까? 대한민국 최고의 IT 기업이?&lt;/p&gt;
&lt;p&gt;기왕 이렇게 된 거 매각 대금이라도 좀 크게 뜯어내지 않으면 당사자가 아님에도 정말 기분 더러울 것 같다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240618-00.html</guid>
      <pubDate>Tue, 18 Jun 2024 16:00:00 +0900</pubDate>
    </item>
    <item>
      <title>참으로 오랜만에 토스에 실망했다</title>
      <link>https://seorenn.github.io/log/20240617-00.html</link>
      <description>&lt;p&gt;&lt;img alt="토스증권은 사파리를 지원하지 않는댄다" src="../upload/202406171431-82d78ad2.png" /&gt;&lt;/p&gt;
&lt;p&gt;토스증권은 사파리를 지원하지 않는댄다. 허탈하다. 실망스럽다.&lt;/p&gt;
&lt;p&gt;프라이버시를 제1의 가치로 내걸고 있는 애플의 행보를 생각해보면 토스 측의 대응은 좀 이해하기 어렵다. 가장 안전하게 사용하기 위해 크로미움 기반의 브라우저를 써야 한다라니 납득하기 어렵다. 크로미움에 얼마나 위험한 확장이 난립하고 있는지 생각해 보면 말도 안 되는 말이다.&lt;/p&gt;
&lt;p&gt;오픈소스로 개발되는 브라우저라서 더 안전할 수도 있다는 말도 논리적으로 맞지는 않다. 애초에 애플의 사파리 브라우징 엔진인 웹킷(WebKit)도 오픈소스로 개발되고 있고 지금은 그저 사파리에서만 주로 사용되고 있다는 점이 다를 뿐이다. 거기다 사파리는 확장도 감시가 심한 편이라 위험한 확장은 사실상 없다고 봐도 된다.&lt;/p&gt;
&lt;p&gt;그럼에도 토스증권은 어째서 사파리를 지원하지 않는 것일까?&lt;/p&gt;
&lt;p&gt;개인적으로 생각하기엔 사파리의 느린 속도의 HTML5 지원이 문제지 않을까 싶기도 하다. 하지만 토스 모바일이 애초에 웹뷰 기반에서 동작하는 것을 보면 굳이 사파리에서 못 돌릴 스펙적인 이슈가 있을까 싶기는 하다. 물론 모바일 앱과는 다르긴 하니 분리해서 생각하는 게 맞을 거다. &lt;/p&gt;
&lt;p&gt;무슨 사유가 있든 사파리를 배제한다면 그건 차별이다. 그리고 브라우저를 차별한다는 것은 토스 측의 명백한 잘못이고 명백한 실수다. 토스 측의 현명한 대처가 있기를 바랄 뿐이다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;img alt="토스증권은 사파리를 지원하지 않는댄다" src="../upload/202406171431-82d78ad2.png" /&gt;&lt;/p&gt;
&lt;p&gt;토스증권은 사파리를 지원하지 않는댄다. 허탈하다. 실망스럽다.&lt;/p&gt;
&lt;p&gt;프라이버시를 제1의 가치로 내걸고 있는 애플의 행보를 생각해보면 토스 측의 대응은 좀 이해하기 어렵다. 가장 안전하게 사용하기 위해 크로미움 기반의 브라우저를 써야 한다라니 납득하기 어렵다. 크로미움에 얼마나 위험한 확장이 난립하고 있는지 생각해 보면 말도 안 되는 말이다.&lt;/p&gt;
&lt;p&gt;오픈소스로 개발되는 브라우저라서 더 안전할 수도 있다는 말도 논리적으로 맞지는 않다. 애초에 애플의 사파리 브라우징 엔진인 웹킷(WebKit)도 오픈소스로 개발되고 있고 지금은 그저 사파리에서만 주로 사용되고 있다는 점이 다를 뿐이다. 거기다 사파리는 확장도 감시가 심한 편이라 위험한 확장은 사실상 없다고 봐도 된다.&lt;/p&gt;
&lt;p&gt;그럼에도 토스증권은 어째서 사파리를 지원하지 않는 것일까?&lt;/p&gt;
&lt;p&gt;개인적으로 생각하기엔 사파리의 느린 속도의 HTML5 지원이 문제지 않을까 싶기도 하다. 하지만 토스 모바일이 애초에 웹뷰 기반에서 동작하는 것을 보면 굳이 사파리에서 못 돌릴 스펙적인 이슈가 있을까 싶기는 하다. 물론 모바일 앱과는 다르긴 하니 분리해서 생각하는 게 맞을 거다. &lt;/p&gt;
&lt;p&gt;무슨 사유가 있든 사파리를 배제한다면 그건 차별이다. 그리고 브라우저를 차별한다는 것은 토스 측의 명백한 잘못이고 명백한 실수다. 토스 측의 현명한 대처가 있기를 바랄 뿐이다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240617-00.html</guid>
      <pubDate>Mon, 17 Jun 2024 14:41:00 +0900</pubDate>
    </item>
    <item>
      <title>자동차 종류 축약어 정리</title>
      <link>https://seorenn.github.io/article/vehicle-abbrev.html</link>
      <description>&lt;p&gt;자동차 축약어로 쓰이는 ICE, EV, HEV, MHEV, PHEV, BEV, FCEV 등의 용어의 의미를 정리해 보자.&lt;/p&gt;
&lt;h2&gt;ICE: Internal Combustion Engine&lt;/h2&gt;
&lt;p&gt;용어 자체는 "석유 등의 화석연료를 태워서 회전운동을 얻는 내연기관 엔진"을 의미하지만 자동차 분류에서는 지금까지 가장 흔하게 볼 수 있는 '&lt;strong&gt;동력원으로 내연기관을 사용하는 차량&lt;/strong&gt;'의 의미로 사용하기도 한다. 아마도 차량으로 칭하려면 ICEV로 불러야 할 것 같지만 이러면 또 EV라는 중첩되는 반대 의미의 축약어가 붙는 것 같아서 그냥 ICE로 칭하는 걸지도 모르겠다. 특징으로 자주 사용되지는 않는 것 같다.&lt;/p&gt;
&lt;h2&gt;EV: Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;전기자동차를 포함하는 '&lt;strong&gt;동력원으로 전기 모터를 사용하는 차량&lt;/strong&gt;'을 통칭하는 의미다. 다만 이 축약어에서는 전기 공급원을 정의하지는 않고 있어서 광범위한 종류의 전기 모터를 탑재하는 자동차를 의미하는 용도로 쓰인다. 참고로 일반적으로 판매되는 순수 전기자동차는 BEV라 부른다. 트렌드 상 ICE와는 상대되는 의미로도 볼 수 있다.&lt;/p&gt;
&lt;p&gt;요즘은 느슨하게 BEV를 그냥 EV라고 부르는 경우도 많은 듯하다. 어딘가에선 전기자동차 브랜드 이름으로 사용하고 있기도 하고 말이다.&lt;/p&gt;
&lt;h2&gt;HEV: Hybrid Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;보통 &lt;strong&gt;하이브리드&lt;/strong&gt;라 부르는 차량으로 내연기관과 전기 모터를 동시에 사용하는 형태의 모든 차량을 의미한다. 구조나 부품 등에 따라 여러 세부 분류가 나눠지지만 MHEV를 제외하고는 구동용 전기모터를 별도로 탑재해서 저출력 시 모터를 쓰고 고출력이 필요할 때 내연기관엔진을 함께 이용하는 형식으로 볼 수 있다. 차량 내부에서 회생제동이나 내장 발전기를 이용해 배터리를 충전하는 방식이며 구조에 따라 내연기관을 충전용으로만 쓰거나 구동용으로도 쓰는 등의 차이가 있을 수 있다.&lt;/p&gt;
&lt;p&gt;최근에는 일반 전기차에 수소연료전지까지 쓸 수 있는 하이브리드 형태도 등장하고 있으니 하이브리드 차량이라도 정확한 동력원이 무엇인지는 파악을 잘해야 할 것 같다.&lt;/p&gt;
&lt;p&gt;충전 방식이나 동력 배분 구조, 회생제동 및 발전기 구조에 따라 직렬혈 혹은 병렬형 두 가지 카테고리로 구분하기도 한다.&lt;/p&gt;
&lt;h2&gt;MHEV: Mild Hybrid Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;시동용 모터를 구동 보조로 사용하는 형태의 '&lt;strong&gt;마일드 하이브리드&lt;/strong&gt;'라 불리는 HEV의 한 종류다. 구조 상 HEV와 비슷한 형태로 볼 수도 있지만 설계상 내연기관차량과 거의 동일하며 그래서 아예 하이브리드 차량이라고 표현하지 않는 경우도 많다.&lt;/p&gt;
&lt;h2&gt;PHEV: Plug-in Hybrid Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;보통 '&lt;strong&gt;플러그인 하이브리드&lt;/strong&gt;'라 불리며 순수 전기차 구조와 내연기관차의 형태가 합쳐진 HEV 차량이다. HEV와 비슷해 보이지만 충전 플러그를 이용해 배터리를 외부로부터 직접 충전해서 모터 만으로도 달릴 수도 있고 내연기관을 함께 혹은 독자적으로 이용해 달릴 수도 있다는 차이가 있다. 배터리 충전만 잘한다면 순수 전기차와 거의 동급으로 볼 수는 있으나 배터리 용량이 전기차에 비해 상대적으로 적어서 현실적으로는 하이브리드로 볼 수밖에 없다. 하지만 하이브리드 중에선 배터리 용량이 가장 큰 편으로 볼 수 있다. 덕분에 차량 가격도 하이브리드 중에선 비싼 편이다.&lt;/p&gt;
&lt;h2&gt;BEV: Battery Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;대용량 배터리가 탑재된 전기자동차다. 일반적으로 &lt;strong&gt;순수 전기자동차&lt;/strong&gt;를 칭하는 축약어가 바로 이 BEV다. 당연하지만 화석연료를 사용하는 내연기관엔진을 탑재하지 않고 전기 모터만 동력원으로 탑재한다. 내연기관 차량만큼 복잡한 설계가 필요하지 않고 덕분에 내구성도 좋고 전기 모터의 미세 컨트롤 특성을 이용할 수 있는 큰 장점이 있지만, 배터리가 비싸고 무겁고 상대적으로 충전에 시간이 많이 든다는 단점이 있다. 다만 배터리 가격은 점점 저렴해지고 있어서 큰 문제는 아니게 될 것 같다.&lt;/p&gt;
&lt;h2&gt;FCEV: Fuel Cell Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;연료전지 자동차&lt;/strong&gt;를 의미한다. 현실적으로는 상용화된 수소연료전지 자동차, 축약해서 수소자동차를 의미한다고 볼 수 있다. 일반 전기차와 구조적으로 동일하지만 배터리 대신 수소연료전지가 탑재된다는 점만 다르다. 따라서 배터리의 가격이나 무게, 충전 시간 등의 단점을 획기적으로 개선하는 것도 가능하지만, 수소는 가연성 물질로 일반적으로 위험한 물질로 인식되는 터라 차량이나 충전소를 꺼리는 경향도 있다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;자동차 축약어로 쓰이는 ICE, EV, HEV, MHEV, PHEV, BEV, FCEV 등의 용어의 의미를 정리해 보자.&lt;/p&gt;
&lt;h2&gt;ICE: Internal Combustion Engine&lt;/h2&gt;
&lt;p&gt;용어 자체는 "석유 등의 화석연료를 태워서 회전운동을 얻는 내연기관 엔진"을 의미하지만 자동차 분류에서는 지금까지 가장 흔하게 볼 수 있는 '&lt;strong&gt;동력원으로 내연기관을 사용하는 차량&lt;/strong&gt;'의 의미로 사용하기도 한다. 아마도 차량으로 칭하려면 ICEV로 불러야 할 것 같지만 이러면 또 EV라는 중첩되는 반대 의미의 축약어가 붙는 것 같아서 그냥 ICE로 칭하는 걸지도 모르겠다. 특징으로 자주 사용되지는 않는 것 같다.&lt;/p&gt;
&lt;h2&gt;EV: Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;전기자동차를 포함하는 '&lt;strong&gt;동력원으로 전기 모터를 사용하는 차량&lt;/strong&gt;'을 통칭하는 의미다. 다만 이 축약어에서는 전기 공급원을 정의하지는 않고 있어서 광범위한 종류의 전기 모터를 탑재하는 자동차를 의미하는 용도로 쓰인다. 참고로 일반적으로 판매되는 순수 전기자동차는 BEV라 부른다. 트렌드 상 ICE와는 상대되는 의미로도 볼 수 있다.&lt;/p&gt;
&lt;p&gt;요즘은 느슨하게 BEV를 그냥 EV라고 부르는 경우도 많은 듯하다. 어딘가에선 전기자동차 브랜드 이름으로 사용하고 있기도 하고 말이다.&lt;/p&gt;
&lt;h2&gt;HEV: Hybrid Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;보통 &lt;strong&gt;하이브리드&lt;/strong&gt;라 부르는 차량으로 내연기관과 전기 모터를 동시에 사용하는 형태의 모든 차량을 의미한다. 구조나 부품 등에 따라 여러 세부 분류가 나눠지지만 MHEV를 제외하고는 구동용 전기모터를 별도로 탑재해서 저출력 시 모터를 쓰고 고출력이 필요할 때 내연기관엔진을 함께 이용하는 형식으로 볼 수 있다. 차량 내부에서 회생제동이나 내장 발전기를 이용해 배터리를 충전하는 방식이며 구조에 따라 내연기관을 충전용으로만 쓰거나 구동용으로도 쓰는 등의 차이가 있을 수 있다.&lt;/p&gt;
&lt;p&gt;최근에는 일반 전기차에 수소연료전지까지 쓸 수 있는 하이브리드 형태도 등장하고 있으니 하이브리드 차량이라도 정확한 동력원이 무엇인지는 파악을 잘해야 할 것 같다.&lt;/p&gt;
&lt;p&gt;충전 방식이나 동력 배분 구조, 회생제동 및 발전기 구조에 따라 직렬혈 혹은 병렬형 두 가지 카테고리로 구분하기도 한다.&lt;/p&gt;
&lt;h2&gt;MHEV: Mild Hybrid Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;시동용 모터를 구동 보조로 사용하는 형태의 '&lt;strong&gt;마일드 하이브리드&lt;/strong&gt;'라 불리는 HEV의 한 종류다. 구조 상 HEV와 비슷한 형태로 볼 수도 있지만 설계상 내연기관차량과 거의 동일하며 그래서 아예 하이브리드 차량이라고 표현하지 않는 경우도 많다.&lt;/p&gt;
&lt;h2&gt;PHEV: Plug-in Hybrid Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;보통 '&lt;strong&gt;플러그인 하이브리드&lt;/strong&gt;'라 불리며 순수 전기차 구조와 내연기관차의 형태가 합쳐진 HEV 차량이다. HEV와 비슷해 보이지만 충전 플러그를 이용해 배터리를 외부로부터 직접 충전해서 모터 만으로도 달릴 수도 있고 내연기관을 함께 혹은 독자적으로 이용해 달릴 수도 있다는 차이가 있다. 배터리 충전만 잘한다면 순수 전기차와 거의 동급으로 볼 수는 있으나 배터리 용량이 전기차에 비해 상대적으로 적어서 현실적으로는 하이브리드로 볼 수밖에 없다. 하지만 하이브리드 중에선 배터리 용량이 가장 큰 편으로 볼 수 있다. 덕분에 차량 가격도 하이브리드 중에선 비싼 편이다.&lt;/p&gt;
&lt;h2&gt;BEV: Battery Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;대용량 배터리가 탑재된 전기자동차다. 일반적으로 &lt;strong&gt;순수 전기자동차&lt;/strong&gt;를 칭하는 축약어가 바로 이 BEV다. 당연하지만 화석연료를 사용하는 내연기관엔진을 탑재하지 않고 전기 모터만 동력원으로 탑재한다. 내연기관 차량만큼 복잡한 설계가 필요하지 않고 덕분에 내구성도 좋고 전기 모터의 미세 컨트롤 특성을 이용할 수 있는 큰 장점이 있지만, 배터리가 비싸고 무겁고 상대적으로 충전에 시간이 많이 든다는 단점이 있다. 다만 배터리 가격은 점점 저렴해지고 있어서 큰 문제는 아니게 될 것 같다.&lt;/p&gt;
&lt;h2&gt;FCEV: Fuel Cell Electronic Vehicle&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;연료전지 자동차&lt;/strong&gt;를 의미한다. 현실적으로는 상용화된 수소연료전지 자동차, 축약해서 수소자동차를 의미한다고 볼 수 있다. 일반 전기차와 구조적으로 동일하지만 배터리 대신 수소연료전지가 탑재된다는 점만 다르다. 따라서 배터리의 가격이나 무게, 충전 시간 등의 단점을 획기적으로 개선하는 것도 가능하지만, 수소는 가연성 물질로 일반적으로 위험한 물질로 인식되는 터라 차량이나 충전소를 꺼리는 경향도 있다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/vehicle-abbrev.html</guid>
      <pubDate>Mon, 17 Jun 2024 11:16:00 +0900</pubDate>
    </item>
    <item>
      <title>WWDC로 뜨거웠던 한 주간의 애플 소식 모음 24-06-16</title>
      <link>https://seorenn.github.io/log/20240616-00.html</link>
      <description>&lt;h2&gt;WWDC24&lt;/h2&gt;
&lt;p&gt;애플은 WWDC24를 통해 macOS 15, iOS 18 등의 차기 OS 메이저 업데이트와 Apple Intelligence 기능 들을 발표했다. 시장의 평가는 무난한 듯하면서도 조금은 차가운 듯했지만 다음날 애플의 주가는 사상최고가를 갱신하며 전날의 하락을 완전히 덮어버렸다.&lt;/p&gt;
&lt;p&gt;관련된 내용은 &lt;a href="../log/20240611-00.html"&gt;애플 WWDC24 간단 정리 및 감상&lt;/a&gt; 글을 참고하자.&lt;/p&gt;
&lt;h2&gt;소프트웨어 안정 버전 릴리즈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;visionOS 1.2: 페르소나, 아이사이트, 가상 키보드 등 개선&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;소프트웨어 개발자 베타 릴리즈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15 beta&lt;/li&gt;
&lt;li&gt;iOS 18 beta&lt;/li&gt;
&lt;li&gt;iPadOS 18 beta&lt;/li&gt;
&lt;li&gt;visionOS 2 beta&lt;/li&gt;
&lt;li&gt;tvOS 18 beta&lt;/li&gt;
&lt;li&gt;watchOS 11 beta&lt;/li&gt;
&lt;li&gt;Xcode 16 beta&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;개발자 베타를 설치하려면 애플 개발자 프로그램에 가입된 계정이 필요하다. 메이저 업데이트의 첫 베타인 만큼 꼭 필요한 경우가 아니면 설치하지 않는 편이 좋을 것 같다.&lt;/p&gt;
&lt;h2&gt;하드웨어 펌웨어 베타 릴리즈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AirPods Pro 2 Beta (7A5220e)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;차기 메이저 업데이트 설치 가능 하드웨어 (루머)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15: 14 버전 설치가 가능했던 모든 맥에 설치가 가능할 것으로 추정된다. 다만 AI 기능은 M 시리즈가 탑재된 맥만 사용 가능하다.&lt;/li&gt;
&lt;li&gt;iOS 18: 아이폰 XS/XS Max/XR 및 이후 출시된 모든 아이폰에서 설치가 가능할 것으로 추정된다. 다만 AI 기능은 A17 Pro가 탑재된 아이폰 15 프로 및 이후 출시된 아이폰만 사용 가능하다.&lt;/li&gt;
&lt;li&gt;iPadOS 18: 아이패드 프로는 2018년 출시 및 이후 모델부터, 아이패드 7세대(2019) 및 이후, 아이패드 미니 5세대(2019) 및 이후, 아이패드 에어 3세대(2019) 및 이후 출시된 제품에서 설치가 가능할 것으로 추정된다. 다만 AI 기능은 M 시리즈가 탑재된 아이패드만 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;WWDC24를 넘어&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;iOS 18: 새 홈 스크린은 앱의 이름을 가릴 수 있으며 이 경우 아이콘이 좀 더 조밀하게 배치되는 듯하다. 메모 앱에는 다양한 스타일링과 구조화 기능이 추가되었다. 설정의 배터리 항목에서는 저속 충전 구간 표시가 추가된 모양이다. 손전등 기능의 인터페이스도 바뀌고, 써드파티 카메라도 잠금화면이나 컨트롤센터에서 바로 사용할 수도 있고, 액션 버튼이 컨트롤센터 등과 유기적으로 연결되고, 아이폰이 죽거나 방전되어도 시간이 계속 표시되는 등 여러 업데이트가 발견되고 있다. 시리는 아예 잠겨있을 때도 동작할 수 있는 트리거를 추가하는 모양이다. 베타 배포 도구인 Testflight 앱도 새롭게 디자인 되는 듯하다.&lt;/li&gt;
&lt;li&gt;macOS 15 Sequoia: 내장된 체스 게임의 그래픽이 업데이트 된다.&lt;/li&gt;
&lt;li&gt;watchOS 11: 새로운 번역 앱이 추가된 모양이다.&lt;/li&gt;
&lt;li&gt;Apple Intelligence: 미국에서는 애플지능 베타 사전 신청을 받는 모양이다.&lt;/li&gt;
&lt;li&gt;OpenAI와 애플의 협업에 관한 보고서를 통해 양측은 서로 비용을 지불하지 않는다고 전해지고 있다. 놀라운 딜이 있는 모양이다.&lt;/li&gt;
&lt;li&gt;당연하겠지만 인텔 맥에서는 애플지능과 실시간 음성 타이핑 기능을 쓸 수 없을 전망이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;OS 사용자 전환율 공개&lt;/h2&gt;
&lt;p&gt;애플은 WWDC를 앞두고 OS 전환율을 공개했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아이폰 사용자의 77%가 iOS 17로 업그레이드 했다. 지난 4년 동안 출시된 아이폰은 86%가 업그레이드 했다.&lt;/li&gt;
&lt;li&gt;아이패드 사용자의 68%가 iPadOS 17로 업그레이드 했다. 지난 4년 동안 출시된 아이패드는 77%가 업그레이드 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;낮은 수치는 절대 아니지만 16 버전대에 비하면 느린 결과다. 이 외의 사용자들은 업그레이드에 관심이 없거나 업그레이드가 안 되는 구형 디바이스를 사용 중으로 볼 수도 있다.&lt;/p&gt;
&lt;h2&gt;기타 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;애플이 앱스토어와 대체 앱스토어에서 PC 에뮬레이터 앱을 차단했다. 애플은 PC는 콘솔이 아니기 때문에 에뮬레이터가 허용되지 않는다는 지침을 밝혔다. 하지만 사유로 밝힌 가이드라인에서도 그 이유가 명확하지 않은 듯하다.&lt;/li&gt;
&lt;li&gt;루머 대로 '애플아이디(Apple ID)' 브랜딩이 '애플계정(Apple Account)'으로 바뀐다고 애플이 공식적으로 밝혔다.&lt;/li&gt;
&lt;li&gt;한국에서 애플이 동의 없이 사용자의 위치 정보를 수집한 혐의로 규제 당국에 의해 약 2억 천 만원의 벌금을 부과 받았다고 한다.&lt;/li&gt;
&lt;li&gt;예고된 대로 일본에서 대체 앱스토어와 써드파티 결제 허용을 강제하는 법이 통과되었다. 당연히 애플의 일본 사업에 영향을 미칠 것 같다.&lt;/li&gt;
&lt;li&gt;EU는 DMA 준수가 부족하다는 이유로 애플에 벌금을 부과할 예정이라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;기타 루머 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;미래에 출시될 7.9인치 폴더블 아이폰은 랩 어라운드 디자인을 가질 것이라 추정되는데 화웨이의 폴더블 폰 디자인과 비슷하다는 주장을 외에는 정확히 어떤 디자인인지는 명확하진 않다. &lt;/li&gt;
&lt;li&gt;아이패드 프로의 사례에 이어 애플은 아이폰, 맥북프로, 애플워치 등도 얇게 재디자인 할 것이라는 소문이 돈다.&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;h2&gt;WWDC24&lt;/h2&gt;
&lt;p&gt;애플은 WWDC24를 통해 macOS 15, iOS 18 등의 차기 OS 메이저 업데이트와 Apple Intelligence 기능 들을 발표했다. 시장의 평가는 무난한 듯하면서도 조금은 차가운 듯했지만 다음날 애플의 주가는 사상최고가를 갱신하며 전날의 하락을 완전히 덮어버렸다.&lt;/p&gt;
&lt;p&gt;관련된 내용은 &lt;a href="../log/20240611-00.html"&gt;애플 WWDC24 간단 정리 및 감상&lt;/a&gt; 글을 참고하자.&lt;/p&gt;
&lt;h2&gt;소프트웨어 안정 버전 릴리즈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;visionOS 1.2: 페르소나, 아이사이트, 가상 키보드 등 개선&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;소프트웨어 개발자 베타 릴리즈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15 beta&lt;/li&gt;
&lt;li&gt;iOS 18 beta&lt;/li&gt;
&lt;li&gt;iPadOS 18 beta&lt;/li&gt;
&lt;li&gt;visionOS 2 beta&lt;/li&gt;
&lt;li&gt;tvOS 18 beta&lt;/li&gt;
&lt;li&gt;watchOS 11 beta&lt;/li&gt;
&lt;li&gt;Xcode 16 beta&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;개발자 베타를 설치하려면 애플 개발자 프로그램에 가입된 계정이 필요하다. 메이저 업데이트의 첫 베타인 만큼 꼭 필요한 경우가 아니면 설치하지 않는 편이 좋을 것 같다.&lt;/p&gt;
&lt;h2&gt;하드웨어 펌웨어 베타 릴리즈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AirPods Pro 2 Beta (7A5220e)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;차기 메이저 업데이트 설치 가능 하드웨어 (루머)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS 15: 14 버전 설치가 가능했던 모든 맥에 설치가 가능할 것으로 추정된다. 다만 AI 기능은 M 시리즈가 탑재된 맥만 사용 가능하다.&lt;/li&gt;
&lt;li&gt;iOS 18: 아이폰 XS/XS Max/XR 및 이후 출시된 모든 아이폰에서 설치가 가능할 것으로 추정된다. 다만 AI 기능은 A17 Pro가 탑재된 아이폰 15 프로 및 이후 출시된 아이폰만 사용 가능하다.&lt;/li&gt;
&lt;li&gt;iPadOS 18: 아이패드 프로는 2018년 출시 및 이후 모델부터, 아이패드 7세대(2019) 및 이후, 아이패드 미니 5세대(2019) 및 이후, 아이패드 에어 3세대(2019) 및 이후 출시된 제품에서 설치가 가능할 것으로 추정된다. 다만 AI 기능은 M 시리즈가 탑재된 아이패드만 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;WWDC24를 넘어&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;iOS 18: 새 홈 스크린은 앱의 이름을 가릴 수 있으며 이 경우 아이콘이 좀 더 조밀하게 배치되는 듯하다. 메모 앱에는 다양한 스타일링과 구조화 기능이 추가되었다. 설정의 배터리 항목에서는 저속 충전 구간 표시가 추가된 모양이다. 손전등 기능의 인터페이스도 바뀌고, 써드파티 카메라도 잠금화면이나 컨트롤센터에서 바로 사용할 수도 있고, 액션 버튼이 컨트롤센터 등과 유기적으로 연결되고, 아이폰이 죽거나 방전되어도 시간이 계속 표시되는 등 여러 업데이트가 발견되고 있다. 시리는 아예 잠겨있을 때도 동작할 수 있는 트리거를 추가하는 모양이다. 베타 배포 도구인 Testflight 앱도 새롭게 디자인 되는 듯하다.&lt;/li&gt;
&lt;li&gt;macOS 15 Sequoia: 내장된 체스 게임의 그래픽이 업데이트 된다.&lt;/li&gt;
&lt;li&gt;watchOS 11: 새로운 번역 앱이 추가된 모양이다.&lt;/li&gt;
&lt;li&gt;Apple Intelligence: 미국에서는 애플지능 베타 사전 신청을 받는 모양이다.&lt;/li&gt;
&lt;li&gt;OpenAI와 애플의 협업에 관한 보고서를 통해 양측은 서로 비용을 지불하지 않는다고 전해지고 있다. 놀라운 딜이 있는 모양이다.&lt;/li&gt;
&lt;li&gt;당연하겠지만 인텔 맥에서는 애플지능과 실시간 음성 타이핑 기능을 쓸 수 없을 전망이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;OS 사용자 전환율 공개&lt;/h2&gt;
&lt;p&gt;애플은 WWDC를 앞두고 OS 전환율을 공개했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아이폰 사용자의 77%가 iOS 17로 업그레이드 했다. 지난 4년 동안 출시된 아이폰은 86%가 업그레이드 했다.&lt;/li&gt;
&lt;li&gt;아이패드 사용자의 68%가 iPadOS 17로 업그레이드 했다. 지난 4년 동안 출시된 아이패드는 77%가 업그레이드 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;낮은 수치는 절대 아니지만 16 버전대에 비하면 느린 결과다. 이 외의 사용자들은 업그레이드에 관심이 없거나 업그레이드가 안 되는 구형 디바이스를 사용 중으로 볼 수도 있다.&lt;/p&gt;
&lt;h2&gt;기타 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;애플이 앱스토어와 대체 앱스토어에서 PC 에뮬레이터 앱을 차단했다. 애플은 PC는 콘솔이 아니기 때문에 에뮬레이터가 허용되지 않는다는 지침을 밝혔다. 하지만 사유로 밝힌 가이드라인에서도 그 이유가 명확하지 않은 듯하다.&lt;/li&gt;
&lt;li&gt;루머 대로 '애플아이디(Apple ID)' 브랜딩이 '애플계정(Apple Account)'으로 바뀐다고 애플이 공식적으로 밝혔다.&lt;/li&gt;
&lt;li&gt;한국에서 애플이 동의 없이 사용자의 위치 정보를 수집한 혐의로 규제 당국에 의해 약 2억 천 만원의 벌금을 부과 받았다고 한다.&lt;/li&gt;
&lt;li&gt;예고된 대로 일본에서 대체 앱스토어와 써드파티 결제 허용을 강제하는 법이 통과되었다. 당연히 애플의 일본 사업에 영향을 미칠 것 같다.&lt;/li&gt;
&lt;li&gt;EU는 DMA 준수가 부족하다는 이유로 애플에 벌금을 부과할 예정이라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;기타 루머 소식들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;미래에 출시될 7.9인치 폴더블 아이폰은 랩 어라운드 디자인을 가질 것이라 추정되는데 화웨이의 폴더블 폰 디자인과 비슷하다는 주장을 외에는 정확히 어떤 디자인인지는 명확하진 않다. &lt;/li&gt;
&lt;li&gt;아이패드 프로의 사례에 이어 애플은 아이폰, 맥북프로, 애플워치 등도 얇게 재디자인 할 것이라는 소문이 돈다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240616-00.html</guid>
      <pubDate>Sun, 16 Jun 2024 23:16:00 +0900</pubDate>
    </item>
    <item>
      <title>PPI는 또 왜이래?</title>
      <link>https://seorenn.github.io/log/20240613-01.html</link>
      <description>&lt;p&gt;CPI가 나오고 다음 날은 PPI가 나온는 날이고 어김없이 또 PPI가 나왔다. CPI에 비하면 조금은 소외되는 지표지만 다음 CPI를 가늠하는 키 중 하나이기도 해서 요즘은 무시할 수가 없다.&lt;/p&gt;
&lt;p&gt;미국 5월 PPI(생산자물가지수)는 대충 요렇게 나왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;헤드라인 PPI: MoM -0.2% (-0.7%), YoY 2.2% (-0.1%)&lt;/li&gt;
&lt;li&gt;근원 PPI: MoM 0.0% (-0.5%), YoY 2.3% (-0.2%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;헤드라인 CPI MoM 지표가 0%가 나온 것도 놀랬지만 이번에는 아예 대놓고 마이너스가 나와버렸다. 물가상승률을 의미하는 인플레이션이 아닌 디플레이션 지표가 되어버리고 말았다. 굳이 언급할 필요도 없겠지만 예측치를 모두 하회한 것은 당연하다.&lt;/p&gt;
&lt;p&gt;CPI와 비슷하게 이번 PPI를 이렇게 꺽어버린 요인은 역시나 에너지 특히 유가 하락분이 컸던 것 같다.&lt;/p&gt;
&lt;p&gt;그래서 시장은 뭔가 반응이 좀 있을까? 잘은 모르겠지만 개장 때와 지금은 분위기가 좀 다른 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FedWatch" src="../upload/202406132327-9fa09f6f.png" /&gt;&lt;/p&gt;
&lt;p&gt;요즘은 FedWatch를 봐도 별 느낌이 안 온다. 아무래도 금리 인하가 없는 세상에 너무 익숙해진 것 같다. 그 덕분인지 아니면 이게 정상인지 모르겠지만 7월 기준금리 인하 가능성은 여전히 소외되고 있는 선택지다. 물론 개인적으로도 9월 인하 가능성이 높지 않을까 찍고(?) 있기도 하다.&lt;/p&gt;
&lt;p&gt;결론적으로 이걸 좋게 봐야되나 나쁘게 봐야 되나 이제는 아무 생각이 없다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;CPI가 나오고 다음 날은 PPI가 나온는 날이고 어김없이 또 PPI가 나왔다. CPI에 비하면 조금은 소외되는 지표지만 다음 CPI를 가늠하는 키 중 하나이기도 해서 요즘은 무시할 수가 없다.&lt;/p&gt;
&lt;p&gt;미국 5월 PPI(생산자물가지수)는 대충 요렇게 나왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;헤드라인 PPI: MoM -0.2% (-0.7%), YoY 2.2% (-0.1%)&lt;/li&gt;
&lt;li&gt;근원 PPI: MoM 0.0% (-0.5%), YoY 2.3% (-0.2%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;헤드라인 CPI MoM 지표가 0%가 나온 것도 놀랬지만 이번에는 아예 대놓고 마이너스가 나와버렸다. 물가상승률을 의미하는 인플레이션이 아닌 디플레이션 지표가 되어버리고 말았다. 굳이 언급할 필요도 없겠지만 예측치를 모두 하회한 것은 당연하다.&lt;/p&gt;
&lt;p&gt;CPI와 비슷하게 이번 PPI를 이렇게 꺽어버린 요인은 역시나 에너지 특히 유가 하락분이 컸던 것 같다.&lt;/p&gt;
&lt;p&gt;그래서 시장은 뭔가 반응이 좀 있을까? 잘은 모르겠지만 개장 때와 지금은 분위기가 좀 다른 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FedWatch" src="../upload/202406132327-9fa09f6f.png" /&gt;&lt;/p&gt;
&lt;p&gt;요즘은 FedWatch를 봐도 별 느낌이 안 온다. 아무래도 금리 인하가 없는 세상에 너무 익숙해진 것 같다. 그 덕분인지 아니면 이게 정상인지 모르겠지만 7월 기준금리 인하 가능성은 여전히 소외되고 있는 선택지다. 물론 개인적으로도 9월 인하 가능성이 높지 않을까 찍고(?) 있기도 하다.&lt;/p&gt;
&lt;p&gt;결론적으로 이걸 좋게 봐야되나 나쁘게 봐야 되나 이제는 아무 생각이 없다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240613-01.html</guid>
      <pubDate>Thu, 13 Jun 2024 23:38:00 +0900</pubDate>
    </item>
    <item>
      <title>모두가 예상했던 6월 FOMC 동결</title>
      <link>https://seorenn.github.io/log/20240613-00.html</link>
      <description>&lt;p&gt;6월 FOMC가 열리기 전 &lt;a href="../log/20240612-01.html"&gt;CPI가 좋게 나와서&lt;/a&gt; 그런지 모르겠지만 이번에는 최소한 인상은 없을 것이라고 보는 시각이 절대 다수였던 것 같다. 그리고 그 시각이 틀리지 않았다는 듯 연준은 또 금리를 동결했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fed는 연방 기준금리를 5.25 ~ 5.50%로 동결 결정했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번 결정도 만장일치 였다. 성명 및 인터뷰를 통해 파월은 이번 결정에 대해 여러 풀이를 내놨는데 대충 정리하면 이런 모양이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인플레이션이 여전히 높다.&lt;/li&gt;
&lt;li&gt;고용시장은 좀 과장된 것 같지만 상대적으로 좋은 상태고 실업률도 아직 낮은 수준이다.&lt;/li&gt;
&lt;li&gt;인하 시점은 미정이고 좋은 지표가 더 필요하지만 예상보다 인플레이션 둔화가 빠르면 혹은 특수한(?) 상황에는 대응할 것이다.&lt;/li&gt;
&lt;li&gt;아직 인하 시점은 아니지만 슬슬 논의를 시작할 수는 있을 것 같다.&lt;/li&gt;
&lt;li&gt;(점도표 상) 연내 기준금리 인하는 1회로 예상되며 인상 의견은 없었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결론적으로 연준은 중립적인 입장이라 볼 수 있다. 쉽게 말해서 '나도 모르겠다'는 것 같다. 결국 인플레이션이나 실업률, 고용률 지표에 따라 인하 시점은 유동적이라는 말이다. 한 가지 힌트로 '인하 논의 시작'을 언급했기에 7월 인하론은 아직 이르다고 보는 게 맞을 것 같다.&lt;/p&gt;
&lt;p&gt;하지만 특수한 상황을 언급한 것으로 보아 정치적 결정, 즉 대선인 11월 이전에 인하할 가능성은 그 이후에 할 가능성 보다 높을 것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;결론: 연준 9월 기준금리 인하?&lt;/p&gt;
&lt;/blockquote&gt;</description>
      <content:encoded>&lt;p&gt;6월 FOMC가 열리기 전 &lt;a href="../log/20240612-01.html"&gt;CPI가 좋게 나와서&lt;/a&gt; 그런지 모르겠지만 이번에는 최소한 인상은 없을 것이라고 보는 시각이 절대 다수였던 것 같다. 그리고 그 시각이 틀리지 않았다는 듯 연준은 또 금리를 동결했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fed는 연방 기준금리를 5.25 ~ 5.50%로 동결 결정했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번 결정도 만장일치 였다. 성명 및 인터뷰를 통해 파월은 이번 결정에 대해 여러 풀이를 내놨는데 대충 정리하면 이런 모양이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인플레이션이 여전히 높다.&lt;/li&gt;
&lt;li&gt;고용시장은 좀 과장된 것 같지만 상대적으로 좋은 상태고 실업률도 아직 낮은 수준이다.&lt;/li&gt;
&lt;li&gt;인하 시점은 미정이고 좋은 지표가 더 필요하지만 예상보다 인플레이션 둔화가 빠르면 혹은 특수한(?) 상황에는 대응할 것이다.&lt;/li&gt;
&lt;li&gt;아직 인하 시점은 아니지만 슬슬 논의를 시작할 수는 있을 것 같다.&lt;/li&gt;
&lt;li&gt;(점도표 상) 연내 기준금리 인하는 1회로 예상되며 인상 의견은 없었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결론적으로 연준은 중립적인 입장이라 볼 수 있다. 쉽게 말해서 '나도 모르겠다'는 것 같다. 결국 인플레이션이나 실업률, 고용률 지표에 따라 인하 시점은 유동적이라는 말이다. 한 가지 힌트로 '인하 논의 시작'을 언급했기에 7월 인하론은 아직 이르다고 보는 게 맞을 것 같다.&lt;/p&gt;
&lt;p&gt;하지만 특수한 상황을 언급한 것으로 보아 정치적 결정, 즉 대선인 11월 이전에 인하할 가능성은 그 이후에 할 가능성 보다 높을 것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;결론: 연준 9월 기준금리 인하?&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240613-00.html</guid>
      <pubDate>Thu, 13 Jun 2024 10:21:00 +0900</pubDate>
    </item>
    <item>
      <title>FOMC를 앞두고 CPI가 불을 지피다</title>
      <link>https://seorenn.github.io/log/20240612-01.html</link>
      <description>&lt;p&gt;FOMC가 열리는 날 (미국 시각 기준) 아침에 미국의 5월 CPI가 발표되었다. 아무래도 FOMC에 영향을 크게 미칠 수도 있을 타이밍이라 관심이 집중되었는데 대충 이런 식으로 나왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;헤드라인 CPI MoM 0% (-0.3%), YoY 3.3% (-0.1%)&lt;/li&gt;
&lt;li&gt;근원 CPI MoM 0.2% (-0.1%), YoY 3.4% (-0.2%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;둘 다 전달 지표 대비 제법 둔화된 모습을 보였다는 것도 호재고 모두 예측치를 하회했다는 것도 호재라 2연 콤보가 제대로 들어왔다.&lt;/p&gt;
&lt;p&gt;세부 내역을 보면 헤드라인 CPI에는 전반적인 에너지 물가 하락, 신차 가격 하락, 운송비 등의 하락에 큰 영향을 끼친 것으로 보인다. 반대로 중고차 가격이나 의료비 등은 이번에는 반등했다.&lt;/p&gt;
&lt;p&gt;문제의 주거비는 여전히 안 잡히고 있지만 그나마 증가폭이 네 달 째 더 늘어나지는 않고 있기는 하다. 얘는 더는 커지지만 않았으면 하는 바램일 뿐이다.&lt;/p&gt;
&lt;p&gt;결과적으로 FOMC에 악영향을 끼치지는 않을 지표 같다. 좋게 영향을 미칠 수 있겠다면 좋겠지만 단기간의 변화는 추세를 만들지 못 하는 만큼 기대를 키울 필요는 없을 것 같다.&lt;/p&gt;
&lt;p&gt;어쨌든 덕분에 주식시장이 또 활기에 찬 것 같다. 애플은 어제의 이례적인 폭등에 이어 순간적일 지도 모르겠지만 일단은 시가총액 1위 자리를 다시 탈환했다. 엔비디아의 도전이 생각보단 쉽게 안 풀리는 게 수 일 전에는 상상이 안 가던 일이었는데 말이다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;FOMC가 열리는 날 (미국 시각 기준) 아침에 미국의 5월 CPI가 발표되었다. 아무래도 FOMC에 영향을 크게 미칠 수도 있을 타이밍이라 관심이 집중되었는데 대충 이런 식으로 나왔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;헤드라인 CPI MoM 0% (-0.3%), YoY 3.3% (-0.1%)&lt;/li&gt;
&lt;li&gt;근원 CPI MoM 0.2% (-0.1%), YoY 3.4% (-0.2%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;둘 다 전달 지표 대비 제법 둔화된 모습을 보였다는 것도 호재고 모두 예측치를 하회했다는 것도 호재라 2연 콤보가 제대로 들어왔다.&lt;/p&gt;
&lt;p&gt;세부 내역을 보면 헤드라인 CPI에는 전반적인 에너지 물가 하락, 신차 가격 하락, 운송비 등의 하락에 큰 영향을 끼친 것으로 보인다. 반대로 중고차 가격이나 의료비 등은 이번에는 반등했다.&lt;/p&gt;
&lt;p&gt;문제의 주거비는 여전히 안 잡히고 있지만 그나마 증가폭이 네 달 째 더 늘어나지는 않고 있기는 하다. 얘는 더는 커지지만 않았으면 하는 바램일 뿐이다.&lt;/p&gt;
&lt;p&gt;결과적으로 FOMC에 악영향을 끼치지는 않을 지표 같다. 좋게 영향을 미칠 수 있겠다면 좋겠지만 단기간의 변화는 추세를 만들지 못 하는 만큼 기대를 키울 필요는 없을 것 같다.&lt;/p&gt;
&lt;p&gt;어쨌든 덕분에 주식시장이 또 활기에 찬 것 같다. 애플은 어제의 이례적인 폭등에 이어 순간적일 지도 모르겠지만 일단은 시가총액 1위 자리를 다시 탈환했다. 엔비디아의 도전이 생각보단 쉽게 안 풀리는 게 수 일 전에는 상상이 안 가던 일이었는데 말이다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240612-01.html</guid>
      <pubDate>Wed, 12 Jun 2024 23:07:00 +0900</pubDate>
    </item>
    <item>
      <title>오늘도 부모 경험치를 쌓는다</title>
      <link>https://seorenn.github.io/log/20240612-00.html</link>
      <description>&lt;p&gt;평소보단 약간 이른 아침, 아이와 함께 평화롭게 아침을 먹고 있었다. 사실 아이에게 휴대폰을 쥐어줬기에 가능한 평화로움이었을 지도 모르겠다. 그게 독이 되었을 수도 있겠지만 말이다.&lt;/p&gt;
&lt;p&gt;아침을 빨리 먹자며 재촉하는 사이에 갑자기 어디선가 굉음이 들린다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"빼~액 빽~ 빽~ 빼~액"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아이 손에 휴대폰 한 대, 내 손에 내 휴대폰 한 대, 바로 옆에 업무용 휴대폰 한 대. 총 3대의 아이폰이 미친듯이 재난문자 굉음을 낸다. 천둥이 옆에 떨어지고 아파트가 무너지는 듯한 그런 미친 굉음이었다.&lt;/p&gt;
&lt;p&gt;순간 많은 생각이 들었다. 최근 북한과 사이가 안 좋은데 설마 미사일 쐈나 아니면 더 설마 남침인가? 근처에서 불이라도 났을까? 어디선가 지진이라도 난 것일까?&lt;/p&gt;
&lt;p&gt;의문은 당연하게도 금방 해결되었다. 지진이었다. 전북에서 4.8이라니 보통이 아닌 세기다.&lt;/p&gt;
&lt;p&gt;조금은 먼 곳이었기에 약간의 안도감은 들었지만, 아이를 바라보게 되고 순간적으로 바로 옆의 책장을 손으로 잡는다. 설마 여기까지 지진이 덮치면 우리 아이 어떡하지라는 생각이 머리 속에 차기 시작했다. 지금이라도 아이를 들고 밖으로 나가야 되나? 아니면 식탁 밑으로 함께 숨어야 되나? 마침 바로 옆이 내력벽인데 여기에 머리 감싸고 그냥 있자고 해야 되나? &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"그리고 내가 아이를 감싸고 있으면 괜찮겠지?"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그 어떤 선택이든 내 몸이 최후의 방패가 되는 것은 정해져 있는 일이었다. 당시에는 그냥 지극히 당연하게 든 생각이었는데 지금 생각해보면 뭔가 살짝 감정이 격해지는 느낌도 든다.&lt;/p&gt;
&lt;p&gt;이렇게 또 부모 경험치를 쌓으며 정말 부모가 되어가는 건가 보다.&lt;/p&gt;
&lt;p&gt;놀래서 한동안 부들부들 떨고 있던 아이를 달래고 달래서 어린이집으로 데려간다. 오늘도 변함 없는 하루가 시작되었다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;평소보단 약간 이른 아침, 아이와 함께 평화롭게 아침을 먹고 있었다. 사실 아이에게 휴대폰을 쥐어줬기에 가능한 평화로움이었을 지도 모르겠다. 그게 독이 되었을 수도 있겠지만 말이다.&lt;/p&gt;
&lt;p&gt;아침을 빨리 먹자며 재촉하는 사이에 갑자기 어디선가 굉음이 들린다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"빼~액 빽~ 빽~ 빼~액"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아이 손에 휴대폰 한 대, 내 손에 내 휴대폰 한 대, 바로 옆에 업무용 휴대폰 한 대. 총 3대의 아이폰이 미친듯이 재난문자 굉음을 낸다. 천둥이 옆에 떨어지고 아파트가 무너지는 듯한 그런 미친 굉음이었다.&lt;/p&gt;
&lt;p&gt;순간 많은 생각이 들었다. 최근 북한과 사이가 안 좋은데 설마 미사일 쐈나 아니면 더 설마 남침인가? 근처에서 불이라도 났을까? 어디선가 지진이라도 난 것일까?&lt;/p&gt;
&lt;p&gt;의문은 당연하게도 금방 해결되었다. 지진이었다. 전북에서 4.8이라니 보통이 아닌 세기다.&lt;/p&gt;
&lt;p&gt;조금은 먼 곳이었기에 약간의 안도감은 들었지만, 아이를 바라보게 되고 순간적으로 바로 옆의 책장을 손으로 잡는다. 설마 여기까지 지진이 덮치면 우리 아이 어떡하지라는 생각이 머리 속에 차기 시작했다. 지금이라도 아이를 들고 밖으로 나가야 되나? 아니면 식탁 밑으로 함께 숨어야 되나? 마침 바로 옆이 내력벽인데 여기에 머리 감싸고 그냥 있자고 해야 되나? &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"그리고 내가 아이를 감싸고 있으면 괜찮겠지?"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그 어떤 선택이든 내 몸이 최후의 방패가 되는 것은 정해져 있는 일이었다. 당시에는 그냥 지극히 당연하게 든 생각이었는데 지금 생각해보면 뭔가 살짝 감정이 격해지는 느낌도 든다.&lt;/p&gt;
&lt;p&gt;이렇게 또 부모 경험치를 쌓으며 정말 부모가 되어가는 건가 보다.&lt;/p&gt;
&lt;p&gt;놀래서 한동안 부들부들 떨고 있던 아이를 달래고 달래서 어린이집으로 데려간다. 오늘도 변함 없는 하루가 시작되었다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240612-00.html</guid>
      <pubDate>Wed, 12 Jun 2024 15:44:00 +0900</pubDate>
    </item>
    <item>
      <title>6월 FOMC를 앞두고 보는 연준 인사들의 발언들</title>
      <link>https://seorenn.github.io/log/20240611-02.html</link>
      <description>&lt;p&gt;6월 FOMC를 앞두고 이번에도 그 사이의 연준 인사들의 발언들을 모아서 정리해 봤다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;제롬 파월 (연준 의장)&lt;/strong&gt;: "고용시장은 조금씩 식고 있어, 다만 인플레이션 둔화에 자신은 없어, 다만 다음 회의에서 인상은 없을 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;마이클 바 (연준 부의장)&lt;/strong&gt;: "1분기 지표는 실망스러워, 목표 달성까지 좀 더 시간이 필요할 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;필립 제퍼슨 (연준 부의장)&lt;/strong&gt;: "현 정책은 충분히 제약적이며 최근 인플레이션 둔화와 주택 시장을 신중하게 평가할 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;미셸 보먼 (연준 이사)&lt;/strong&gt;: "인플레이션이 당분간 높은 수준을 유지할 것, 상황에 따라 금리 인상도 선택지", "현 통화정책은 충분히 제약적이며 현 금리를 유지하면 인플레이션은 하락할 것", "QT 종료를 기준금리 인하 신호로 보면 안 돼"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;크리스토퍼 월러 (연준 이사)&lt;/strong&gt;: "금융 제재가 달러의 위상에 악영향을 미쳐", "인플레이션이 가속화되지 않아 추가 금리 인상은 불필요", "3~5개월 내내 지표가 누그러지면 연말에나 금리 인하 가능할 것", "단정할 순 없지만 중립금리 오를 수 있어"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;존 윌리엄스 (뉴욕 연방 총재)&lt;/strong&gt;: "시간은 좀 더 필요하겠지만 금리는 결국 내릴 것", "긍정적 지표가 나오고 있지만 아직 충분하지는 않아, 다만 인상은 필요 없을 것", "인플레이션은 여전히 높지만 하반기로 갈 수록 둔화 속도는 빨라질 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;토마스 바킨 (리치먼드 연은 총재)&lt;/strong&gt;: "현 기준금리는 충분히 효과적이며 결국 인플레이션 목표를 달성시킬 것", "최근 지표는 긍정적이지만 연준의 목표에는 못 미쳐"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;닐 카시카리 (미니애폴리스 연은 총재)&lt;/strong&gt;: "기준금리 인상 시나리오를 배제할 수 없다", "좀 더 오래 금리를 동결해야", "금리 인하 전에 수개월간의 긍정적인 인플레이션 데이터가 필요", "누구도 금리 인상을 배제하지 않아", "미국인들은 인플레이션 보다는 경기침체를 원할 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;수잔 콜린스 (보스턴 연은 총재)&lt;/strong&gt;: "인플레이션 2% 대까지 돌아가는데 필요한 만큼 경제 활동이 둔화될 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;메리 데일리 (샌프란시스코 연은 총재)&lt;/strong&gt;: "향후 인플레이션의 움직임은 상당히 불확실" (물가와 노동시장의 움직임에 따라 금리 향방이 달라질 거라는 듯하다. 그냥 중립적인 듯하다.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;로리 로건 (댈러스 연은 총재)&lt;/strong&gt;: "금리 인하를 생각하기에는 너무 이르다"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;오스탄 굴스비 (시카고 연은 총재)&lt;/strong&gt;: "올해 인플레이션이 계속 하락할 것, 하지만 금리의 방향이 정해진 것은 아니다", "주거비 인플레이션이 더 낮아져야"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;로레타 메스터 (클리블랜드 연은 총재)&lt;/strong&gt;: "금리를 다시 올리고 싶지는 않다", "목표 달성을 위해 현 금리를 더 유지해야"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;제프리 슈미드 (캔자스시티 연은 총재)&lt;/strong&gt;: "인플레이션에 진전이 있었지만 여전히 과제가 남아있어"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;래피얼 보스틱 (애틀랜타 연은 총재)&lt;/strong&gt;: "하나의 경제지표를 추세로 간주해서는 안 돼", "인플레이션은 하락하겠지만 좀 더딜 것", "고금리를 더 오랫동안 지속해야"&lt;/p&gt;
&lt;h2&gt;기타&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;에릭 로젠그렌 (전 보스턴 연은 총재)&lt;/strong&gt;: "중국 관세 조치가 인플레이션 목표 달성을 지연시킬 수도"&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;6월 FOMC에서 비둘기적인 결과를 보기엔 좀 힘들 것 같은 분위기다. 점도표에서 올해 중 2회 인하가 찍혀 나오면 무조건 호재일 것 같다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;6월 FOMC를 앞두고 이번에도 그 사이의 연준 인사들의 발언들을 모아서 정리해 봤다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;제롬 파월 (연준 의장)&lt;/strong&gt;: "고용시장은 조금씩 식고 있어, 다만 인플레이션 둔화에 자신은 없어, 다만 다음 회의에서 인상은 없을 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;마이클 바 (연준 부의장)&lt;/strong&gt;: "1분기 지표는 실망스러워, 목표 달성까지 좀 더 시간이 필요할 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;필립 제퍼슨 (연준 부의장)&lt;/strong&gt;: "현 정책은 충분히 제약적이며 최근 인플레이션 둔화와 주택 시장을 신중하게 평가할 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;미셸 보먼 (연준 이사)&lt;/strong&gt;: "인플레이션이 당분간 높은 수준을 유지할 것, 상황에 따라 금리 인상도 선택지", "현 통화정책은 충분히 제약적이며 현 금리를 유지하면 인플레이션은 하락할 것", "QT 종료를 기준금리 인하 신호로 보면 안 돼"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;크리스토퍼 월러 (연준 이사)&lt;/strong&gt;: "금융 제재가 달러의 위상에 악영향을 미쳐", "인플레이션이 가속화되지 않아 추가 금리 인상은 불필요", "3~5개월 내내 지표가 누그러지면 연말에나 금리 인하 가능할 것", "단정할 순 없지만 중립금리 오를 수 있어"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;존 윌리엄스 (뉴욕 연방 총재)&lt;/strong&gt;: "시간은 좀 더 필요하겠지만 금리는 결국 내릴 것", "긍정적 지표가 나오고 있지만 아직 충분하지는 않아, 다만 인상은 필요 없을 것", "인플레이션은 여전히 높지만 하반기로 갈 수록 둔화 속도는 빨라질 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;토마스 바킨 (리치먼드 연은 총재)&lt;/strong&gt;: "현 기준금리는 충분히 효과적이며 결국 인플레이션 목표를 달성시킬 것", "최근 지표는 긍정적이지만 연준의 목표에는 못 미쳐"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;닐 카시카리 (미니애폴리스 연은 총재)&lt;/strong&gt;: "기준금리 인상 시나리오를 배제할 수 없다", "좀 더 오래 금리를 동결해야", "금리 인하 전에 수개월간의 긍정적인 인플레이션 데이터가 필요", "누구도 금리 인상을 배제하지 않아", "미국인들은 인플레이션 보다는 경기침체를 원할 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;수잔 콜린스 (보스턴 연은 총재)&lt;/strong&gt;: "인플레이션 2% 대까지 돌아가는데 필요한 만큼 경제 활동이 둔화될 것"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;메리 데일리 (샌프란시스코 연은 총재)&lt;/strong&gt;: "향후 인플레이션의 움직임은 상당히 불확실" (물가와 노동시장의 움직임에 따라 금리 향방이 달라질 거라는 듯하다. 그냥 중립적인 듯하다.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;로리 로건 (댈러스 연은 총재)&lt;/strong&gt;: "금리 인하를 생각하기에는 너무 이르다"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;오스탄 굴스비 (시카고 연은 총재)&lt;/strong&gt;: "올해 인플레이션이 계속 하락할 것, 하지만 금리의 방향이 정해진 것은 아니다", "주거비 인플레이션이 더 낮아져야"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;로레타 메스터 (클리블랜드 연은 총재)&lt;/strong&gt;: "금리를 다시 올리고 싶지는 않다", "목표 달성을 위해 현 금리를 더 유지해야"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;제프리 슈미드 (캔자스시티 연은 총재)&lt;/strong&gt;: "인플레이션에 진전이 있었지만 여전히 과제가 남아있어"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;래피얼 보스틱 (애틀랜타 연은 총재)&lt;/strong&gt;: "하나의 경제지표를 추세로 간주해서는 안 돼", "인플레이션은 하락하겠지만 좀 더딜 것", "고금리를 더 오랫동안 지속해야"&lt;/p&gt;
&lt;h2&gt;기타&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;에릭 로젠그렌 (전 보스턴 연은 총재)&lt;/strong&gt;: "중국 관세 조치가 인플레이션 목표 달성을 지연시킬 수도"&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;6월 FOMC에서 비둘기적인 결과를 보기엔 좀 힘들 것 같은 분위기다. 점도표에서 올해 중 2회 인하가 찍혀 나오면 무조건 호재일 것 같다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240611-02.html</guid>
      <pubDate>Tue, 11 Jun 2024 21:37:00 +0900</pubDate>
    </item>
    <item>
      <title>민주당이 '이사의 충실의무' 상법 개정을 발의 했었다니?</title>
      <link>https://seorenn.github.io/log/20240611-01.html</link>
      <description>&lt;p&gt;밸류업에 가장 중요한 부분이 상법 개정이라는 주장에 민간에서는 많은 이들이 동의하는 부분이다. 개인적으로 이 상법 개정이 민주당에 의해 발의되었는 지는 몰랐었는데 이번에 다시 발의 되었다고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;더불어민주당 정준호 의원이 최근 대표 발의한 상법 개정안은 상법 제382조의 3에 이사가 '회사'를 위하여 그 의무를 충실하게 수행해야 한다고 규정한 부분을 '주주의 비례적 이익과 회사'를 위하여 의무를 충실하게 수행해야 한다고 수정했다. - &lt;a href="https://news.einfomax.co.kr/news/articleView.html?idxno=4312699" target="_blank"&gt;밸류업 뜨거운 감자된 '이사의 충실의무'…국회서도 쟁점📎&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;밸류업에 대해 민주당이 상법 개정에 대해서는 반대하지 않을 거라고는 예상하긴 했지만 오히려 주도할 줄은 몰랐다. 생각해보면 현 보수 정치세력이 친기업이었다는 점을 간과했다. 국민의힘이나 현 정부 요인들은 전통적으로 대주주 편을 드는 정치세력이었으니 말이다.&lt;/p&gt;
&lt;p&gt;이 개정으로 인해 뭐가 달라질 수 있을까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;돈 부족하다고 맘대로 유상증자를 하면 주가 하락으로 대주주를 제외한 다수의 주주들이 피해를 보는데 이를 막을 수 있다. &lt;/li&gt;
&lt;li&gt;초기 투자자 엑시트 시킨다고 하는 물적분할은 모기업의 가치를 낮추어 역시 주가를 하락시켜 많은 투자자들에 피해를 끼치는데 역시 이를 막을 수 있다.&lt;/li&gt;
&lt;li&gt;이해관계가 얽힌 회사끼리 지분을 교환해서 주주총회에서 대주주에 유리하게 서로 영향을 끼치는 행위도 주주에게 피해를 끼친다면 제한될 수 있다.&lt;/li&gt;
&lt;li&gt;상속 시점에 상속세를 줄이기 위해 의도적으로 회사의 주가를 떨어뜨리는 행위 또한 주주의 피해로 이어지는데 이를 막을 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;문구 개정 하나로 정말 많은 것이 달라진다. 단지 예시일 뿐이지만 몇 년 전부터 그리고 지금도 많은 주주들을 화나게 하는 이런 일들을 막을 수 있다는 말이다. 회사의 경영진은 모두 주주에게 손해를 끼치는 일을 하기 쉽지 않아지고 소액주주든 대주주든 주주에 손해를 끼친다면 손해배상의 대상이 될 수 있으니 말이다.&lt;/p&gt;
&lt;p&gt;다만 누군가 쟁점화 시키고 있다는 점이 좀 아쉽다. '비례적 이익'이라는 부분을 문제삼는 듯하다. 이 말은 '모두가 보유 주식 수 만큼 공정하게'라는 의미로 쉽게 말해서 "대주주에게만 이익이 되고 소액주주에게 손해가 되는 일을 해서는 안 된다"고 명확하게 정의한 것으로 볼 수 있다. 만약 '비례적'을 뺀다면 소액주주의 권리는 상황에 따라 무시될 수도 있는 법이다. 따라서 개인적으로는 민주당 개정안이 취지에 맞고 대한민국에 꼭 필요한 밸류업 법안이라고 보인다. &lt;/p&gt;
&lt;p&gt;하지만 보수 정치 세력 및 경영인 단체는 여전히 대주주 편을 들면서 이 개정을 반대할 가능성이 있다. 물론 이 개정이 이뤄진 후 대주주와 소액주주의 이해관계가 상충한다면 이사는 누구 편을 들어야 할지 고민하는 게 틀린 건 아니겠지만, 이해상충이라면 대주주 편을 들더라도 소액주주의 손해 보전도 함께 생각해야 맞는 게 아닐까? 그들(?)의 논지에는 뭔가가 많이 잘못 되었다고 생각된다.&lt;/p&gt;
&lt;p&gt;어쨌거나 이 상법 개정안이 제때 통과되어 효과를 내게 되면 금투세 개시 시점에 대해 여론의 호의가 더 생길 지도 모른다. 만약 대통령이 이것 조차 거부한다면 현 정권과 여당의 몇 안 되는 콘크리트 지지율에도 영향이 갈 지도 모르겠고 말이다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;밸류업에 가장 중요한 부분이 상법 개정이라는 주장에 민간에서는 많은 이들이 동의하는 부분이다. 개인적으로 이 상법 개정이 민주당에 의해 발의되었는 지는 몰랐었는데 이번에 다시 발의 되었다고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;더불어민주당 정준호 의원이 최근 대표 발의한 상법 개정안은 상법 제382조의 3에 이사가 '회사'를 위하여 그 의무를 충실하게 수행해야 한다고 규정한 부분을 '주주의 비례적 이익과 회사'를 위하여 의무를 충실하게 수행해야 한다고 수정했다. - &lt;a href="https://news.einfomax.co.kr/news/articleView.html?idxno=4312699" target="_blank"&gt;밸류업 뜨거운 감자된 '이사의 충실의무'…국회서도 쟁점📎&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;밸류업에 대해 민주당이 상법 개정에 대해서는 반대하지 않을 거라고는 예상하긴 했지만 오히려 주도할 줄은 몰랐다. 생각해보면 현 보수 정치세력이 친기업이었다는 점을 간과했다. 국민의힘이나 현 정부 요인들은 전통적으로 대주주 편을 드는 정치세력이었으니 말이다.&lt;/p&gt;
&lt;p&gt;이 개정으로 인해 뭐가 달라질 수 있을까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;돈 부족하다고 맘대로 유상증자를 하면 주가 하락으로 대주주를 제외한 다수의 주주들이 피해를 보는데 이를 막을 수 있다. &lt;/li&gt;
&lt;li&gt;초기 투자자 엑시트 시킨다고 하는 물적분할은 모기업의 가치를 낮추어 역시 주가를 하락시켜 많은 투자자들에 피해를 끼치는데 역시 이를 막을 수 있다.&lt;/li&gt;
&lt;li&gt;이해관계가 얽힌 회사끼리 지분을 교환해서 주주총회에서 대주주에 유리하게 서로 영향을 끼치는 행위도 주주에게 피해를 끼친다면 제한될 수 있다.&lt;/li&gt;
&lt;li&gt;상속 시점에 상속세를 줄이기 위해 의도적으로 회사의 주가를 떨어뜨리는 행위 또한 주주의 피해로 이어지는데 이를 막을 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;문구 개정 하나로 정말 많은 것이 달라진다. 단지 예시일 뿐이지만 몇 년 전부터 그리고 지금도 많은 주주들을 화나게 하는 이런 일들을 막을 수 있다는 말이다. 회사의 경영진은 모두 주주에게 손해를 끼치는 일을 하기 쉽지 않아지고 소액주주든 대주주든 주주에 손해를 끼친다면 손해배상의 대상이 될 수 있으니 말이다.&lt;/p&gt;
&lt;p&gt;다만 누군가 쟁점화 시키고 있다는 점이 좀 아쉽다. '비례적 이익'이라는 부분을 문제삼는 듯하다. 이 말은 '모두가 보유 주식 수 만큼 공정하게'라는 의미로 쉽게 말해서 "대주주에게만 이익이 되고 소액주주에게 손해가 되는 일을 해서는 안 된다"고 명확하게 정의한 것으로 볼 수 있다. 만약 '비례적'을 뺀다면 소액주주의 권리는 상황에 따라 무시될 수도 있는 법이다. 따라서 개인적으로는 민주당 개정안이 취지에 맞고 대한민국에 꼭 필요한 밸류업 법안이라고 보인다. &lt;/p&gt;
&lt;p&gt;하지만 보수 정치 세력 및 경영인 단체는 여전히 대주주 편을 들면서 이 개정을 반대할 가능성이 있다. 물론 이 개정이 이뤄진 후 대주주와 소액주주의 이해관계가 상충한다면 이사는 누구 편을 들어야 할지 고민하는 게 틀린 건 아니겠지만, 이해상충이라면 대주주 편을 들더라도 소액주주의 손해 보전도 함께 생각해야 맞는 게 아닐까? 그들(?)의 논지에는 뭔가가 많이 잘못 되었다고 생각된다.&lt;/p&gt;
&lt;p&gt;어쨌거나 이 상법 개정안이 제때 통과되어 효과를 내게 되면 금투세 개시 시점에 대해 여론의 호의가 더 생길 지도 모른다. 만약 대통령이 이것 조차 거부한다면 현 정권과 여당의 몇 안 되는 콘크리트 지지율에도 영향이 갈 지도 모르겠고 말이다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240611-01.html</guid>
      <pubDate>Tue, 11 Jun 2024 16:50:00 +0900</pubDate>
    </item>
    <item>
      <title>애플 WWDC24 간단 정리 및 감상</title>
      <link>https://seorenn.github.io/log/20240611-00.html</link>
      <description>&lt;p&gt;WWDC24가 순조롭게(?) 끝난 것 같지만 애플 주가는 하락했다. 시장의 분위기가 느껴지는 한 문구다. 어쨌든 기대를 크게 모은 WWDC24를 간단히 정리해 보고 감상 및 사족을 정리해 보자.&lt;/p&gt;
&lt;h2&gt;각종 OS 차기 메이저 버전 미리보기&lt;/h2&gt;
&lt;p&gt;늘 WWDC가 그랬듯 각 OS들의 차기 메이저 업데이트 미리보기가 이번에도 키노트로 정리되었다.&lt;/p&gt;
&lt;p&gt;시작은 애플TV+ 자랑 및 광고로 부터 시작했다. WWDC는 개발자 행사인데 이런 것으로 시작했다는 것에는 좀 실망스러웠다.&lt;/p&gt;
&lt;p&gt;진짜 시작점은 비전프로의 OS인 visionOS로 그만큼 중요하다는 의미였을 것 같다. visionOS 2의 변경점은 크게 바뀌거나 추가되는 건 없고 기존 기능들의 개선에 가깝다는 느낌이다. 다만 Volumetric API, TabvletopKit, Enterprise APIs 등 개선의 기능과 맞물려 개발자 들을 지원하기 위한 다양한 개선은 눈의 띄인다. 불행히도 한국이 정발 목록에 빠져 있다는 것은 상당히 아쉬운 부분이었다. &lt;em&gt;어차피 난 안(못) 살거지만.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;iOS 18은 여러 기능이 소개되었지만 상당수 부분은 AI와 관련된 부분이고, 아이콘 색상 강조 및 이를 이용한 홈스크린 다크모드 개선과 컨트롤 센터 개선 및 API 지원, 사진 보관함 개선, 그리고 가장 화제(?)인 '통화 녹음'을 제외하면 크게 바뀐 건 없다는 느낌이다. 지도도 Tap to Cash도 한국에선 무쓸모니 말이다.&lt;/p&gt;
&lt;p&gt;Airpods가 Siri와의 상호작용 개선으로 보여준 기능은 제법 괜찮아 보였다. 말로 하기 힘든 경우가 많은 상황에서 머리 제스처를 인식하는 것은 쓸 만한 기능 같다. 그밖에 음성분리가 더 강화되는 것 같은데 이제는 에어팟이 아이폰의 필수 악세서리가 되어가는 느낌이다.&lt;/p&gt;
&lt;p&gt;tvOS, watchOS는 쓰질 않으니 잘 모르겠다.&lt;/p&gt;
&lt;p&gt;iPadOS 18은 특히 계산기가 충격을 좀 줬다. 별 거 아닌 앱이 왜 이제서야 들어오나 이런 생각들이 많았었으니 말이다. 특히 계산기 안의 수식메모 기능이 아이패드용으로 새롭게 개발된 계산기 앱을 킬러 앱으로 만들어 줬다. 엄밀히 이야기하자면 플랫폼의 AI 기능이긴 하지만, 어쨌든 수학공식은 키보드로 입력하기 지랄같고 애플펜슬이 필요한 몇 안 되는 특수한 경우라 생각하는데 이걸 아주 제대로 자동화로 융합시켜 아이패드에 적합한 좋은 기능으로 만들었다.&lt;/p&gt;
&lt;p&gt;macOS 15의 경우는 아이폰 미러링 기능이 제대로 대박이었다. 다른 미러링과는 다르게 아예 아이폰을 맥 안으로 넣어버리는 듯한 기능이니 말이다. 심지어 아이폰과 미러링 되는 아이폰을 따로 사용하는 것조차 가능했으니 미러링 수준은 한참 넘어섰다. 그 외에는 다른 플랫폼과의 연속성에 집중이 된 모습이었다. 새로운 패스워드 앱은 예상대로 모든 플랫폼에 도입되는 것 같다. Game Porting Toolkit 2의 경우는 좋은 지원 임에는 분명하나 그보다 애플 자체에서 게임 개발사의 이식을 직접적으로 지원하는 모습을 보여주는 것도 필요하다고 생각된다.&lt;/p&gt;
&lt;h2&gt;AI = Apple Intelligence&lt;/h2&gt;
&lt;p&gt;어찌보면 이번 WWDC의 핵심이 바로 이 AI다. 다만 말장난인지 의도한 브랜드인지 하여간 애플은 AI를 Artificial Intelligence가 아닌 Apple Intelligence라고 부른다.&lt;/p&gt;
&lt;p&gt;AI를 활용하는 모습은 루머로 상당히 많이 언급된 형태라 크게 신선한 느낌은 없었다. '수식메모' 같은 무시무시한 것도 있었고 '동작 자동화' 라는 미래가 기대되는 기능과 '필체 흉내' 같은 재미있는 기능도 있긴 했지만 요약, 사진 인식, 이모티콘 조합, 프롬프트 기반 이미지 생성, 사진 찾기 등등은 흔한 기능이라 생각된다.&lt;/p&gt;
&lt;p&gt;물론 애플 답게 &lt;strong&gt;가장 강조했던 것은 이번에도 Privacy&lt;/strong&gt;였다. 거의 모든 AI 활용 기능에서 이 개인정보 보호를 꼭 덧붙였다. 대부분의 AI 기능이 온 디바이스로 구동되니 당연하기도 했지만, 심지어 클라우드가 필요한 부분에서도 이 프라이버시를 강조했다. 다만 여기서의 클라우드는 애플 자체 서버로 구축된 클라우드 한정이다.&lt;/p&gt;
&lt;p&gt;화제를 모았던 OpenAI와의 협업도 결국 Siri의 일부분으로서만 동작하는 형태로 밝혀졌다. 물론 상당수의 사람들이 이런 수준일 거라고 예상했는데 모든 것을 맡기기에는 애플이 강조하는 Privacy를 스스로 포기하는 일이 될 테니 말이다. 아마도 시장이 가장 실망한 부분이 이 부분인 것 같다.&lt;/p&gt;
&lt;p&gt;여기까지만 보면 시장의 반응이 실망으로 표현된 것이 이해가 된다. 킬러 기능으로 와닿는 것은 몇 없었고 대부분 흔한 기능들이었으니 말이다. 다만 흔하긴 해도 쓸만한 기능들이라 주가 폭락 까지는 아니었던 것 같고 여기까지 기대를 쌓은 부분을 이익 실현하는 형태의 조정이라고 생각된다. 하지만 실망감이 있다는 것은 분명하다.&lt;/p&gt;
&lt;h2&gt;소감&lt;/h2&gt;
&lt;p&gt;개인적으로는 애플지능(?)은 이제부터 시작인데 왜 벌써 실망하느냐는 생각만 든다. 거의 막바지에 등장하긴 했지만 애플의 AI 기능들은 모두 &lt;strong&gt;애플의 SDK를 활용하면 대부분 개발자가 별 짓(?)을 안 해도 바로 접목&lt;/strong&gt;이 될 수 있다. 예를 들어 TextKit 혹은 이를 기반으로 만들어진 프레임워크를 사용해 개발한 앱은 AI 요약 기능을 거의 바로 사용할 수 있게 된다. 이 부분은 굉장히 중요하다. 향후 애플 생태계가 AI와의 융합에서도 그대로 이어진다는 말이 되니 말이다. 이건 그 어느 곳에서도 아직 제대로 해내지 못 한 부분이다. 따라서 제대로만 제공된다면 개인적인 평가로 &lt;strong&gt;One more thing 급의 혁신 자질은 충분&lt;/strong&gt;하다고 본다.&lt;/p&gt;
&lt;p&gt;단지 소개된 모든 AI 기능들을 활용하려면 아이폰 15 프로나 M 시리즈가 탑재된 기기가 필요하다는 점에서 좀 실망했다. 뉴럴엔진이 탑재된 모든 구형 기기에서도 사용할 수 있게 해야 더 빠르게 써트파티 콘텐츠 공급이 될 수 있을 텐데.... 아 아니다. 신형 아이폰이나 맥, 아이패드를 더 팔아먹어야 하니 뭐 당연한 선택일 수도 있겠다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;WWDC24가 순조롭게(?) 끝난 것 같지만 애플 주가는 하락했다. 시장의 분위기가 느껴지는 한 문구다. 어쨌든 기대를 크게 모은 WWDC24를 간단히 정리해 보고 감상 및 사족을 정리해 보자.&lt;/p&gt;
&lt;h2&gt;각종 OS 차기 메이저 버전 미리보기&lt;/h2&gt;
&lt;p&gt;늘 WWDC가 그랬듯 각 OS들의 차기 메이저 업데이트 미리보기가 이번에도 키노트로 정리되었다.&lt;/p&gt;
&lt;p&gt;시작은 애플TV+ 자랑 및 광고로 부터 시작했다. WWDC는 개발자 행사인데 이런 것으로 시작했다는 것에는 좀 실망스러웠다.&lt;/p&gt;
&lt;p&gt;진짜 시작점은 비전프로의 OS인 visionOS로 그만큼 중요하다는 의미였을 것 같다. visionOS 2의 변경점은 크게 바뀌거나 추가되는 건 없고 기존 기능들의 개선에 가깝다는 느낌이다. 다만 Volumetric API, TabvletopKit, Enterprise APIs 등 개선의 기능과 맞물려 개발자 들을 지원하기 위한 다양한 개선은 눈의 띄인다. 불행히도 한국이 정발 목록에 빠져 있다는 것은 상당히 아쉬운 부분이었다. &lt;em&gt;어차피 난 안(못) 살거지만.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;iOS 18은 여러 기능이 소개되었지만 상당수 부분은 AI와 관련된 부분이고, 아이콘 색상 강조 및 이를 이용한 홈스크린 다크모드 개선과 컨트롤 센터 개선 및 API 지원, 사진 보관함 개선, 그리고 가장 화제(?)인 '통화 녹음'을 제외하면 크게 바뀐 건 없다는 느낌이다. 지도도 Tap to Cash도 한국에선 무쓸모니 말이다.&lt;/p&gt;
&lt;p&gt;Airpods가 Siri와의 상호작용 개선으로 보여준 기능은 제법 괜찮아 보였다. 말로 하기 힘든 경우가 많은 상황에서 머리 제스처를 인식하는 것은 쓸 만한 기능 같다. 그밖에 음성분리가 더 강화되는 것 같은데 이제는 에어팟이 아이폰의 필수 악세서리가 되어가는 느낌이다.&lt;/p&gt;
&lt;p&gt;tvOS, watchOS는 쓰질 않으니 잘 모르겠다.&lt;/p&gt;
&lt;p&gt;iPadOS 18은 특히 계산기가 충격을 좀 줬다. 별 거 아닌 앱이 왜 이제서야 들어오나 이런 생각들이 많았었으니 말이다. 특히 계산기 안의 수식메모 기능이 아이패드용으로 새롭게 개발된 계산기 앱을 킬러 앱으로 만들어 줬다. 엄밀히 이야기하자면 플랫폼의 AI 기능이긴 하지만, 어쨌든 수학공식은 키보드로 입력하기 지랄같고 애플펜슬이 필요한 몇 안 되는 특수한 경우라 생각하는데 이걸 아주 제대로 자동화로 융합시켜 아이패드에 적합한 좋은 기능으로 만들었다.&lt;/p&gt;
&lt;p&gt;macOS 15의 경우는 아이폰 미러링 기능이 제대로 대박이었다. 다른 미러링과는 다르게 아예 아이폰을 맥 안으로 넣어버리는 듯한 기능이니 말이다. 심지어 아이폰과 미러링 되는 아이폰을 따로 사용하는 것조차 가능했으니 미러링 수준은 한참 넘어섰다. 그 외에는 다른 플랫폼과의 연속성에 집중이 된 모습이었다. 새로운 패스워드 앱은 예상대로 모든 플랫폼에 도입되는 것 같다. Game Porting Toolkit 2의 경우는 좋은 지원 임에는 분명하나 그보다 애플 자체에서 게임 개발사의 이식을 직접적으로 지원하는 모습을 보여주는 것도 필요하다고 생각된다.&lt;/p&gt;
&lt;h2&gt;AI = Apple Intelligence&lt;/h2&gt;
&lt;p&gt;어찌보면 이번 WWDC의 핵심이 바로 이 AI다. 다만 말장난인지 의도한 브랜드인지 하여간 애플은 AI를 Artificial Intelligence가 아닌 Apple Intelligence라고 부른다.&lt;/p&gt;
&lt;p&gt;AI를 활용하는 모습은 루머로 상당히 많이 언급된 형태라 크게 신선한 느낌은 없었다. '수식메모' 같은 무시무시한 것도 있었고 '동작 자동화' 라는 미래가 기대되는 기능과 '필체 흉내' 같은 재미있는 기능도 있긴 했지만 요약, 사진 인식, 이모티콘 조합, 프롬프트 기반 이미지 생성, 사진 찾기 등등은 흔한 기능이라 생각된다.&lt;/p&gt;
&lt;p&gt;물론 애플 답게 &lt;strong&gt;가장 강조했던 것은 이번에도 Privacy&lt;/strong&gt;였다. 거의 모든 AI 활용 기능에서 이 개인정보 보호를 꼭 덧붙였다. 대부분의 AI 기능이 온 디바이스로 구동되니 당연하기도 했지만, 심지어 클라우드가 필요한 부분에서도 이 프라이버시를 강조했다. 다만 여기서의 클라우드는 애플 자체 서버로 구축된 클라우드 한정이다.&lt;/p&gt;
&lt;p&gt;화제를 모았던 OpenAI와의 협업도 결국 Siri의 일부분으로서만 동작하는 형태로 밝혀졌다. 물론 상당수의 사람들이 이런 수준일 거라고 예상했는데 모든 것을 맡기기에는 애플이 강조하는 Privacy를 스스로 포기하는 일이 될 테니 말이다. 아마도 시장이 가장 실망한 부분이 이 부분인 것 같다.&lt;/p&gt;
&lt;p&gt;여기까지만 보면 시장의 반응이 실망으로 표현된 것이 이해가 된다. 킬러 기능으로 와닿는 것은 몇 없었고 대부분 흔한 기능들이었으니 말이다. 다만 흔하긴 해도 쓸만한 기능들이라 주가 폭락 까지는 아니었던 것 같고 여기까지 기대를 쌓은 부분을 이익 실현하는 형태의 조정이라고 생각된다. 하지만 실망감이 있다는 것은 분명하다.&lt;/p&gt;
&lt;h2&gt;소감&lt;/h2&gt;
&lt;p&gt;개인적으로는 애플지능(?)은 이제부터 시작인데 왜 벌써 실망하느냐는 생각만 든다. 거의 막바지에 등장하긴 했지만 애플의 AI 기능들은 모두 &lt;strong&gt;애플의 SDK를 활용하면 대부분 개발자가 별 짓(?)을 안 해도 바로 접목&lt;/strong&gt;이 될 수 있다. 예를 들어 TextKit 혹은 이를 기반으로 만들어진 프레임워크를 사용해 개발한 앱은 AI 요약 기능을 거의 바로 사용할 수 있게 된다. 이 부분은 굉장히 중요하다. 향후 애플 생태계가 AI와의 융합에서도 그대로 이어진다는 말이 되니 말이다. 이건 그 어느 곳에서도 아직 제대로 해내지 못 한 부분이다. 따라서 제대로만 제공된다면 개인적인 평가로 &lt;strong&gt;One more thing 급의 혁신 자질은 충분&lt;/strong&gt;하다고 본다.&lt;/p&gt;
&lt;p&gt;단지 소개된 모든 AI 기능들을 활용하려면 아이폰 15 프로나 M 시리즈가 탑재된 기기가 필요하다는 점에서 좀 실망했다. 뉴럴엔진이 탑재된 모든 구형 기기에서도 사용할 수 있게 해야 더 빠르게 써트파티 콘텐츠 공급이 될 수 있을 텐데.... 아 아니다. 신형 아이폰이나 맥, 아이패드를 더 팔아먹어야 하니 뭐 당연한 선택일 수도 있겠다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240611-00.html</guid>
      <pubDate>Tue, 11 Jun 2024 13:50:00 +0900</pubDate>
    </item>
    <item>
      <title>이열치열</title>
      <link>https://seorenn.github.io/log/20240610-00.html</link>
      <description>&lt;blockquote&gt;
&lt;p&gt;이열치열(以熱治熱): 열을 열로 다스린다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;시기를 앞선 듯한 무더위가 왔다. 작년에 고장난 선풍기를 아직 마련하지 않았다. 에어컨을 켜기엔 뭔가 미묘한 것 같다.&lt;/p&gt;
&lt;p&gt;그리고 80도 이상의 뜨거운 정수기 물에 블랙 커피 믹스 두 개를 탄다. 뜨거운 커피다. 마신다. 땀이 흥건해진다.&lt;/p&gt;
&lt;p&gt;이열치열.&lt;/p&gt;
&lt;p&gt;이 정도 땀이면 조금만 바람이 불어도 이 더위를 이겨낼 수 있을 것 같다. 이열치열은 분명 조상의 오랜 경험으로 만들어진 전략일 것이다.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;바람이 안 분다.&lt;/p&gt;
&lt;p&gt;사람 살려.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;에어컨을 틀어 놓은 아기 방으로 피신한다.&lt;/p&gt;
&lt;p&gt;'이열치열'은 절대로 '더위는 에어컨으로 잡아 병신아'라는 의미일 것이다.&lt;/p&gt;</description>
      <content:encoded>&lt;blockquote&gt;
&lt;p&gt;이열치열(以熱治熱): 열을 열로 다스린다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;시기를 앞선 듯한 무더위가 왔다. 작년에 고장난 선풍기를 아직 마련하지 않았다. 에어컨을 켜기엔 뭔가 미묘한 것 같다.&lt;/p&gt;
&lt;p&gt;그리고 80도 이상의 뜨거운 정수기 물에 블랙 커피 믹스 두 개를 탄다. 뜨거운 커피다. 마신다. 땀이 흥건해진다.&lt;/p&gt;
&lt;p&gt;이열치열.&lt;/p&gt;
&lt;p&gt;이 정도 땀이면 조금만 바람이 불어도 이 더위를 이겨낼 수 있을 것 같다. 이열치열은 분명 조상의 오랜 경험으로 만들어진 전략일 것이다.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;바람이 안 분다.&lt;/p&gt;
&lt;p&gt;사람 살려.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;에어컨을 틀어 놓은 아기 방으로 피신한다.&lt;/p&gt;
&lt;p&gt;'이열치열'은 절대로 '더위는 에어컨으로 잡아 병신아'라는 의미일 것이다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240610-00.html</guid>
      <pubDate>Mon, 10 Jun 2024 14:26:00 +0900</pubDate>
    </item>
  </channel>
</rss>
