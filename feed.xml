<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Seorenn Note</title>
<subtitle>Seorenn의 잡다한 메모를 적는 온라인 공개 공책</subtitle>
<link href="https://seorenn.github.io/"/>
<link href="https://seorenn.github.io/feed.xml" rel="self"/>
<updated>2020-07-02T01:57:14+09:00</updated>
<author><name>Seorenn</name></author>
<id>https://seorenn.github.io</id>
<entry>
<title>Javascript에서 같음을 비교하기</title>
<link href="https://seorenn.github.io/note/javascript-equality.html"/>
<id>https://seorenn.github.io/note/javascript-equality.html</id>
<updated>2020-07-01T01:11:10+09:00</updated>
<summary>이 글은 자바스크립트의 최악의 모호성으로 평가받는 같음을 비교하는 것에 관한 글이다</summary>
<content type="text">
이 글은 [Javascript]의 최악의 모호성으로 평가받는 같음(equality)을
비교하는 것에 관한 글이다.


[Javascript] <file:javascript.org>


이건 왜 같지?
=============

  일단 굉장히 유명한 예제를 하나 살펴보자.

  ,----
  | > let a = 1
  | > let b = '1'
  | > a == b
  | true
  `----

  다른 언어였다면 `a' 와 `b' 가 같다는 것이 참(true)이 되었다는 논리
  전개에 파멸과 혼동을 느꼈을지도 모른다. 참 어이없는 식이다. 사실 이
  정도면 컴파일 에러와 같은 문법 오류로 실행 조차 못 시키는 수준의
  내용일테니까 말이다.

  하지만 [Javascript]에서는 당연한 이야기고 이미 익숙한 이들에겐
  한숨나오는 이야기일지도 모르겠다.


[Javascript] <file:javascript.org>


동일 여부 판단
==============

  사실 [Javascript]에는 같은지 비교하기 위한 연산자로 `==' 과 함께 `==='
  도 있다. 즉 equal이 3개나 붙은 연산자다.

  ,----
  | > let a = 1
  | > let b = '1'
  | > a == b
  | true
  | > a === b
  | false
  `----

  이제 뭔가 다른게 보인다.

  앞서 말했다시피 `==' 와 `===' 는 둘 다 같음을 비교하기 위한
  오퍼레이터다.

  하지만 결과에 차이가 있다면 뭔가 다른게 있는 것이다. 추론하자면 `=='
  는 값(value)을 비교하기 위한 오퍼레이터 같다. 아니 정확하게 값을
  비교하는 것도 아니고 비슷한 값인지 비교를 한다. 다른 말로 느슨한
  비교라고도 할 수 있다.

  반면 `===' 는 빡빡한 비교 연산자인데 대충 설명하자면 값과 함께
  타입(types)과 레퍼런스(references)도 비교한다고 볼 수 있다.

  같다라는 의미의 오퍼레이터가 있다면 같지 않다라는 것도 있을 것이다.
  당연하게도 NOT(!)을 붙이면 되겠지라고 생각한다면 정답이다. 같지
  않다라는 의미로 `!=' 와 `!==' 가 있고, 느슨하게 비교하나 빡빡하게
  비교하나의 차이도 동일하다.


[Javascript] <file:javascript.org>


모호성의 폭증
=============

  안타깝게도 앞의 예를 모든 곳에서 써먹을 수 있는 것은 아니다.

  ,----
  | > let a = {age: 18}
  | > let b = {age: 18}
  | > a == b
  | false
  | > a === b
  | false
  `----

  [Javascript]도 레퍼런스 변수 시스템을 사용하는 언어라는 점을 안다면
  당연한 이야기일 것이다.

  즉 `==' 는 여기서는 객체의 레퍼런스를 비교한다. 그리고 `a' 와 `b' 는
  다른 레퍼런스로 만들어졌으니 둘은 다르다. 거기다 `===' 로 비교해도
  이번에는 다를 수 밖에 없다. 레퍼런스가 다르니까.

  그래서 아래와 같이 레퍼런스 대입을 사용하면 또 다른 결과를 볼 수 있다.

  ,----
  | > b = a
  | > a == b
  | true
  | > a === b
  | true
  `----

  그러니까 왜 당연한 이야기를 하냐고? 앞에서 봤던 예를 다시 꺼내기
  위함이다.

  ,----
  | > 2 == '2'
  | true
  | > new String('33') == 33
  | true
  `----

  [Javascript]의 문자열도 분명 `String' 이라는 클래스의 객체다. 그렇다면
  레퍼런스로 비교되어야 맞는 것 같다. 그런데 왜 값을 비교하고 있는 걸까?

  이건 함정이다. 이상한 함정에 빠졌다.

        왜냐하면 자바스크립트의 문자열은 원시 타입(Primitive
        Type)이면서도 메서드를 가지는 초월적인 존재이기 때문이다.
        이게 다 자바스크립트 탓이다. 참고로 이 글은 자바스크립트를
        정중하게 욕하는 글이다.


[Javascript] <file:javascript.org>


우리는 무엇을 써야하나
======================

  사실 추천할 답은 이미 정해져 있다.

  ,----
  | > null == undefined
  | true
  | > null === undefined
  | false
  | > true == 1
  | true
  | > true === 1
  | false
  | > true == '1'
  | true
  | > true === '1'
  | false
  `----

  느슨한 비교가 얼마나 착오를 만들어내는 지는 매우 유명하다. 따라서
  우리가 자주 사용해야 할 것은 빡빡한 비교 연산자인 `===' 과 `!==' 이다.
  이 둘은 적어도 `==', `!=' 보다 부작용이 심하진 않다.

  안타깝지만 이것은 [Javascript]의 특징임을 인정하고 공부를 시작하는
  수밖에 없다고 보인다.


[Javascript] <file:javascript.org>
</content>
</entry>
<entry>
<title>Javascript</title>
<link href="https://seorenn.github.io/note/javascript.html"/>
<id>https://seorenn.github.io/note/javascript.html</id>
<updated>2020-07-01T01:03:32+09:00</updated>
<summary>자바스크립트(Javascript), ECMAScript(ES5, ES6)와 관련된 글들</summary>
<content type="text">
자바스크립트(Javascript)는 웹 브라우저에서 동작하는 스크립트 언어다.
뭔가 부족한 듯한 소개지만 사실상 모든 것을 대변하는 말이다. 물론 현재는
웹 브라우저 뿐만 아니라 엔진만 떼어내면 뭐든 할 수 있는 플랫폼으로
인식될 정도로 많이 쓰이는 언어이기도 해서 이 정의는 틀렸지만 말이다.

이 글에서는 Javascript 뿐만 아니라 ECMAScript를 함께 다룬다. 개념 상 이
둘은 다르게 취급하는 것이 맞겠지만, 현재로써 이 둘을 별도로 생각하는
것도 좀 이상한 것 같기도 하다. 버전은 ES6(ES2015)를 기준으로 한다.


모듈(Module)
============

  일반적으로 모듈은 아래와 같은 형식으로 쓰인다.
  ,----
  | // someModule.js
  | export const name = 'some value';
  | 
  | // someCode.js
  | import { name } from 'someModule.js';
  `----
  이름 자체를 주지 않고 default로 export 한 경우라면 이름을 마음껏 지을
  수 있다.
  ,----
  | // someModule.js
  | export default 'default value';
  | 
  | // someCode.js
  | import anyName from 'someModule.js';
  `----
  이 두 가지 방식을 섞어서 쓸 수도 있다.
  ,----
  | // someModule.js
  | export const name = 'some value';
  | export default 'default value';
  | 
  | // someCode.js
  | import anyName, { name } from 'someModule.js';
  `----
  위에서 알 수도 있겠지만, 당연하게도 모듈은 여러 심볼을 가질 수 있다.
  ,----
  | // someModule.js
  | export const value1 = 'some value 1';
  | export const value2 = 'some value 2';
  | 
  | // someCode.js
  | import * as someValues from 'someModule.js';
  | console.log(someValues.value1);
  | console.log(someValues.value2);
  `----


튜플 비슷한 문법
================

  [Python]의 튜플(Tuple)과 비슷한 문법을 발견해서 메모한다.
  ,----
  | let [foo, bar] = [1, 2]
  | [foo, bar] = [bar, foo]
  `----
  무슨 문법인지 아직 이름은 모르겠다. 하여간 덕분에 중간 매개체 없이
  교환(swap) 구현이 가능해졌다.


[Python] <file:python.org>


문자열(String)
==============

문자열 치환(String Interpolation)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ,----
  | `value = ${value}`
  `----
  백틱으로 둘러싼다는 점에 유의하자. 중괄호 내부는 변수 뿐만 아니라
  식(expression)도 얼마든지 사용할 수 있다.


배열(Array)
===========

배열에 특정 원소가 포함되어 있는지 판단하기
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  `Array.prototype.includes()' 를 사용하는 게 가장 간단하다.
  ,----
  | ["0", "1", "2", "3"].includes("0")  // -> true
  | ["0", "1", "2", "3"].includes(0)    // -> false
  `----
  위치(index)를 알고 싶다면 `Array.prototype.find()' 를 사용할 수도
  있다.
  ,----
  | ["0", "1", "2", "3"].find(e => e === "0")  // -> 0
  | ["0", "1", "2", "3"].find(e => e === "1")  // -> 1
  | ["0", "1", "2", "3"].find(e => e === "4")  // -> undefined
  `----


For Each
~~~~~~~~

  자바스크립트의 Array에는 `forEach' 메서드가 제공된다.
  ,----
  | > [1, 2, 3, 4, 5].forEach((e) => console.log(e))
  | 1
  | 2
  | 3
  | 4
  | 5
  `----
  위는 화살표 함수를 써서 간단하게 [구현]한 것이지만 조금 더 전통적인(?)
  방식으로 [구현]하면 아래와 같다.
  ,----
  | > [1, 2, 3, 4, 5].forEach(function(e) { console.log(e); });
  | 1
  | 2
  | 3
  | 4
  | 5
  `----
  일부러 전통적이라는 의미에서 세미콜론까지 붙여봤다. 근데 ES6를
  지원하는 브라우저라면 굳이 쓸 필요는 없다. 개인적으로는 안 쓰는 것을
  선호한다.

  간혹 getElements류 함수의 결과로 forEach를 쓰려하면 에러가 나는 경우가
  있는데 당연히 타입이 Array가 아니라서 오류가 발생한다. 이럴 때는 대충
  아래처럼 돌려서 쓸 수 있다.
  ,----
  | var elements = document.getElementsByClassName('some-class');
  | // pre ES6
  | Array.prototype.forEach.call(elements, function(e) { ... });
  | // after ES6
  | Array.from(elements).forEach((e) => { ... })
  `----
  개인적으로 ES6 코드는 일부러 세미콜론을 안 붙이고 있으니 구분은 가능할
  것 같다.


[구현] <file:implementation.org>


Object(Dictionary) vs Map
=========================

  자바스크립트에서 키-값(Key-Value) 액세스를 위한 타입으로 Object와 Map
  이라는 내장 타입을 사용할 수 있다. 이 둘을 비교해보자.

  아래는 Object를 사용하는 예제다.
  ,----
  | let obj = {};
  | obj['key'] = 'value';
  | 
  | console.log(Object.keys(obj).length);
  | 
  | if (obj['key']) {
  |   console.log(obj['key']);
  | }
  | 
  | for (let key of Object.keys(obj)) { ... }
  `----
  - Object는 말 그대로 자바스크립트의 기본 객체 타입이지
    사전(Dictionary)형 타입이 아님에 염두를 두자.
  - 아이템 개수를 구하는 부분을 잘 보면 알겠지만 열거를 통해 나열 시킨
    다음 개수를 구하는 방식이라 아무래도 쓸 데 없는 퍼포먼스 낭비가
    있다.
  - 열거 방식도 키 리스트를 구해서 각 키를 별도로 액세스 해야 하는
    부담이 있다.
  - 키 순서는 입력한 순서와 다를 수도 있다.
  - 사전 타입이 아닌 만큼 이미 키를 덮어 쓸 경우 문제를 일으킬 수 있다.

  아래는 `Map' 을 사용하는 예제다.
  ,----
  | let map = new Map();
  | map.set('key', 'vaule');
  | console.log(map.size);
  | let v = map.get('key');
  | 
  | for (let [key, value] of map) { ... }
  `----
  - `Map' 은 Hash Map을 [구현]하는 자료구조 클래스다.
  - `.size' 를 통해 개수를 구하는 부분의 퍼포먼스가 Object에 비해 월등히
    빠르다.
  - 열거 시 키와 값을 미리 가져와서 사용할 수 있기 때문에 퍼포먼스
    측면에서 역시 Object 보다 유리하다.
  - 열거 시 키 순서가 입력된 순서대로 나타난다.
  - 순수한 자료구조 용도의 객체이기 때문에 키를 마음껏 사용할 수 있다.


[구현] <file:implementation.org>


웹 브라우저 DOM 관련
====================

요소 얻기
~~~~~~~~~

  ,----
  | document.getElementById('some-id')
  | document.getElementsByClassName('some-class')[0]
  | document.getElementsByTagName('tag-name')[0]
  `----
  메서드 이름에서 elements와 element의 차이, 즉 복수와 단수의 차이를 잘
  구분하자.


특정 블록에 HTML 넣기
~~~~~~~~~~~~~~~~~~~~~

  아래는 some-id라는 아이디의 div 블록 내부 내용을 [HTML] 태그로
  지정하는 예제다.
  ,----
  | document.getElementById('some-id').innerHTML = '<some-html>...</some-html>'
  `----
  보다시피 그냥 plain text로 [HTML]을 써넣으면 된다.


[HTML] <file:html.org>


콘텐츠 높이 구하기
~~~~~~~~~~~~~~~~~~

  웹 브라우저에 표시되는 내용의 높이(height)를 구하는 방법이다.
  ,----
  | document.getElementsByTagName('body')[0].clientHeight
  `----
  물론 특정 element를 선택해서 할 수도 있다.
  ,----
  | document.getElementById('some-block').clientHeight
  `----
  `clientHeight' 말고 `offsetHeight' 도 비슷한 용도로 사용 가능한 듯
  하다.


특정 태그 앞에 요소 넣기
~~~~~~~~~~~~~~~~~~~~~~~~

  수동으로 노드를 만들어서 특정 태그 노드 앞에 붙이는 예제다.
  ,----
  | let targetElement = document.getElementById('target')
  | let newElement = document.createElement('div')
  | newElement.innerHTML = 'HTML CONTENT'
  | newElement.className = 'some-class'
  | 
  | targetElement.parentNode.insertBefore(newElement, targetElement)
  `----
  좀 더 쉬운 방법도 있다.
  ,----
  | document.getElementById('target').insertAdjacentHTML('beforebegin', 'HTML CONTENT')
  `----
  `beforebegin' 이 위치를 가리키는 의미인데 별도의 상수 정의는 없는 것
  같다. 참고로 `afterbegin', `beforeend', `afterend' 등 다양한 위치를
  지정할 수 있다.


주제별 글들
===========

  - [Javascript에서 같음을 비교하기]
  - [Javascript 스프레드 연산자]
  - [Javascript 화살표 함수]


[Javascript에서 같음을 비교하기] <file:javascript-equality.org>

[Javascript 스프레드 연산자] <file:javascript-spreads-operator.org>

[Javascript 화살표 함수] <file:javascript-arrow-function.org>


외부 링크
=========

  - [모던 JavaScript 튜토리얼]
  - [ECMAScript ES2016~ES2020 정리]
  - [Math as Code]: 수식을 어떻게 표현하는지에 관한 설명의 자바스크립트
    버전


[모던 JavaScript 튜토리얼] <https://ko.javascript.info/>

[ECMAScript ES2016~ES2020 정리]
<https://junhobaik.github.io/es2016-es2020/>

[Math as Code] <https://github.com/Jam3/math-as-code>
</content>
</entry>
<entry>
<title>Annotation VS Comment</title>
<link href="https://seorenn.github.io/note/annotation-vs-comment.html"/>
<id>https://seorenn.github.io/note/annotation-vs-comment.html</id>
<updated>2020-07-01T00:15:06+09:00</updated>
<summary>이 글은 annotation과 comment라는 두 단어를 개인적인 사정으로(?) 비교하는 이상한 글이다</summary>
<content type="text">
이 글은 annotation과 comment라는 두 단어를 개인적인 사정으로(?) 비교하는
이상한 글이다.


Annotation과 Comment의 사전적 의미
==================================

  사실 이 이상한 글을 쓰게 된 계기는 annotation이라는 단어 때문이다. 이
  단어의 사전적 의미를 찾아보면 이렇다.

        annotation: 주석(을 달기)

  annotation의 경우 일반적인 문서나 논문의 보조 설명을 위한 주석 용도로
  사용하는 개념 혹은 노트다.

  학창 시절 공부하면서 책에 펜으로 보조 설명을 적는다던가, 형광펜으로
  뭔가 표시한다던가, 포스트잇 등으로 뭔가를 적어서 붙여 놓는다던가 등이
  대표적인 주석의 예라고 볼 수 있다.

  여기서 주석이라는 의미를 주목할 수 밖에 없다. 왜냐하면
  우리(개발자)들이 흔히 쓰는 주석이라는 단어는 comment이기 때문이다.

        comment: 논평, 언급, 지적, 논평하다, 견해를 밝히다

  이런... comment 자체에 주석이라는 의미가 없었다니! 하지만 소프트웨어
  개발자들은 대체로 코멘트를 주석이라 부르는 것에는 변함은 없는 것 같다.

  어쨌든 결과적으로 둘 다 주석이라는 의미가 있다. 그렇다면 이 두 단어의
  의미는 같다고도 볼 수 있을까?

  그럴리가.


개발자의 Annotation
===================

  영어 단어 annotation은 개발 분야에 있어서는 '주석'이라는 의미로는
  쓰이지 않는다. 그 보다는 뭔가의 지시어와 비슷한 개념이다. 이 코드는
  무슨 역할을 수행한다거나 어떤 특징을 받는다 등의 의미를 가지기도 한다.

  많은 언어들에서 비슷비슷한 문법을 예로 들자면 [Python]의 데코레이터
  패턴이 있다. 아래는 대충 만든 데코레이터 패턴을 사용한 예이다.

  ,----
  | @some_decorator
  | def some_function():
  |     pass
  `----

  위 코드에서 `some_function()' 은 `some_decorator' 의 특징을 받게 된다.
  물론 생략된 것이 많긴 한데, 중요한 것은 여기서 저
  데코레이터(decorator)를 적는 방식이 일반적으로 annotation이라 불리는
  그거다.

  이런 문법은 다양한 언어에서 비슷하게 지원하기도 한다. 예를 들자면
  Java에서는 Annotation 이라는 문법이 비슷한 모양으로 제공되고,
  [Swift]에서는 `PropertyWrapper' 를 annotation 스타일로 지원한다.

  그런데 [Python]의 경우 아예 annotation 문법이 따로 있기도 하다.

  ,----
  | def some_function(a: int, b: int, c: 'This is annotation for c'):
  |     pass
  `----

  위의 경우 `c' 매개변수의 역할을 설명하기 위한 annotation이 그 의미처럼
  '주석' 처럼 붙어있다. 다만 comment와는 다른 점은, 저 주석은 런타임으로
  문서를 볼 수 있는 [Python] 특유의 문법이라는 점이다. 따라서 아주
  특별한 케이스로 볼 수 있다.

  그 외에 역시 [Python]의 Type Annotation이라 불리는 기능도 역시나
  annotation이라는 이름을 달고 있다. 이 기능은 타입 힌트를 주는 방식으로
  강타입 언어의 특징을 대충(?) 붙여주는 용도로 사용된다.

  결론적으로 개발자에겐 Annotation이라는 용어는 코드에 영향을 끼치는
  다양한 지시어 정도의 의미인 것 같다. 사실 의미를 따지기엔 너무
  다양하게 쓰여서 그냥 가져다 쓰기 나름인 것 같다.


[Python] <file:python.org>

[Swift] <file:swift.org>


개발자의 Comment
================

  프로그래밍 언어에 있어서 주석(comment)은 실행에 아무런 영향을 끼치지
  않고 오로지 코드 읽기를 위한 보조 설명이나 문서화에만 관여하는
  문법이다. 예를 들자면 [C 언어]를 기준으로 아래와 같은 식으로 표현한다.

  ,----
  | /* This function do something */
  | void do_something() {
  |   printf("Some! Thing!\n");  // this is something!
  | }
  `----

  여기서 `/* ... */' 로 표시한 것이 일반적인 [C 언어]식 주석이고, `//'
  로 시작하는 것이 C++에서 유래한 한 줄 짜리 주석 문법이다.

  이런 주석은 실제 실행에는 아무런 영향을 끼치지 않는다. 실제로 위
  코드에서 주석의 문법 자체만 그대로 놔두고 내용은 마음대로 고쳐도 빌드
  에러나 런타임 오류는 나지 않는다.


[C 언어] <file:c-language.org>


결론
====

  일반인에게 annotation은 문서에 첨부하는 보조 설명 용도의 주석이고,
  comment는 의견 혹은 댓글(?)이라는 의미로 가장 많이 쓰인다.

  개발자에게 annotation은 코드에 의미를 가지는 뭔가를 지시하거나
  알려주기 위한 특정한 문법을 의미하고, comment는 코드 실행에 영향은 안
  끼치면서 코드를 설명하기 위한 보조 설명이다.
</content>
</entry>
<entry>
<title>영어 노트</title>
<link href="https://seorenn.github.io/note/english-note.html"/>
<id>https://seorenn.github.io/note/english-note.html</id>
<updated>2020-07-01T00:08:50+09:00</updated>
<summary>개인적으로 작성하는 영어 노트</summary>
<content type="text">
이 글은 개인적인 필요에 의해서만 작성되는 영어 노트다.


the는 언제 왜 쓰는건가?
=======================

  보통은 누군과 대화하고 있을 때 주제나 공통된 대상에 붙이는 것이
  일반적이다.
        a dog 어쨌든 저쨌든 그냥 개 / the dog 지금 앞에 보이는 그
        개
  the는 상대를 특정할 수 있는 그 무엇인가를 표현할 때 자주 붙인다.
  다르게 표현하자면 대화의 주제나 대상이다.

  그런데 이것 말고도 쓰임세가 많아서 문제다.
        the sun / the moon
  유니크한 대상을 표현할 때 쓸 수 있다.

  하지만 유니크하면서도 붙이지 않는 경우가 있다.
        Korea
  나라를 적을 때 the를 붙이는 경우는 기억에 없는데 맞는 것 같다. 참
  영어는 귀찮다.

  그런데 the는 비교 용도로도 쓰인다.
        more / the more
  more 보다 더 많으면 the more 라고도 한다. 귀찮아 죽겠다 아주...

  그냥 표현에 익숙해지는 수밖에 없어보인다.


'must' VS 'have to'
===================

        have to??? 뭘 가진다고? 어이고 말세야
  have to와 must는 의미가 비슷하다. 뭐뭐 해야한다는 식의 의미다.

  다만 어감 상 must는 강제로 꼭 해야 한다는 그런 의미라면 have to는
  약간은 가벼운 개인의 스케쥴 같은 그런 느낌이다.

  반대 표현은 must not 그리고 do not have to 라고 한다.

  특이사항으로 must는 시제 변화가 없다. 과거나 미래라면 그냥 have to를
  쓰는 편이 좋을지도 모른다.


as if
=====

        만약에 뭐뭐한 것으로써... 아아... 저 멀리... 변태가...
  위에는 뭐 전혀 아니고, 그냥 '마치' 라고 번역하면 편하다.
        It seems as if I spend day and night at the office
  대충 번역하면 '마치 회사에서 올나잇 한 것 같다'?


차량 탑승 시 on과 in
====================

  버스나 비행기, 기차와 같은 대량(?) 운송 수단을 탔을 때는 on을 쓴다.
        You are on a bus
  근데 빌어먹을 자전거를 탈 때도 on 을 붙인다.

  승용차나 택시 등 개인용 운송수단을 탔을 때는 in을 쓴다.
        You are in a car
  트럭도 여기에 해당한다. 영어는 정말 귀찮다.


기타 짧은 표현 메모들
=====================

  get rid of
        '없애다, 치우다, 사라지게 하다'의 의미다. 더이상 필요없는 것을
        치우다는 의미와 가깝다.
  grounded
        감금되다. 외출금지 되다. (땅에 박혔다고 보면 되려나?)
  at a glance
        한눈에, 즉시. (glance는 흘낏 보다, 휙 보다 등의 의미)
  caveats
        가끔 문서 등에 이게 써 있으면 '경고' 혹은 '전제조건' 등을
        의미한다. 즉 주의하라는 의미다.
  no such thing as ()
        세상에 () 그런 건 없어.


영어 월
=======

  아직도 영어로 몇 월을 못 외우냐고? 응. 뭐 어쩌라고...
  - 1 January JAN
  - 2 Febrary FEB
  - 3 March MAR
  - 4 April APR
  - 5 May MAY
  - 6 June JUN
  - 7 July JUL
  - 8 August AUG
  - 9 September SEP
  - 10 October OCT
  - 11 November NOV
  - 12 December DEC


기타 단어들
===========

present vs current
~~~~~~~~~~~~~~~~~~

  present는 시간 상 현재를 의미한다. 예를 들어 present day 라고 하면
  현재 시각을 의미한다. '즉시' 라는 의미에 가깝다.

  비슷하지만 다른 current는 기간 내에서 현재 시점을 의미한다. 예를 들어
  current situtation 라고 말 그대로 현재 상황을 의미한다.

  따라서 동의어가 아니다. 섞어서 쓰면 혼동을 줄 수 있으니 조심하자.


주제별 글들
===========

  - [RSVP]
  - [Annotation VS Comment]


[RSVP] <file:rsvp.org>

[Annotation VS Comment] <file:annotation-vs-comment.org>
</content>
</entry>
<entry>
<title>Python으로 간단한 웹 서버 띄우기</title>
<link href="https://seorenn.github.io/note/python-simple-web-server.html"/>
<id>https://seorenn.github.io/note/python-simple-web-server.html</id>
<updated>2020-06-30T21:52:42+09:00</updated>
<summary>파이썬으로 디버깅 용도로 쓸 간단한 HTTP 웹 서버를 띄우는 방법을 알아보자</summary>
<content type="text">
이 글은 [Python]으로 간단한 웹 서버를 띄우는 방법을 정리한 글이다.
예제의 기준은 3.7 버전이며 2.x 같은 구 버전은... 이제는 잊자.

주의할 점은 이 서버는 개발용 혹은 디버그 용도라는 점이다. 즉 프로덕션
용도로 쓰기엔 기능과 속도 그리고 보안 모든 면에서 문제가 있을 수 있다.


[Python] <file:python.org>


http.server
===========

  아래 [CLI] 커맨드 한 줄이면 현재 디렉터리의 파일을 서빙하는 HTTP 웹
  서버를 띄울 수 있다.

  ,----
  | python -m http.server
  `----

  이후 웹 브라우저에서 `http://localhost:8000' 주소로 접속하면 파일
  목록이 보이거나 혹은 [HTML] 파일을 볼 수 있다.

  물론 몇 가지 옵션이 더 제공된다.

  ,----
  | python -m http.server 3000 --bind 127.0.0.1
  `----

  위의 예는 포트를 3000으로 바꾸고 바인딩 주소를 127.0.0.1로 설정하는
  예이다.

  현재 디렉터리가 아닌 다른 디렉터리를 루트로 삼고 싶다면 `--directory'
  옵션을 사용할 수 있다.

  ,----
  | python -m http.server --directory /foo/bar
  `----

  다양한 옵션이 있지만 사실 별 다른 옵션 없이 현재 디렉터리에 기본
  설정으로 띄우는 것만 해도 개발 용도로는 무리가 없는 것 같다.


[CLI] <file:cli.org>

[HTML] <file:html.org>


조금 더 자세하게
================

  위의 예는 [CLI]로 바로 실행시키는 예제인데, 당연하게도 이
  `http.server' 는 [Python]의 일반적인 모듈이기 때문에 코드를 작성해서
  실행시킬 수도 있다.

  ,----
  | from http.server import HTTPServer, SimpleHTTPRequestHandler
  | 
  | server = HTTPServer(('0.0.0.0', 8000), SimpleHTTPRequestHandler)
  | server.serve_forever()
  `----

  앞서 제일 처음 소개한 커맨드를 스크립트로 작성하면 이런 식이다.

  이 외에도 여러 모듈도 제공되니 궁금하다면 공식 문서를 잘 살펴보자.


[CLI] <file:cli.org>

[Python] <file:python.org>


외부 링크
=========

  - [http.server - HTTP servers]


[http.server - HTTP servers]
<https://docs.python.org/3/library/http.server.html>
</content>
</entry>
<entry>
<title>Python</title>
<link href="https://seorenn.github.io/note/python.html"/>
<id>https://seorenn.github.io/note/python.html</id>
<updated>2020-06-30T21:50:33+09:00</updated>
<summary>Python(파이썬)에 관한 간략한 설명 및 자료 정리</summary>
<content type="text">
파이썬(Python)은 네덜란드 출신의 귀도 반 로썸(Guide van Rossum)에 의해
탄생한 프로그래밍 언어다. 동적 타이핑을 사용하는 인터프리터 언어라는
점도 특징이지만, 역시 들여쓰기를 블록 구분으로 사용하는 것을 문법으로
강제하는 언어라는 점이 가장 큰 특징이다.


설치
====

  [macOS] 의 경우 [Homebrew] 를 통해 설치하거나 혹은 [pyenv] 로 쉽게
  설치할 수 있다.

  혹시 [Homebrew] 를 통해 설치했는데 python 커맨드가 시스템 파이썬을
  실행시킨다면 아래와 같이 경로를 추가 설정해서 시험해보자.
  ,----
  | export PATH="/usr/local/opt/python/libexec/bin:$PATH"
  `----
  이 설정은 포뮬러가 어떻게 바뀌느냐에 따라 바뀔 수도 있으니 참고만
  하자.


[macOS] <file:macos.org>

[Homebrew] <file:homebrew.org>

[pyenv] <file:pyenv.org>


버전 별 정리
============

  - [Python 3.8 업데이트 내역]


[Python 3.8 업데이트 내역] <file:python-3-8-updates.org>


주제별 내용
===========

  - [Python 딕셔너리 타입 정리]
  - [Python의 Bytes와 Byte Array]
  - [Python List Comprehension]
  - [Python 정규표현식]
  - [Python 예외 처리]
  - [Python으로 파일의 경로 및 목록 다루기]
  - [Python 3로 수동으로 옮겨가기]
  - [Python으로 간단한 웹 서버 띄우기]


[Python 딕셔너리 타입 정리] <file:python-dictionary.org>

[Python의 Bytes와 Byte Array] <file:python-bytes-and-bytearray.org>

[Python List Comprehension] <file:python-list-comprehension.org>

[Python 정규표현식] <file:python-regular-expression.org>

[Python 예외 처리] <file:python-exception-handling.org>

[Python으로 파일의 경로 및 목록 다루기] <file:python-file-dir-tips.org>

[Python 3로 수동으로 옮겨가기] <file:python3-manual-migration.org>

[Python으로 간단한 웹 서버 띄우기] <file:python-simple-web-server.org>


패키지 노트
===========

  - [bitstring(Python)]


[bitstring(Python)] <file:python-bitstring.org>


외부 링크
=========

  - [Python에 F-string 이라는 게 있었다?]
  - [Python 3 정적 타이핑 소개 및 소감(?)]
  - [Math to Code]: Numpy 수식 교육용 인터랙티브 자료. 엔지니어 대상이라
    퀴즈 해답을 코드를 입력하는 방식이다.
  - [Math as Code]: 수식을 코드로 어떻게 표현하는 지에 관한 설명의
    파이썬 버전


[Python에 F-string 이라는 게 있었다?] <https://seorenn.tistory.com/76>

[Python 3 정적 타이핑 소개 및 소감(?)] <https://seorenn.tistory.com/77>

[Math to Code] <https://mathtocode.com/>

[Math as Code]
<https://github.com/Jam3/math-as-code/blob/master/PYTHON-README.md>
</content>
</entry>
<entry>
<title>Javascript 스프레드 연산자</title>
<link href="https://seorenn.github.io/note/javascript-spreads-operator.html"/>
<id>https://seorenn.github.io/note/javascript-spreads-operator.html</id>
<updated>2020-06-30T02:26:30+09:00</updated>
<summary>자바스크립트의 스프레드 연산자(Spreads Operator)에 대해 알아보자</summary>
<content type="text">
이 글은 [Javascript]의 스프레드 연산자(Spreads Operator)에 대해 간략히
정리하는 글이다. 당연하겠지만 ES6(ES2015) 버전을 기준으로 한다.


[Javascript] <file:javascript.org>


스프레드(Spreads) 연산자
========================

  스프레드 혹은 전개 연산자는 `...' 으로 표기하며 이름처럼 펼치거나
  확산한다라는 의미로 동작한다. 말로는 참 이해 안 되는 말이다. 그냥
  예제를 보는 게 좋을 것 같다.

  ,----
  | let a1 = [1, 2, 3];
  | let a2 = [...a1, 4, 5, 6];
  `----

  위 코드에서 `a2' 는 `[1, 2, 3, 4, 5, 6]' 이 된다. 즉 `a1' 리스트의
  내용이 `a2' 내에 풀어져서 자연스럽게 합체(?)되었다. 이것이 바로
  스프레드의 정체성을 가장 잘 보여주는 예제같다.

  스프레드는 리스트 뿐만 아니라 오브젝트(Object)에서도 별 무리 없이 잘
  풀어준다.

  ,----
  | let o1 = {
  |   name: "James",
  |   age: 16
  | }
  | let o2 = {
  |   familyName: "Kim",
  |   ...o1
  | }
  `----

  이렇게 하면 `o2' 에는 `{ familyName: "Kim", name: "James", age: 16 }'
  이런 내용이 들어가게 된다. 따라서 오브젝트의 내용에 뭔가를 대량으로
  추가할 때 상당히 편하게 사용할 수 있는 문법이다.

  물론 반대 방향(?)의 활용도 가능하다.

  ,----
  | [a, b, ...others] = [1, 2, 3, 4, 5, 6]
  `----

  아마도 예상 가능하겠지만, 위 코드를 실행시키면 `others' 에는 `[3, 4,
  5, 6]' 이 들어간다.


함수 매개변수의 스프레드
========================

  스프레드의 이런 특징은 함수의 매개변수에서도 활용이 가능하다.

  ,----
  | function sixArgs(a, b, c, d, e, f) {
  |     // ...
  | }
  | 
  | let arr = [1, 2, 3, 4, 5, 6]
  | sixArgs(...arr);
  `----

  이렇게 하면 각 매개변수에 해당 배열의 값들이 알아서 펼쳐져서 들어간다.
  즉 `a' 에는 `1' 이, `b' 에는 `2' 가, 그리고 최종적으로 `f' 에는 `6' 이
  들어간다.

  물론 스프레드를 사용하는 위치를 임의로 정할 수도 있다.

  ,----
  | function someFunc(value, ...rest) {
  |     console.log(value);
  |     console.log(rest);
  | }
  `----
  위 함수를 `someFunc(1, 2, 3, 4, 5)' 로 호출한 경우 `value' 에는 `1'
  이, rest에는 `[2, 3, 4, 5]' 가 들어간다.

  참고로 이 경우 스프레드(Spreads)가 아니라 나머지 매개변수(Rest
  Parameter)라 불리는 것 같다.
</content>
</entry>
<entry>
<title>Javascript 화살표 함수</title>
<link href="https://seorenn.github.io/note/javascript-arrow-function.html"/>
<id>https://seorenn.github.io/note/javascript-arrow-function.html</id>
<updated>2020-06-30T00:49:24+09:00</updated>
<summary>자바스크립트의 화살표 함수의 소개와 함께 이와 관련된 글들</summary>
<content type="text">
[Javascript]에서는 축약된 동적 함수 혹은 [클로저] 형태로 쓸 수 있는
화살표 함수(Arrow Function) 문법을 제공한다. 이 글에서는 이 화살표
함수가 무엇인지 간단히 정리한다.


[Javascript] <file:javascript.org>

[클로저] <file:closure.org>


화살표 함수
===========

  화살표 함수 표현법은 `=>' 오퍼레이터를 사용하기 때문에 이런 이름이
  붙은 것 같다. 문법은 생략하고 일단 예제를 보자.

  ,----
  | let add = (a, b) => {
  |     return a + b
  | }
  `----

  위 코드는 아래와 동일하다고 볼 수 있다.

  ,----
  | let add = function(a, b) {
  |     return a + b
  | }
  `----

  참고로 위의 두 코드는 아래와 같이 더 단순하게 구현할 수도 있다.

  ,----
  | let add = (a, b) => a + b
  `----

  즉 단순한 식(expression)만 있을 경우 `return' 과 중괄호를 생략할 수
  있다.

  당연하게도 `function' 을 이용해 [클로저]를 구현하던 것을 화살표 함수로
  그대로 대체할 수 있다.

  ,----
  | setTimeout(() => {
  |   console.log('after a second...')
  | }, 1000)
  `----

  확실히 코드가 더 단축되기는 하는데 읽기가 좋은지는 잘 모르겠다.


[클로저] <file:closure.org>


식(expression) 표현법의 확장
============================

  위에서 언급했던 예를 다시 보자.

  ,----
  | (a, b) => a + b
  `----

  위 코드는 아래처럼 표현할 수도 있다.

  ,----
  | (a, b) => (a + b)
  `----

  괄호로 감싼 것이 뭔가 특별한가 생각할 수도 있는데, 좀 더 복잡한 식을
  표현하기 위해 괄호를 사용하는 것과 사실 별 차이는 없다. 다만 차이가
  있다면 아래와 같이 표현할 수도 있다는 점이 있다.

  ,----
  | (a, b) => (
  |     a + b
  | )
  `----

  이렇게 줄바꿈을 해서 여러 줄의 식을 구현할 경우 유용한 방식이다.

  만약 오브젝트를 리턴해야 한다면 어떻게 해야할까?

  ,----
  | (v1, v2) => {
  |     foo: v1,
  |     bar: v2,
  | }
  `----

  불행히도 이 코드는 틀렸다. 당연하게도 중괄호는 함수 본체를 구현할 때
  사용하는 문법으로 해석된다.

  그런데 이런 단순한 식으로 오브젝트(Object)를 리턴하는 경우에 괄호를
  이용할 수 있다.

  ,----
  | (v1, v2) => ({
  |     foo: v1,
  |     bar: v2,
  | })
  `----

  중괄호를 괄호로 감싸면 아주 간단하게 오브젝트를 리턴하는 화살표 함수를
  구현할 수 있다.
</content>
</entry>
<entry>
<title>CRUD</title>
<link href="https://seorenn.github.io/note/crud.html"/>
<id>https://seorenn.github.io/note/crud.html</id>
<updated>2020-06-29T14:48:24+09:00</updated>
<summary>CRUD란 무슨 의미일까?</summary>
<content type="text">
CRUD란 Create, Read, Update, Delete의 앞자리만을 따서 지은 합성어로 말
그대로 생성, 읽기, 수정, 삭제 기능 전체를 의미하는 단어다.

쉽게 말해서 DB나 혹은 DB와 연동되는 API의 기능 전반을 의미한다. 특정
기능의 CRUD를 만들었다는 말은 해당 레코드를 추가하거나 보거나 수정하거나
삭제하는 기능을 구현했다는 의미다.

DB입장에서 보자면 검색(Search)을 제외한 거의 모든 기능에 해당하기도 해서
기본적이면서도 가장 본질적인 기능을 의미한다고 볼 수 있다.
</content>
</entry>
<entry>
<title>Python의 Bytes와 Byte Array</title>
<link href="https://seorenn.github.io/note/python-bytes-and-bytearray.html"/>
<id>https://seorenn.github.io/note/python-bytes-and-bytearray.html</id>
<updated>2020-06-28T19:11:10+09:00</updated>
<summary>파이썬의 바이트와 바이트 배열 타입을 살펴보고 덤으로 한글과 바이트의 관계도 살펴보자</summary>
<content type="text">
이 글은 [Python]의 `bytes' 와 `bytearray' 타입을 간략히 정리하는 글이다.
사용된 예제는 3.7 이상의 버전에서 테스트되었다. 2.x 버전의 바이트 처리가
3.x에서 약간 바뀐 점도 있어서 2.x 버전에서는 예제가 오류가 날 가능성이
있다.


[Python] <file:python.org>


Bytes
=====

  `bytes' 타입은 이름처럼 바이트가 나열된 형태의 자료구조를 구현하는
  클래스다. 그런데 클래스를 직접 이용해서 생성하는 것 보다는 아래와 같은
  방식으로 가장 먼저 체험할 가능성이 높은 타입 같다.
  ,----
  | >>> bs = b'abcd'
  | >>> bs
  | b'abcd'
  | >>> type(bs)
  | <class 'bytes'>
  `----
  `b' 로 시작하는 문자열 표현을 사용했는데, `b' 의 의미는 `bytes' 로
  이해할 수 있다면 그다지 어려울 것이 없는 것 같다. 말 그대로
  4바이트짜리 바이트 버퍼가 생성되었다. 참고로 이렇게 바이트 버퍼를
  문자열로 표기하는 것을 binstring 이라고 부른다.

  물론 `bytes' 를 이용해 바로 생성하는 방법으로도 사용할 수 있다.
  ,----
  | >>> b = bytes(8)
  | >>> b
  | b'\x00\x00\x00\x00\x00\x00\x00\x00'
  `----
  생성자의 첫 매개변수는 바이트 버퍼의 바이트 카운트, 즉 사이즈다. 위의
  경우 8 바이트짜리 버퍼가 생성된다.

  안심스럽게(?) 생성된 버퍼는 모두 0으로 초기화되어 있는데, 불행히도 이
  `bytes' 타입은 수정이 불가능한 타입이다. 다르게 표현해서 Immutable
  타입이다. 그래서 0으로 초기화되어도 사실 별로 의미 없을지도 모른다.

  따라서 의미있는 바이트 버퍼를 만들 때는 아래처럼 튜플이나 리스트로
  실제 데이터를 표현해서 초기화할 수 있다.
  ,----
  | >>> bytes((1, 2, 3, 4))
  | b'\x01\x02\x03\x04'
  | >>> bytes([1, 2, 3, 4])
  | b'\x01\x02\x03\x04'
  `----
  그 외에 사용법은 리스트와 비슷하다.
  ,----
  | >>> b = bytes([1, 2, 3, 4])
  | >>> len(b)
  | 4
  | >>> b[2]
  | 3
  `----
  이 외에 리스트 슬라이스나 for 루프로 순환하기 등 리스트로 하던 행위를
  대충 비슷하게 할 수 있다.


Byte Array
==========

  `bytearray' 타입은 이름처럼 바이트 배열(Byte Array)을 구현하는
  클래스인데, `bytes' 가 수정이 불가능한 immutable 타입인 것에 반해 이
  타입은 요소 수정이 가능한 타입이다. 다르게 말해서 mutable bytes 처럼
  생각할 수도 있다.

  따라서 생성은 아마도 생성자를 통해서 데이터를 넘겨주면 될 것 같다.
  ,----
  | >>> ba = bytearray(b'abcd')
  | >>> ba
  | bytearray(b'abcd')
  `----
  예상대로 된다.

  자 그럼 mutable bytes라고 했으니 수정이 되는지도 보면 될 것 같다.
  ,----
  | >>> ba[0] = 'A'
  | Traceback (most recent call last):
  |   File "<stdin>", line 1, in <module>
  | TypeError: 'str' object cannot be interpreted as an integer
  `----
  왜 안되는가라고 생각할 수 있는데 `'A'' 는 [Python]의 문자열
  오브젝트다. 그리고 Byte Array는 이름처럼 바이트 단위로 액세스를 해야
  한다. 따라서 문자열 대신 한 바이트 수치를 넣는 방식이면 수정이 될 것
  같다.
  ,----
  | >>> ba[0] = 0x41
  | >>> ba
  | bytearray(b'Abcd')
  `----
  0x41 즉 16진수 41은 대문자 A의 아스키 코드이다. 그래서 첫 글자가
  대문자 A로 바뀌었다.

  물론 이런 경우 `ord()' 함수를 쓰는게 더 편할 수 있다.
  ,----
  | >>> ba[1] = ord('B')
  | >>> ba
  | bytearray(b'ABcd')
  `----
  당연하게 이 방법이 직관적이다.

  이 외에도 여러가지 방법으로 바이트 배열을 변조할 수 있다.
  ,----
  | >>> ba.append(ord('e'))
  | >>> ba
  | bytearray(b'ABcde')
  | >>> del(ba[4])
  | >>> ba
  | bytearray(b'ABcd')
  `----
  마치 리스트를 다루는 것과 비슷하게 쓸 수 있다. 예를 들어 슬라이스나
  for 루프로 순환하기 등등 말이다.


[Python] <file:python.org>


바이트를 문자열로 바꾸기
========================

  바이트 버퍼나 바이트 배열을 다시 문자열로 받을 수 있는지 살펴보자.
  ,----
  | >>> b = b'abcd'
  | >>> str(b)
  | "b'abcd'"
  `----
  아... 뭔가 되기는 하는데 지금 원하는 것은 저게 아니다. 그렇다면 어떻게
  해야 할까?

  사실 우리가 쓰는 문자열은 유니코드 문자를 사용한다. 그래서 바이트
  배열로 구성되는 C 문자열을 그대로 문자열로 변환하는 것은 이상한
  행위다.

  다행히도 해답은 있다. 이 경우 `bytes' 나 `bytearray' 를 decode하면
  다시 원래의 문자열을 얻을 수도 있다.
  ,----
  | >>> b.decode()
  | 'abcd'
  `----
  [Python] 3 버전에 들어서는 `encode()' 나 `decode()' 를 쓸 일이 많이
  줄어서 좋았는데 다시 보게 되어서 약간 슬프다. 하지만 이번 경우엔 어쩔
  수 없이 쓰는게 맞는 것 같다.


[Python] <file:python.org>


한글과 바이트
=============

  이제 한글을 쓰는 경우를 살펴보자. 한글도 binstring으로 표현하면 바로
  바이트 배열로 쓸 수 있을까?
  ,----
  | >>> b'한글'
  |   File "<stdin>", line 1
  | SyntaxError: bytes can only contain ASCII literal characters.
  `----
  불행히도 그렇지 않다. 우리가 입력한 문자의 인코딩을 알려주지 않으면
  바이트 버퍼로 바꿀 수 없다. 그럼 어떻게 해야할까?

  다행히도 이 경우를 위해 `encode()' 를 사용할 수 있다.
  ,----
  | >>> hbuf = '한글'.encode('utf-8')
  | >>> hbuf
  | b'\xed\x95\x9c\xea\xb8\x80'
  `----
  인코딩을 명확하게 UTF-8 이라고 알려주고 인코딩을 하면 자연스럽게
  바이트 버퍼가 튀어나오니 이걸 쓰면 된다.

  그렇다면 반대의 경우는 어떻게 해야할까? 이미 힌트는 주어졌다. 했던
  것의 반대 방법을 쓰면 된다.
  ,----
  | >>> hbuf.decode('utf-8')
  | '한글'
  `----
  Encode의 반대는 Decode니까 쉬운 문제였다.

  일단 한글 주제로 이야기하긴 했는데, 사실상 유니코드로 표현하는 모든
  문자에 해당하는 내용이다. 굳이 영어만 쓴다고 해도 바이트 단위로 작업을
  해야한다면 인코딩과 디코딩은 하는 편이 좋다.

  앞의 내용에서는 생략했지만 사실 `bytes' 는 생성자 자체에서 인코딩을
  지원한다.
  ,----
  | >>> bytes('한글', 'utf-8')
  | b'\xed\x95\x9c\xea\xb8\x80'
  `----
  이렇게 써도 된다는 이야기다.
</content>
</entry>
<entry>
<title>Python 딕셔너리 타입 정리</title>
<link href="https://seorenn.github.io/note/python-dictionary.html"/>
<id>https://seorenn.github.io/note/python-dictionary.html</id>
<updated>2020-06-27T14:57:39+09:00</updated>
<summary>파이썬의 사전형 혹은 딕셔너리 타입(Dictionary Type)의 생성과 수정 및 여러 변조 방법을 알아보자</summary>
<content type="text">
이 글은 [Python]의 딕셔너리 타입(Dictionary Type, 사전형)과 관련된
내용을 정리한다. 예제 코드는 3.7 버전에서만 돌려봤지만 아마도 2.x
버전에서도 별 문제 없이 실행 가능할거라 생각된다.


[Python] <file:python.org>


딕셔너리 타입
=============

  [Python]의 딕셔너리 타입(Dictionary Type)은 `dict' 라는 이름의 내장
  클래스로써, 하나 이상의 키를 이용해 각 키의 값을 읽거나 쓸 수 있는
  타입이며, 여러 데이터를 담을 수 있어서 일반적으로 콜렉션
  타입(Collection Type)의 한 종류로 분류된다.

  보통 이런 종류의 자료구조로 사전형이라 부르는 타입과 동일하거나 혹은
  해시맵(Hash Map), 해시테이블(Hash Table)등의 자료구조와 유사하다.


[Python] <file:python.org>


딕셔너리 인스턴스 생성
======================

  아래 명령으로 빈 딕셔너리를 생성할 수 있다.
  ,----
  | >>> d = {}
  `----
  중괄호는 [Python]에서 딕셔너리 타입을 정의할 때 주로 사용되기 때문에
  중괄호는 곧 딕셔너리라고 인식해도 크게 틀리진 않는다.

  이제 특정 키를 이용해 값을 쓸 수 있다.
  ,----
  | >>> d['key'] = 'value'
  | >>> d['other'] = 123
  | >>> d
  | {'key': 'value', 'other': 123}
  `----
  물론 한 번에 바로 생성할 수도 있다.
  ,----
  | >>> d = {'key': 'value', 'other': 123}
  | >>> d
  | {'key': 'value', 'other': 123}
  `----
  아예 `dict' 클래스의 생성자를 활용하는 방법도 있다.
  ,----
  | >>> d = dict(key='value', other=123)
  | >>> d
  | {'key': 'value', 'other': 123}
  `----
  매개변수로 튜플 리스트를 사용할 수도 있다.
  ,----
  | >>> d = dict([('key', 'value'), ('other', 123)])
  | >>> d
  | {'key': 'value', 'other': 123}
  `----
  이 외에도 다양한 방법이 있을 수 있다.


[Python] <file:python.org>


키 읽기, 쓰기, 수정, 삭제
=========================

  키의 값을 읽을 때는 배열 원소 참조하는 것과 비슷한 문법을 사용하지만
  인덱스 대신 키를 사용한다는 점이 다르다.
  ,----
  | >>> print(d['key'])
  | value
  `----
  만약 없는 키를 읽으려고 하면 `KeyError' 예외가 발생한다.
  ,----
  | >>> print(d['unknown'])
  | Traceback (most recent call last):
  |   File "<stdin>", line 1, in <module>
  | KeyError: 'unknown'
  `----
  굳이 예외처리를 하고 싶지 않다면 키가 없을 때의 기본 값을 지정할 수
  있는 `get()' 메서드를 활용해서 값을 읽는 것이 편하다.
  ,----
  | >>> print(d.get('key'))
  | value
  | >>> print(d.get('unknown', 'no key'))
  | no key
  | >>> print(d.get('another unknown'))
  | None
  `----
  `get()' 메서드의 두 번째 인자가 기본값이며 이 값이 지정되지 않은
  경우는 `None' 이 기본값이 된다.

  값을 쓰는 것은 제일 처음의 읽는 방법과 비슷하다.
  ,----
  | >>> d['a'] = 'aaa'
  | >>> d
  | {'key': 'value', 'other': 123, 'a': 'aaa'}
  `----
  하지만 `set()' 메서드는 별도로 없는 것 같다.

  값을 수정하는 것은 그냥 값을 쓰는 것과 동일하다.
  ,----
  | >>> d['a'] = 'aaaaa'
  | >>> d
  | {'key': 'value', 'other': 123, 'a': 'aaaaa'}
  `----
  키를 삭제하려면 평범하게(?) `del()' 을 쓸 수 있다.
  ,----
  | >>> del(d['a'])
  | >>> d
  | {'key': 'value', 'other': 123}
  `----


딕셔너리끼리 합치기
===================

  일반적인 방법으로 `update' 메서드를 활용할 수 있다.
  ,----
  | >>> a = {'a':1, 'aa': 2}
  | >>> b = {'b':3, 'bb': 4}
  | >>> a.update(b)
  | >>> a
  | {'a': 1, 'aa': 2, 'b': 3, 'bb': 4}
  `----
  `update()' 메서드는 원본을 변조하는 파괴적인(destructive) 방법이라
  병렬 처리 시 인스턴스의 레퍼런스가 다른 태스크에서도 공유된다면
  조심해서 사용해야 할 것 같다.

  이 외의 트릭으로 아래 방법이 있다.
  ,----
  | >>> a = {'a': 1, 'aa': 2}
  | >>> b = {'b': 3, 'bb': 4}
  | >>> {**a, **b}
  | {'a': 1, 'aa': 2, 'b': 3, 'bb': 4}
  `----
  Immutable 작업 스타일로 쓸 수가 있어서 병렬 처리 환경에서도 안심하고
  쓸 수 있을 것 같다.


딕셔너리에 다른 딕셔너리를 풀어 넣기
====================================

  딕셔너리를 생성할 때 다른 딕셔너리의 값들을 같이 가져가려면 `**' 를
  활용할 수 있다.
  ,----
  | >>> a = {'john': 100}
  | >>> b = {'james': 50, 'kim': 99}
  | >>> c = {'lee': 98, **a, **b}
  | >>> c
  | {'lee': 98, 'john': 100, 'james': 50, 'kim': 99}
  `----
  이건 사실 위의 합치기 두 번째 예제랑 다를 게 없다. 하지만 목적이 좀
  다르게 느껴저서 별도의 항목으로 분리했다.


순회하기
========

  보통은 아래처럼 모든 키의 리스트(혹은 리스트 제너레이터)를 돌려주는
  `keys()' 메서드를 이용해 모든 키의 값을 읽을 수 있다.
  ,----
  | >>> d = {'key': 'value', 'other': 123}
  | >>> for k in d.keys():
  | ...     print(f'{k} = {d.get(k)}')
  | ...
  | key = value
  | other = 123
  `----
  이 외에 값들만 순회하고자 한다면 `values()' 메서드를 이용할 수도 있다.
  하지만 그다지 쓸 일은 잘 없을 것 같다.


참고
====

  요즘은 왠만해선 딕셔너리나 해시테이블 등의 자료구조에서 키를 문자열
  형태로 사용하는 게 일반적이지만, 꼭 문자열만 키로 쓸 수 있는 것은
  아니다.
  ,----
  | >>> a = {1: 100, 2:200}
  | >>> a
  | {1: 100, 2: 200}
  | >>> a[1]
  | 100
  `----
  키를 정수로 지정하면 배열과 거의 같은 모습을 구경할 수 있기도 하다.

  물론 문자열이 아무래도 활용성이 좋으니 문자열 외의 타입을 키로
  사용하는 일은 흔하진 않을 것이다. 아마도...
</content>
</entry>
<entry>
<title>Python 3.8 업데이트 내역</title>
<link href="https://seorenn.github.io/note/python-3-8-updates.html"/>
<id>https://seorenn.github.io/note/python-3-8-updates.html</id>
<updated>2020-06-27T01:52:22+09:00</updated>
<summary>파이썬 3.8에서 바뀌거나 추가된 것들을 간략히 알아보자</summary>
<content type="text">
이 글은 [Python] 3.8의 업데이트 내역을 간략히 정리한다.


[Python] <file:python.org>


The Walrus 오퍼레이터
=====================

  `:=' 오퍼레이터가 추가되었다. 머리를 왼쪽으로 90도 눕혀서 보면
  눈(코?)과 긴 이빨이 꼭 바다코끼리 처럼 보이는데 그래서
  바다코끼리(Walrus) 오퍼레이터라고 불린다.

  이 오퍼레이터는 함수의 실행 결과가 있는 경우, 즉 `None' 이 아닌 값이
  반환된 경우 이를 변수에 받아서 바로 액세스할 수 있는 문법을 제공한다.
  ,----
  | if (result := some_work()):
  |     do_process(result)
  `----
  위 예제에서 `some_work()' 의 반환 값이 `None' 이 아니면 `if' 문 아래의
  블록에 진입한다. 그리고 `result' 라는 변수에 반환 값이 그대로
  전달되어서 사용할 수 있다. 물론 이 `result' 변수는 이 `if' 블록이
  끝나는 순간 사용할 수 없다.

  마치 [Swift]의 `if let' 구문과 용도가 비슷한데, 실제 활용도도 비슷한
  것 같다. 예를 들어 루프나 [Python List Comprehension] 등에서도 사용할
  수 있다.


[Swift] <file:swift.org>

[Python List Comprehension] <file:python-list-comprehension.org>


F-string 기능 추가
==================

  디버깅 용도로 변수의 값을 출력하기 위해 아래와 같은 경우를 사용할 수
  있다.
  ,----
  | print(f"some_var={some_var}")
  `----
  3.8부터는 위 코드를 아래처럼 축약해서 적을 수 있다.
  ,----
  | print(f"{some_var=}")
  `----
  많이 편해진 것 같다.


/ 오퍼레이터
============

  매개변수를 특징(?)을 분리하기 위해 `/' 오퍼레이터가 추가되었다. 예를
  들어 아래 코드의 경우
  ,----
  | def f(a, b, /, c, d, *, e, f):
  |     pass
  `----
  매개변수가 좀 독특하게 선언되어 있다.

  우선 처음의 `a', `b' 는 일반적인 매개변수다.

  그 다음은 `/' 와 `*' 사이에 매개변수가 위치하는데, 여기 안쪽은 보통
  함수의 매개변수 선언과 동일한 방식으로 사용할 수 있다는 표식이다.

  그런데 `*' 뒤쪽은 키워드 표기법만 사용 가능하다. 즉 필드 이름을 반드시
  표기해야 한다.

  그래서 위 함수는 아래처럼 호출할 수 있다.
  ,----
  | f(1, 2, 3, d=4, e=5, f=6)
  `----
  얼마나 쓰일지는 잘 모르겠다. 개인적으로는 필드 이름을 강제하는 것을
  선호하기 때문에 그렇게 느낄 수도 있다.
</content>
</entry>
<entry>
<title>Python으로 파일의 경로 및 목록 다루기</title>
<link href="https://seorenn.github.io/note/python-file-dir-tips.html"/>
<id>https://seorenn.github.io/note/python-file-dir-tips.html</id>
<updated>2020-06-27T00:34:02+09:00</updated>
<summary>파이썬으로 경로에서 파일명 얻기, 확장자 분리하기, 디렉터리 구분하기, 파일 디렉터리 목록 얻기 등</summary>
<content type="text">
이 글은 [Python]으로 파일 및 디렉토리의 경로(path)나 파일 목록 구하기와
관련된 내용을 정리한다. 딱히 이런 분류로 글을 쓰는 건 개인적으로 자주
사용하고 자주 찾게 되는 내용이라 그렇지 별 다른 구분이 있는 것은 아니다.


[Python] <file:python.org>


경로에서 파일명만 얻기
======================

  `os.path' 모듈의 `basename()' 함수를 사용하면 경로에서 파일명만
  문자열로 따로 얻을 수 있다.
  ,----
  | >>> import os
  | >>> os.path.basename('/foo/bar/test.txt')
  | 'test.txt'
  `----


경로에서 디렉터리만 얻기
========================

  `os.path' 모듈의 `dirname()' 함수를 사용하면 해당 경로에서 디렉터리
  부분만 문자열로 얻을 수 있다.
  ,----
  | >>> import os
  | >>> os.path.dirname('/foo/bar/test.txt')
  | '/foo/bar'
  `----


파일명에서 확장자 분리하기
==========================

  `os.path' 모듈의 `splitext()' 함수는 파일명에서 확장자를 분리하는
  용도로 사용할 수 있다. 함수 이름에 주의하자.
  ,----
  | >>> import os
  | >>> os.path.splitext('test.txt')
  | ('test', '.txt')
  `----
  `splitext' 는 파일명 뿐만이 아니라 경로(path)에서도 동작한다. 예를
  들어 `/foo/bar/text.txt' 를 입력할 경우 `/foo/bar/text' 와 `.txt' 로
  분리된다.


경로에서 디렉터리와 파일 분리하기
=================================

  이 경우에는 `os.path' 모듈의 `split()' 함수를 사용해보자.
  ,----
  | >>> import os
  | >>> os.path.split('/foo/bar/sample.txt')
  | ('/foo/bar', 'sample.txt')
  `----
  참고로 `os.path.split()' 함수는 경로에서 마지막 요소만을 분리해주는
  용도다. 그래서 상위 디렉터리를 구하는 용도로도 사용할 수 있다.
  ,----
  | >>> os.path.split('/foo/bar')
  | ('/foo', 'bar')
  `----


파일 혹은 디렉토리 구분하기
===========================

  `os.path' 모듈에 `isfile()' 과 `isdir()' 이라는 딱 적당한(?) 이름의
  함수가 제공된다.
  ,----
  | >>> import os
  | >>> os.path.isfile('/foo/bar/some/file.txt')
  | True
  | >>> os.path.isdir('/foo/bar/some/file.txt')
  | False
  `----


디렉터리 안의 파일 목록 얻기
============================

  여러 방법이 있겠지만 여기서는 `os' 모듈의 `listdir' 을 사용한 방법을
  보자.
  ,----
  | >>> import os
  | >>> os.listdir('.')
  | ['foo.a', 'bar.b', 'somedir', ...]
  `----


디렉터리 안의 모든 파일 및 디렉터리 목록 얻기
=============================================

  특정 디렉터리 안의 내용물을 서브 디렉터리까지 다 포함해서 목록을
  구할려면 여러 방법이 있겠지만 이번에는 [Python] 3.4 에서 추가된
  `pathlib' 모듈의 `Path' 클래스의 `rglob()' 메서드를 이용해보자.
  ,----
  | >>> from pathlib import Path
  | >>> list(Path("/foo/bar/dir").rglob("*"))
  | [PosixPath('/foo/bar/dir/a'), PosixPath('/foo/bar/dir/a/test.txt'), ...]
  `----
  `PosixPath' 라는 새로운 타입이 등장하는데 이름처럼 경로를 표기하는데
  적합한 타입이다. 이 타입은 별로 어려울 것 없이 `str()' 로 문자열로
  변환이 되니 익숙한 방법을 사용하면 된다.

  어쨌든 이런 식으로 해당 디렉터리 아래의 모든 파일과 디렉터리 목록을
  1차원 리스트로 가공된 결과를 얻을 수 있다.

  굳이 `list()' 를 이용해 리스트화를 한 이유는 결과를 바로 보기
  위함이다. 보통 이런 경우 generator가 리턴된 것이기 때문에 굳이
  `list()' 로 바로 풀어버릴 필요 없이 바로 for 루프를 돌면서 필요한
  처리를 하는 게 성능과 메모리 효율이 더 좋을 것이다.
  ,----
  | >>> for p in Path("/Users/seorenn/tmp/a").rglob("*"):
  | ...     print(p)
  | ...
  | /foo/bar/dir/a
  | /foo/bar/dir/a/test.txt
  | ...
  `----
  참고로 `rglob()' 의 파일 이름 패턴은 이 외의 다양한 패턴을 지원하므로
  궁금하다면 매뉴얼을 찾아보자.


[Python] <file:python.org>
</content>
</entry>
<entry>
<title>RSVP</title>
<link href="https://seorenn.github.io/note/rsvp.html"/>
<id>https://seorenn.github.io/note/rsvp.html</id>
<updated>2020-06-26T22:24:07+09:00</updated>
<summary>RSVP의 의미와 용도는 무엇일까</summary>
<content type="text">
어떤 행사의 소개 페이지를 보면서 RSVP라는 단어를 보게 되었다. 뭔가의
약자로 보이는 이 단어가 너무나 생소해서 의미를 찾아보게 되었다.


RSVP
====

        répondez s’il vous plaît
  RSVP는 영어가 아니라 프랑스어 약자다.

  발음을 정확히 옮기긴 어렵지만 '헤폰데 실 부 프레' 정도로 읽힌다.
  여기서 '실 부 프레'는 유명해서 많이들 아는 의미일텐데, 영어의
  'please'와 유사한 용도로 쓰인다. 즉 뭔가를 부탁한다는 의미다.

  그렇다면 나머지 단어, 즉 제일 처음의 'répondez' 만 알면 될 것 같은데
  쉽게 납득가는 단어가 있다. 바로 'respond'다.

  직역하자면 "응답을 알려주세요" 정도가 될 것 같다.


초대장
======

  RSVP는 주로 어떤 행사나 파티 등에 초대장을 보내면서 이 초대에
  참석할지를 묻는 용도로 사용되던 단어다. 초대장에 RSVP가 쓰여져 있다면
  참석할지 말지를 알려주어야 한다.

  응답으로 Yes 혹은 Decline 두 가지 선택지에서 선택할 수 있게 하는
  경우도 있지만, 체크박스 등으로 'regrets only' 라고 쓰인 경우 불참
  여부를 체크해 달라는 의미이므로 참석하려면 체크하지 않으면 된다.


지금도 그렇게 쓰나?
===================

  인터넷이 기본인 요즘의 행사에서 '초대'는 여러 다양한 방식으로 응할 수
  있기 때문에 딱히 정해진 형식은 없는 것 같다. 보통 RSVP라 쓰면 행사
  참여 의사를 요청하거나 전달하는 것 정도로 이해하면 될 것 같다.

  요즘은 RSVP보다는 Registration 정도가 비슷한 용도로 더 많이 쓰이는
  단어이지 않을까? 그냥 추측이다.
</content>
</entry>
<entry>
<title>Org Publish로 익스포트 자동화하기</title>
<link href="https://seorenn.github.io/note/org-publish.html"/>
<id>https://seorenn.github.io/note/org-publish.html</id>
<updated>2020-06-26T21:50:39+09:00</updated>
<summary>Org 문서들과 관련 파일들을 자동으로 익스포트해 주는 Org Publish의 설정방법과 사용법을 알아보자</summary>
<content type="text">
Org Publish는 [Emacs]에서 [Org Mode]로 작성된 .org 문서들로 정적
웹사이트를 만들 수 있게 자동화 해주는 도구다. 특정 디렉토리 안의 `.org'
파일들을 `.html' 파일로 익스포트 해서 원하는 디렉터리로 복사해 준다.
그리고 각종 [CSS]나 스크립트, 이미지 등의 파일도 자동으로 복사해 준다.


[Emacs] <file:emacs.org>

[Org Mode] <file:org-mode.org>

[CSS] <file:css.org>


시작하기
========

  설명을 시작하기에 앞서 아래와 같은 디렉터리에서 글을 쓴다고 가정하자.
  ,----
  | ~/org/
  |     static/
  |         style.css
  |     img/
  |         someimage.jpg
  |     index.org
  |     foobar.org
  |     ...
  `----
  위 구조는 `.org' 파일로 글을 쓸 `~/org' 디렉터리, [CSS]나 [Javascript]
  파일을 넣기 위핸 `~/org/static' 디렉터리, 그리고 이미지를 넣기 위핸
  `~/org/img' 디렉터리로 구성되어 있다고 치자.

  이제 위의 디렉터리 구조를 아래와 같은 디렉터리 구조로 익스포트 하는
  것을 목적으로 삼자.
  ,----
  | ~/web/
  |     static/
  |         style.css
  |     img/
  |         someimage.jpg
  |     index.html
  |     foobar.html
  |     ...
  `----
  `.org' 파일 확장자가 `.html' 로 바뀐 거 빼곤 이름과 배치가 동일하다.
  즉 이대로 원하는 서버에 올리면 그대로 정적 웹사이트가 서빙될 수 있는
  형태다.

  이제 이 목적에 맞게 Org Publish를 설정해보자.


[CSS] <file:css.org>

[Javascript] <file:javascript.org>


필요한 모듈들
=============

  Org Publish는 다행히도 별도로 설치할 필요가 없다. [Emacs]이맥스에 이미
  빌트인 되어있는 [Org Mode]의 모듈이기 때문이다. 다만 필요한 몇몇
  모듈은 자동으로 로딩되지 않기 때문에 명시적으로 로드해야 할 수도 있다.
  ,----
  | (require 'ox-publish)
  | (require 'ox-html)
  | (require 'ox-rss)
  `----
  참고로 마지막의 `ox-rss' 모듈은 RSS를 만들기 위한 것이 아니면 필요가
  없는데 나중에 필요할지도 몰라서 일단 넣어둔 상태다. 따라서 이 글에서는
  꼭 필요하진 않다.

  이제 본격적으로 설정 스크립트를 작성해보자.


[Emacs] <file:emacs.org>

[Org Mode] <file:org-mode.org>


기본 설정
=========

  Org Publish의 프로젝트 설정은 `org-publish-project-alist' 라는
  리스트로 대부분 설정할 수 있다. 아래는 위의 목적대로 작성한
  스크립트다.
  ,----
  | (setq org-publish-project-alist
  |       '(("doc"
  |          :base-directory "~/org"
  |          :base-extension "org"
  | 
  |          :publishing-directory "~/web/"
  | 
  |          :recursive t
  | 
  |          :with-toc nil
  |          :with-title t
  |          :with-date t
  |          :section-numbers nil
  |          :html-doctype "html5"
  |          :html-html5-fancy t
  |          :html-head-include-default-style nil
  |          :html-head-include-scripts nil
  |          :htmlized-source t)
  |         ("static"
  |          :base-directory "~/org/static"
  |          :base-extension "css\\|js\\|png\\|jpg\\|jpeg\\|gif"
  |          :publishing-directory "~/web/static"
  |          :recursive t
  |          :publishing-function org-publish-attachment)
  |         ("img"
  |          :base-directory "~/org/img"
  |          :base-extension "png\\|jpg\\|jpeg\\|gif"
  |          :publishing-directory "~/web/img"
  |          :recursive t
  |          :publishing-function org-publish-attachment)))
  `----
  위 설정에는 `doc', `static', `img' 의 세 가지 프로젝트가 정의되어
  있다. 일단 이름은 마음대로 지을 수 있지만 가급적 디렉터리 이름과
  동일하게 지었다.

  `doc' 프로젝트의 내용은 `.org' 파일들이 위치하는 디렉터리에 대한
  설정이다.
  - `base-extension' 에 명시된 확장자의 파일들을 `publishing-directory'
    에 익스포트한다.
  - `htmlized-source' 가 `nil' 이 아니기 때문에 익스포트는 [HTML]
    형식으로 한다.
  그 외에 여러 옵션이 있는데 이는 [Org Mode]의 Export 옵션 그 자체이기도
  하니 일단 생략한다.

  나머지 `static' 과 `img' 프로젝트의 내용은 특정한 확장자의 파일들을
  그대로 복사하도록 하기 위한 규칙이다. `publishing-function' 에 명시한
  `org-publish-attachment' 함수는 말 그대로 첨부용 파일을 그대로
  복사하는 용도다.


[HTML] <file:html.org>

[Org Mode] <file:org-mode.org>


Publish 해보기
==============

  이제 실제로 편찬(publish)을 해보자. 단순하게 `org-publish-all' 함수를
  실행시키면 된다.
  ,----
  | M-x org-publish-all
  `----
  참고로 [Doom Emacs]의 경우 `M-x' 대신 `SPC :' 단축키를 이용해도
  동일하다.

  어쨌거나 이 함수는 등록된 모든 프로젝트의 설정에 맞게 익스포트 하거나
  추가하거나 수정한 파일을 자동으로 복사한다.

  별 문제가 없다면 이 명령 만으로 목적대로 원하는 디렉터리에 [HTML]
  파일들과 함께 이미지 등의 정적 파일들도 복사된다.

  당연하겠지만 `org-publish-all' 함수나 혹은 아래에 소개할 `org-publish'
  함수는 새로 추가된 파일이나 변경된 파일만 작업을 수행한다.


[Doom Emacs] <file:doom-emacs.org>

[HTML] <file:html.org>


프로젝트 그룹화하기
===================

  `org-publish-all' 함수의 경우 등록된 모든 프로젝트를 대상으로 익스포트
  및 복사 작업을 수행한다. 하지만 만약 필요한 일부 프로젝트만 골라서
  익스포트 하려면 `org-publish' 함수를 이용할 수 있다. 예를 들어 아래
  커맨드를 실행시키면 `doc' 프로젝트만 publish 된다.
  ,----
  | (org-publish "doc")
  `----
  참고로 [Doom Emacs]의 경우는 `SPC ;' 를 누르면 [Emacs Lisp] 코드를
  즉석에서 입력해서 실행시킬 수 있는 프롬프트가 뜨니 여기서 위 코드를
  입력해보자.

  이렇게 개별 프로젝트를 출력할 수도 있는데, 프로젝트를 그룹으로 묶으면
  한 프로젝트의 연관 프로젝트도 모조리 자동으로 출력되게 할 수 있다.
  ,----
  | (setq org-publish-project-alist
  |       '(("doc"
  |          :base-directory "~/org"
  |          ;; ...
  |          )
  |         ("static"
  |          :base-directory "~/org/static"
  |          ;; ...
  |          )
  |         ("img"
  |          :base-directory "~/org/img"
  |          ;; ...
  |          )
  |         ("web" :components ("doc" "static" "img"))))
  `----
  생략한 코드가 많은데, 그냥 앞서 설정했던 내용에서 마지막 `web' 을
  정의하는 한 줄이 더 추가되었다고 치자. 이 코드의 의미는 `web'
  프로젝트는 `doc', `static', `img' 라는 세 가지 컴포넌트로 구성되어
  있다라는 것이다.

  이제 아래 커맨드 한 줄이면 `doc', `static', `img' 세 프로젝트 모두
  publish 된다.
  ,----
  | (org-publish "web")
  `----
  이런 식으로 그룹화를 할 수 있다. 하지만 꼭 할 필요 없이 위의
  `org-publish-all' 함수를 사용하는 게 더 편할 수 있다.


[Doom Emacs] <file:doom-emacs.org>

[Emacs Lisp] <file:emacs-lisp.org>


전부 새로 퍼블리시 하기
=======================

  굳이 그룹화를 소개한 것은 이 항목 때문이다. `org-publish-all' 함수는
  변경되거나 새로 추가된 파일만 업데이트를 하는데, 만약 설정을 바꾸는
  바람에 모든 파일을 다시 익스포트해야 한다면 이 함수가 좀 불만스러울 수
  있다.

  대신 이 경우 다음 명령어 한 방에 해결이 될 수도 있다.
  ,----
  | (org-publish "PROJECT_NAME" t)
  `----
  `org-publish' 함수의 두 번째 매개변수로 `nil' 이 아닌 값이 들어오게
  되면 파일의 변동 여부를 검사하지 않고 지정된 퍼블리시 함수를 이용해
  퍼블리시를 하게 된다.

  만약 프로젝트를 그룹으로 묶어뒀다면 이 커맨드 하나로 모든 것을 강제로
  새로 익스포트 할 수 있게 된다.

  물론 이 기능을 자주 쓸 일은 없을지도 모르고, 또 `.org' 파일을 [HTML]로
  출력하는 작업이 가장 자주 필요할거라 그룹화가 꼭 필요한 건 아니다.
  편한대로 사용하자.


[HTML] <file:html.org>


외부 링크
=========

  - [org-publish 공식 매뉴얼]


[org-publish 공식 매뉴얼] <https://orgmode.org/manual/Publishing.html>
</content>
</entry>
<entry>
<title>Org Mode</title>
<link href="https://seorenn.github.io/note/org-mode.html"/>
<id>https://seorenn.github.io/note/org-mode.html</id>
<updated>2020-06-26T21:50:03+09:00</updated>
<summary>Org Mode 에 대한 소개와 문법, 관련된 글들을 정리합니다.</summary>
<content type="text">
Org Mode 는 문서나 할 일, 프로젝트 관리 Agenda 등등 다양한 기능을
지원하는 텍스트 기반 시스템이자 [Emacs] 확장이다. 기본적으로 아웃라인
기반의 문서를 작성할 수 있는 Outline Mode 와 함께 다양한 기능의 마이너
모드들이 합쳐져서 만들어 진 [Emacs]의 유명한 [킬러 애플리케이션]이다.


[Emacs] <file:emacs.org>

[킬러 애플리케이션] <file:killer-application.org>


설정 팁
=======

링크 렌더링 하지 않기
~~~~~~~~~~~~~~~~~~~~~

  [Doom Emacs]나 [Spacemacs]의 기본 설정 상태에서는 링크가 자동으로
  렌더링 되어서 보기 편하게 바뀐다. 예를 들어 `[[https://foo.bar][link
  name]]' 같은 코드는 `link name' 으로만 표시된다. 하지만 읽기는 편한데
  이걸 수정해야 할 때는 좀 귀찮다. 이럴 때는 아래 설정으로 렌더링 되지
  않게 할 수 있다.
  ,----
  | (setq org-link-descriptive nil)
  `----
  이러면 링크 텍스트가 그대로 표시되기 때문에 수정 하기에는 좀 더
  편하다.


[Doom Emacs] <file:doom-emacs.org>

[Spacemacs] <file:spacemacs.org>


주제별 내용
===========

  - [Org 문법 정리]
  - [Org 테이블 스프레드시트]
  - [Org Publish로 익스포트 자동화하기]


[Org 문법 정리] <file:org-syntax.org>

[Org 테이블 스프레드시트] <file:org-table-spreadsheet.org>

[Org Publish로 익스포트 자동화하기] <file:org-publish.org>


Doom Emacs Snippets
===================

  아래는 [Doom Emacs]에서 Org Mode 용으로 제공되는 스니펫 중 일부다.
  아래 키워드를 입력하고 `TAB' 을 누르면 자동으로 블록 템플릿이
  완성된다.
  `<s'
        소스 블록(`BEGIN_SRC' ~ `END_SRC')
  `<q'
        인용 블록(`BEGIN_QUOTE' ~ `END_QUOTE')
  `<h'
        HTML 출력 블록(`BEGIN_EXPORT html' ~ `END_EXPORT')


[Doom Emacs] <file:doom-emacs.org>


팁
==

매크로(Macro)
~~~~~~~~~~~~~

  자주 사용하는 내용은 특정 키워드로 매크로(macro)를 만들어서 사용할 수
  있다. 매크로는 `org-export-global-macros' 리스트를 세팅해서 만들 수
  있다.
  ,----
  | (setq org-export-global-macros
  |       '(("copyright" . "* Copyright 1900 Fossil")
  |         ("oops" . "@@html:<b><i>OOPS!</i></b>@@")))
  `----
  위는 두 가지 매크로를 선언한 예이다. 이 매크로는 `{{{name}}}' 의
  문법으로 사용이 가능하다.

  예를 들어 org 문서에 `{{{copyright}}}' 라고 쓰게 되면 익스포트 시 해당
  내용이 뒤에 선언한 내용으로 치환되어서 익스포트 된다. 따라서 1단계
  제목(heading)이 해당 위치에 표시된다.

  그 아래의 매크로는 `{{{oops}}}' 라고 쓰게 되면 역시 뒤의 내용으로
  치환된 후 익스포트가 되는데, `@@html:...@@' 문법은 [HTML] 태그를 쓸 때
  사용하는 org 문법이다. 즉 위 매크로가 [HTML]로 익스포트 되면 굵고
  기울어진 "OOPS!" 를 볼 수 있다.


[HTML] <file:html.org>


스크롤이나 커서 이동이 너무 느릴 경우(Performance Issue)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  커서 이동 등이 너무 느릴 경우 줄 번호를 표시하는 모드를 꺼 보면 도움이
  될 수도 있다. [Doom Emacs]의 경우는 아래 코드로 줄 번호 모드를 끌 수
  있다.
  ,----
  | (doom-disable-line-numbers-h)
  `----
  개인적으로는 아래처럼 훅을 만들어 놓고 몇 가지 설정을 끄고 쓰고 있다.
  ,----
  | (defun seorenn-text-styles ()
  |   (doom-disable-line-numbers-h)
  |   (auto-fill-mode -1))
  | 
  | (add-hook! 'org-mode-hook #'seorenn-text-styles)
  `----
  재차 말하지만 위 코드는 [Doom Emacs] 상에서만 가능한 설정이다. 바닐라
  [Emacs]의 경우는 `linum-mode' 를 끄도록 `add-hook' 함수를 통해서 아마
  설정할 수 있을 것이다.

  줄 번호를 표시하는 게 왜 그렇게 CPU를 많이 먹는지 이해는 안 가지만
  어차피 org 문서를 다룰 때는 별로 필요 없기도 해서 문제는 없는 것 같다.


[Doom Emacs] <file:doom-emacs.org>

[Emacs] <file:emacs.org>


외부 링크
=========

  - [Org Mode 공식 홈페이지]


[Org Mode 공식 홈페이지] <https://orgmode.org>
</content>
</entry>
<entry>
<title>iOS, macOS 개발 관련 링크</title>
<link href="https://seorenn.github.io/note/ios-macos-dev-links.html"/>
<id>https://seorenn.github.io/note/ios-macos-dev-links.html</id>
<updated>2020-06-26T11:50:53+09:00</updated>
<summary>macOS, iOS, tvOS, iPadOS, watchOS 등등 애플 플랫폼 개발 및 리소스 링크 모음</summary>
<content type="text">
이 글은 [iOS], [macOS] 등등 [애플] 플랫폼 개발과 관련된 링크 모음집이다.


[iOS] <file:ios.org>

[macOS] <file:macos.org>

[애플] <file:apple.org>


Swift
=====

Swift 일반
~~~~~~~~~~

  - [Debugging with Swift Combine Framework]
  - [Create the Perfect UserDefaults Wrapper Using Property Wrapper]
  - [Property Wrapper, 무엇이 무엇을 감싸는가?]


[Debugging with Swift Combine Framework]
<https://www.vadimbulavin.com/debugging-with-combine-swift-framework/>

[Create the Perfect UserDefaults Wrapper Using Property Wrapper]
<https://swiftsenpai.com/swift/create-the-perfect-userdefaults-wrapper-using-property-wrapper/>

[Property Wrapper, 무엇이 무엇을 감싸는가?]
<https://www.notion.so/Property-Wrapper-5ee4a361e9d744fe9cb07b4dfa6f96ac>


SwiftUI
~~~~~~~

  - [Introducing SwiftUI]
  - [Understanding Property Wrappers in SwiftUI]
  - [SwiftUI Layout System]
  - [Inspecting the View Tree – Part 1: PreferenceKey]
  - [Inspecting the View Tree – Part 2: AnchorPreferences]
  - [Inspecting the View Tree – Part 3: Nested Views]
  - [Introducing Container views in SwiftUI]
  - [Modeling app state using Store objects in SwiftUI]
  - [Redux-like state container in SwiftUI. Basics.]
  - [Building forms with SwiftUI]
  - [View composition in SwiftUI]
  - [Reusing SwiftUI views across Apple platforms]
  - [Animations in SwiftUI]
  - [Gestures in SwiftUI]
  - [Building Bottom sheet in SwiftUI]
  - [Building Pager view in SwiftUI]
  - [Advanced SwiftUI Animations – Part 1: Paths]
  - [Advanced SwiftUI Animations – Part 2: GeometryEffect]
  - [Advanced SwiftUI Animations – Part 3: AnimatableModifier]
  - [Accessibility in SwiftUI]
  - [Dynamic Type in SwiftUI]
  - [Localization in SwiftUI]
  - [Building BarChart with Shape API in SwiftUI]
  - [Gradient in SwiftUI]
  - [GeometryReader to the Rescue]


[Introducing SwiftUI] <https://developer.apple.com/tutorials/swiftui/>

[Understanding Property Wrappers in SwiftUI]
<https://swiftwithmajid.com/2019/06/12/understanding-property-wrappers-in-swiftui/>

[SwiftUI Layout System]
<https://kean.github.io/post/swiftui-layout-system>

[Inspecting the View Tree – Part 1: PreferenceKey]
<https://swiftui-lab.com/communicating-with-the-view-tree-part-1/>

[Inspecting the View Tree – Part 2: AnchorPreferences]
<https://swiftui-lab.com/communicating-with-the-view-tree-part-2/>

[Inspecting the View Tree – Part 3: Nested Views]
<https://swiftui-lab.com/communicating-with-the-view-tree-part-3/>

[Introducing Container views in SwiftUI]
<https://swiftwithmajid.com/2019/07/31/introducing-container-views-in-swiftui/>

[Modeling app state using Store objects in SwiftUI]
<https://swiftwithmajid.com/2019/09/04/modeling-app-state-using-store-objects-in-swiftui/>

[Redux-like state container in SwiftUI. Basics.]
<https://swiftwithmajid.com/2019/09/18/redux-like-state-container-in-swiftui/>

[Building forms with SwiftUI]
<https://swiftwithmajid.com/2019/06/19/building-forms-with-swiftui/>

[View composition in SwiftUI]
<https://swiftwithmajid.com/2019/10/30/view-composition-in-swiftui/>

[Reusing SwiftUI views across Apple platforms]
<https://swiftwithmajid.com/2019/10/23/reusing-swiftui-views-across-apple-platforms/>

[Animations in SwiftUI]
<https://swiftwithmajid.com/2019/06/26/animations-in-swiftui/>

[Gestures in SwiftUI]
<https://swiftwithmajid.com/2019/07/10/gestures-in-swiftui/>

[Building Bottom sheet in SwiftUI]
<https://swiftwithmajid.com/2019/12/11/building-bottom-sheet-in-swiftui/>

[Building Pager view in SwiftUI]
<https://swiftwithmajid.com/2019/12/25/building-pager-view-in-swiftui/>

[Advanced SwiftUI Animations – Part 1: Paths]
<https://swiftui-lab.com/swiftui-animations-part1/>

[Advanced SwiftUI Animations – Part 2: GeometryEffect]
<https://swiftui-lab.com/swiftui-animations-part2/>

[Advanced SwiftUI Animations – Part 3: AnimatableModifier]
<https://swiftui-lab.com/swiftui-animations-part3/>

[Accessibility in SwiftUI]
<https://swiftwithmajid.com/2019/09/10/accessibility-in-swiftui/>

[Dynamic Type in SwiftUI]
<https://swiftwithmajid.com/2019/10/09/dynamic-type-in-swiftui/>

[Localization in SwiftUI]
<https://swiftwithmajid.com/2019/10/16/localization-in-swiftui/>

[Building BarChart with Shape API in SwiftUI]
<https://swiftwithmajid.com/2019/08/14/building-barchart-with-shape-api-in-swiftui/>

[Gradient in SwiftUI]
<https://swiftwithmajid.com/2019/11/13/gradient-in-swiftui/>

[GeometryReader to the Rescue]
<https://swiftui-lab.com/geometryreader-to-the-rescue/>


애플 플랫폼 공통
================

Combine Framework
~~~~~~~~~~~~~~~~~

  - [Combine Framework in Swift]


[Combine Framework in Swift]
<https://medium.com/flawless-app-stories/combine-framework-in-swift-b730ccde131>


Core Data Framework
~~~~~~~~~~~~~~~~~~~

  - [Predicates in Swift]: `NSPredicate' 가이드 글


[Predicates in Swift]
<https://www.swiftbysundell.com/articles/predicates-in-swift/>


기타
~~~~

  - [Sign in with Apple, Part 1: Apps]: 앱 쪽에서 애플 인증을 어떻게
    구현하는지에 관한 글
  - [Sign in with Apple, Part 2: Private Email Relay Service]: 이메일
    숨기기
  - [iOS 코드 서명에 대해서]: 애플의 개발자 인증서나 프로비저닝을 분석한
    글


[Sign in with Apple, Part 1: Apps]
<https://sarunw.com/posts/sign-in-with-apple-1/>

[Sign in with Apple, Part 2: Private Email Relay Service]
<https://sarunw.com/posts/sign-in-with-apple-2/>

[iOS 코드 서명에 대해서]
<https://engineering.linecorp.com/ko/blog/ios-code-signing/?fbclid=IwAR1I2SIo6YNQGwCGNy5N64viCyQ4PiWm2-8pd-v-rp1aXpjJ9flP19rNBdg>


iOS
===

  - [iOS 13에서 다크 모드 지원하기 (Supporting Dark Mode)]
  - [iOS 14: IDFA 시대가 저물어 갑니다. 어떻게 대처할 수 있을까요?]


[iOS 13에서 다크 모드 지원하기 (Supporting Dark Mode)]
<https://mildwhale.github.io/2019-12-27-iOS-supporting-dark-mode/>

[iOS 14: IDFA 시대가 저물어 갑니다. 어떻게 대처할 수 있을까요?]
<https://singularkorea.github.io/2020-06-25/ios14-idfa-limit-ad-tracking-skadnetwork-wwdc-privacy-update>


Xcode
=====

  - [Xcode Instruments usage to improve app performance]: 타임
    프로파일러로 앱 퍼포먼스를 측정하고 개선하는 방법에 관한 간략한
    가이드.
  - [Gedatsu provide readable format about AutoLayout error console
    log]: Auto Layout의 콘솔 에러 로그를 좀 더 보기 편하게 출력 해주는
    코드. 안타깝게도 [Xcode] 플러그인은 아니지만 특정 상황에선 도움이 될
    듯 하다.
  - [Why Failure, Auto Layout?]: 위와 비슷하게 Auto Layout 콘솔 에러
    로그를 붙여 넣으면 좀 더 보기 편하게 바꿔서 보여 주는 사이트.


[Xcode Instruments usage to improve app performance]
<https://www.avanderlee.com/debugging/xcode-instruments-time-profiler/>

[Gedatsu provide readable format about AutoLayout error console log]
<https://github.com/bannzai/Gedatsu>

[Xcode] <file:xcode.org>

[Why Failure, Auto Layout?] <https://www.wtfautolayout.com>


앱스토어(Appstore)
==================

  - [Screenshot specifications]: 기기별 스크린샷 사이즈


[Screenshot specifications]
<https://help.apple.com/app-store-connect/#/devd274dd925>


오디오(Audio)
=============

  - <https://github.com/mixedinkey-opensource/MIKMIDI>: 미디(MIDI)
    라이브러리
</content>
</entry>
<entry>
<title>Org 테이블 스프레드시트</title>
<link href="https://seorenn.github.io/note/org-table-spreadsheet.html"/>
<id>https://seorenn.github.io/note/org-table-spreadsheet.html</id>
<updated>2020-06-26T01:08:16+09:00</updated>
<summary>Org Mode의 테이블의 스프레드시트 기능을 사용해보자</summary>
<content type="text">
[Org Mode]의 테이블은 간단한 스프레드시트(Spreadsheet) 기능을 제공한다.
테이블의 각 셀을 이용해 계산을 하는 것 등인데 마치 엑셀이나 Numbers,
구글 독스에서 제공하는 스프레드시트(Spreadsheet)와 유사하다. 사용법이 좀
어렵긴 하지만 그래도 재미있으니 한번 살펴보자.

참고로 이 글에서 언급하는 단축키는 [Doom Emacs] 기준이다. 물론 일부
단축키는 바닐라 [Emacs]와 동일할 수도 있다.


[Org Mode] <file:org-mode.org>

[Doom Emacs] <file:doom-emacs.org>

[Emacs] <file:emacs.org>


테이블
======

  일단 아래와 같은 테이블을 만들었다고 가정해보자.
  ,----
  | | Kind  | Price | Ideal | Earning |
  | |-------+-------+-------+---------|
  | | Book  |   100 |    99 |         |
  | | Apple |   256 |    30 |         |
  | | Coke  |     4 |     9 |         |
  | |-------+-------+-------+---------|
  | |       |       |       |         |
  `----
  위 테이블을 이용해 계속 살펴보자.


셀 정보 확인하기
================

  스프레드시트에서는 행과 열에 고유번호가 있듯이 테이블에도 고요 번호
  시스템이 있다.

  우선 커서를 아래 `[]' 위치에 놨다고 가정하자.

  ,----
  | | Kind  | Price | Ideal | Earning |
  | |-------+-------+-------+---------|
  | | Book  |   100 |    99 |      [] |
  | | Apple |   256 |    30 |         |
  | | Coke  |     4 |     9 |         |
  | |-------+-------+-------+---------|
  | |       |       |       |         |
  `----
  커서 위치의 셀 주소(?)를 파악하기 위해 `C-c ?' 혹은 `SPC m b h' 키를
  눌러보면 하단 미니 버퍼에 커서가 있는 위치의 주소를 표시해준다.
  ,----
  | line @2, col $4, ref @2$4 or D2
  `----
  여기서 `@2$4' 라는 값이 커서가 위치한 셀의 위치를 한 번에 나타내는 셀
  주소다. 복잡하지만 이런 표현 방법을 알아야 이후의 내용을 진행할 수
  있다.

  셀의 고유번호를 확인하는 다른 방법도 알아보자. `C-c }' 키를 누르면
  테이블 헤더에 주소 정보가 토글된다.
  ,----
  |    1| Kind  | Price | Ideal | Earning |
  | I*1 |$1-----+$2-----+$3-----+$4-------|
  |    2| Book  |   100 |    99 |      [] |
  |    3| Apple |   256 |    30 |         |
  |    4| Coke  |     4 |     9 |         |
  | I*2 |$1-----+$2-----+$3-----+$4-------|
  |    5|       |       |       |         |
  `----
  이 정보를 통해서 $1부터 $4까지 표시되는 것이 칼럼(행, Column) 번호이고
  골뱅이가 로우(열, Row) 번호임을 유추할 수 있다.


Lisp 함수 실행시켜 보기
=======================

  위의 마지막 표에서 커서가 위치한 곳인 `[]' 위치에서 아래와 같은 내용을
  입력해보자.
  ,----
  | :='(- @2$3 $2$2);N
  `----
  위 텍스트를 입력하고 끝에서 `TAB' 키를 눌러주면 뭔가 변화가 생긴다.
  ,----
  | | Kind  | Price | Ideal | Earning            |
  | |-------+-------+-------+--------------------|
  | | Book  |   100 |    99 | -1                 |
  | | Apple |   256 |    30 |                    |
  | | Coke  |     4 |     9 |                    |
  | |-------+-------+-------+--------------------|
  | |       |       |       |                    |
  | #+TBLFM: @2$4='(- @2$3 @2$2);N
  `----
  커서가 있던 위치에 `-1' 이라는 값이 찍힌 것을 볼 수 있다. 즉 위에서
  입력한 코드는 3번 칼럼의 값($3)에서 2번 컬럼의 값($2)을 빼라는
  의미이고 그래서 커서 위치에 그 결과인 -1 이 찍힌 것이다.

  그렇다면 해당 코드의 의미를 이렇게 이해할 수 있다:
  - `:=' 은 이 셀에는 이후에 나오는 내용으로 치환시킨다는 의미다.
  - `'' 는 Lisp의 quote 함수다.
  - `(- @2$3 @2$2)' 는 Lisp 코드로 2열 3행의 값에서 2열 2행의 값을
    뺀다는 의미다. 제일 앞의 `-' 가 바로 빼기 함수다.
  - `;N' 은 Lisp 코드의 끝을 의미한다.
  몇몇 내용은 아마도 [Emacs Lisp]을 좀 알아야 이해가 될 것 같다.

  그 외에 표의 하단에 아래와 같은 특수한 내용이 추가되어 있는 것이
  보인다.
  ,----
  | #+TBLFM: @2$4='(- @2$3 @2$2);N
  `----
  `#+' 로 시작하는 표기는 [Org Mode] 문서에서 프로퍼티를 표현할 때
  사용하는 기호다. 아마도 방금 입력했던 식을 다르게 표시한 것으로
  유추된다.

  그렇다면 이 `#+` 부분을 약간 고치면 아마 식의 내용이 자동으로 바뀔 것
  같다. TBLFM의 내용을 아래처럼 고쳐보자.
  ,----
  | #+TBLFM: $4='(- $3 $2);N
  `----
  수정한 뒤에는 `C-c C-c' 키를 눌러야 반영된다. 그러면 아래처럼 내용이
  바뀐다.
  ,----
  | | Kind  | Price | Ideal | Earning |
  | |-------+-------+-------+---------|
  | | Book  |   100 |    99 |      -1 |
  | | Apple |   256 |    30 |    -226 |
  | | Coke  |     4 |     9 |       5 |
  | |-------+-------+-------+---------|
  | |       |       |       |       0 |
  | #+TBLFM: $4='(- $3 $2);N
  `----
  4행의 값은 3행 빼기 2행의 값이다 라는 것을 정의했다. 이제 자동으로
  입력된 값 외의 다른 값을 수정하면 제일 오른쪽 행의 값이 자동으로
  바뀐다. 그야말로 엑셀 같은 스프레드시트가 되었다. 불행히도 마지막 열
  까지 데이터가 입력되어 버린 것은 좀 이상하긴 하지만...


[Emacs Lisp] <file:emacs-lisp.org>

[Org Mode] <file:org-mode.org>


사칙연산 사용해보기
===================

  이제 Lisp 코드 말고 `calc' 를 통해 제공되는 계산기 기능을 써보자. 앞의
  내용과 비슷한 기능을 시험해 보기 위해 다시 테이블을 처음의 모양으로
  리셋시켰다.
  ,----
  | | Kind  | Price | Ideal | Earning |
  | |-------+-------+-------+---------|
  | | Book  |   100 |    99 |      [] |
  | | Apple |   256 |    30 |         |
  | | Coke  |     4 |     9 |         |
  | |-------+-------+-------+---------|
  | |       |       |       |         |
  `----
  커서 위치도 여전히 `[]' 로 표시한 부분인 Earning 칼럼의 첫 로우에
  있다. 이 위치에서 이제 아래와 같은 내용을 입력해보자.
  ,----
  | =$3-$2
  `----
  내용이 아까 보다는 단순하다. 어쨌든 입력을 하고 `TAB' 키를 누르는 순간
  비슷하게 아래와 같이 표시된다.
  ,----
  | | Kind  | Price | Ideal | Earning |
  | |-------+-------+-------+---------|
  | | Book  |   100 |    99 |      -1 |
  | | Apple |   256 |    30 |         |
  | | Coke  |     4 |     9 |         |
  | |-------+-------+-------+---------|
  | |       |       |       |         |
  | #+TBLFM: $4=$3-$2
  `----
  뭔가 더 쉽고 직관적인 문법의 명령어를 썼는데 결과는 아까와 비슷해
  보인다. 하지만 여기서 끝이 아니다.

  이제 살짝 마법을 써보자. 하단의 `#+TBLFM' 쪽으로 커서를 가져한 후 `C-c
  C-c' 키를 눌러보자.
  ,----
  | | Kind  | Price | Ideal | Earning |
  | |-------+-------+-------+---------|
  | | Book  |   100 |    99 |      -1 |
  | | Apple |   256 |    30 |    -226 |
  | | Coke  |     4 |     9 |       5 |
  | |-------+-------+-------+---------|
  | |       |       |       |       0 |
  | #+TBLFM: $4=$3-$2
  `----
  갑자기 자동으로 계산되는 영역이 늘었다. Earning 칼럼 전체에 데이터가
  자동으로 계산되어 들어갔다.

  입력한 명령어의 차이에서 `:' 오퍼레이터 존재의 의미가 이해가 갈 것
  같다. `:=' 오퍼레이터는 현재 셀에만 함수를 적용한다는 의미이고, `='
  오퍼레이터는 이 행이나 열 전체에 해당 함수를 적용한다는 의미일 것
  같다.

  비록 가장 아래쪽에 이상한 데이터가 하나 들어가긴 했지만...


합계 구하기
===========

  이제 Price와 Ideal 수치 합계를 한번 계산해보자. 제일 아래의 빈 로우에
  값을 채워 넣을 예정이다. 여전히 커서는 `[]' 로 표시한 위치에 있다고
  가정하자.
  ,----
  | | Kind  | Price | Ideal | Earning |
  | |-------+-------+-------+---------|
  | | Book  |   100 |    99 |      -1 |
  | | Apple |   256 |    30 |    -226 |
  | | Coke  |     4 |     9 |       5 |
  | |-------+-------+-------+---------|
  | |       |    [] |       |       0 |
  | #+TBLFM: $4=$3-$2
  `----
  이번엔 조금 다른 방법을 써서 편집해보자. `SPC m b e' 키를 누르면
  하단에 별도의 버퍼가 열리면서 여기에 해당 셀에 입력할 값을 별도로
  입력할 수 있다. 이 특수 버퍼에 아래와 같은 내용을 입력해보자.
  ,----
  | :=vsum(@2$2..@4$2)
  `----
  미니버퍼에 잘 표시가 되어있지만 위의 것을 입력한 후 `C-c C-c' 키를
  눌러야만 입력한 내용이 셀에 반영된다. 뭐... 수동으로 입력하는 거랑
  별반 차이는 없겠지만 말이다.

  이제 할 일은 입력된 내용 위에서 `TAB' 키를 눌러보는 것이다.
  ,----
  | | Kind  | Price | Ideal | Earning |
  | |-------+-------+-------+---------|
  | | Book  |   100 |    99 |      -1 |
  | | Apple |   256 |    30 |    -226 |
  | | Coke  |     4 |     9 |       5 |
  | |-------+-------+-------+---------|
  | |       |   360 |       |       0 |
  | #+TBLFM: $4=$3-$2::@5$2=vsum(@2$2..@4$2)
  `----
  아래에 Price 합계가 표시되었다. 그리고 제일 하단에 TBLFM 항목에도 방금
  입력한 것과 비슷한 명령이 추가되었다.

  입력했던 내용 자체는 앞서 살펴본 것과 비슷하다. 다만 `vsum' 함수가
  특별한데, 이 함수는 지정된 범위 내의 데이터를 합하기 위한 calc
  패키지의 함수다.

  이제 남은 빈 곳도 채우기 위해 직접 TBLFM 코드를 수동으로 수정해보자.
  ,----
  | #+TBLFM: $4=$3-$2::@5=vsum(@2..@4)
  `----
  `vsum' 입력 인자에서 모든 행을 대상으로 하도록 수정했다. 이제 다
  고쳤으니 `C-c C-c' 를 눌러보자.
  ,----
  | | Kind                | Price | Ideal | Earning |
  | |---------------------+-------+-------+---------|
  | | Book                |   100 |    99 |      -1 |
  | | Apple               |   256 |    30 |    -226 |
  | | Coke                |     4 |     9 |       5 |
  | |---------------------+-------+-------+---------|
  | | Book + Apple + Coke |   360 |   138 |    -222 |
  | #+TBLFM: $4=$3-$2::@5=vsum(@2..@4)
  `----
  뭔가 다 채워지긴 했는데 이상하다.🤦


계산 영역 제한하기
==================

  위 결과에서 좌측 하단의 이상한 것(?)을 지워보자. 방금 명령으로
  입력되어 버린 모든 내용을 초기화하기 위해 제일 아래 로우 각 셀의
  내용을 수동으로 다 지웠다.

  그리고 TBLFM의 가장 마지막 항목을 아래처럼 고쳐봤다.
  ,----
  | #+TBLFM: $4=$3-$2::@5$2..@5$4=vsum(@2..@4)
  `----
  그리고 TBLFM 위에서 `C-c C-c' 를 눌러보자.
  ,----
  | | Kind  | Price | Ideal | Earning |
  | |-------+-------+-------+---------|
  | | Book  |   100 |    99 |      -1 |
  | | Apple |   256 |    30 |    -226 |
  | | Coke  |     4 |     9 |       5 |
  | |-------+-------+-------+---------|
  | |       |   360 |   138 |    -222 |
  | #+TBLFM: $4=$3-$2::@5$2..@5$4=vsum(@2..@4)
  `----
  이상한 `Book + Apple + Coke' 라는 이상한 데이터가 사라졌다.

  원리는 간단하다. 위에서 사용한 코드는 값이 들어가는 부분을 영역으로
  표현했다는 점을 잘 보자. `@5$2..@5$4' 까지만 vsum의 결과를
  적용하겠다는 의미로 사용했다.

  이상한 경고 메시지가 뜨긴 하는데 뭐 잘 되었으니 무시하자.😏

  어쨌거나 이제 우리는 완벽한(?) 테이블 스프레드시트를 하나 만들었다. 참
  먼 길이었다. 역시 구글 스프레드시트나 Numbers를 쓰는게 현명할 것 같다.


calc 함수 목록
==============

  아래 함수는 스프레드시트 연산에 사용할 수 있는 다양한 함수들이다. 모든
  것을 정리한 것은 아니고 일단 정보를 구한 것만 정리한다.
  - `exp(c)' 지수(exponential)
  - `log(c)' log
  - `log10(c)' log10
  - `sqrt(c)' 루트(SQRT, Square-Root)
  - `vcor(v1, v2)' 상관계수(correlation)
  - `vcount(v)' 개수
  - `vcov(v1, v2)' 공분산(covariance)
  - `vlen(v)' 길이(length)
  - `vmax(v)' 최댓값(maximum)
  - `vmean(v)' 평균(average)
  - `vmedian(v)' 중간값
  - `vmin(v)' 최솟값(minimum)
  - `vprod(v)' 곱(product)
  - `vsdev(v)' 표준편차(standard deviation)
  - `vsum(v)' 합계
  - `vvar(v)' 분산(variance)


외부 링크
=========

  - [Org as a spreadsheet system: a short introduction]


[Org as a spreadsheet system: a short introduction]
<https://orgmode.org/worg/org-tutorials/org-spreadsheet-intro.html>
</content>
</entry>
<entry>
<title>Org 문법 정리</title>
<link href="https://seorenn.github.io/note/org-syntax.html"/>
<id>https://seorenn.github.io/note/org-syntax.html</id>
<updated>2020-06-26T00:58:09+09:00</updated>
<summary>Org Mode의 마크업 문법 일부를 정리하는 글</summary>
<content type="text">
이 글은 [Org Mode]의 마크업 문법 중 개인적으로 사용하는 것들을 정리한다.


[Org Mode] <file:org-mode.org>


헤더
====

  헤더에는 제목을 비롯하여 문서의 여러 프로퍼티를 정의할 수 있다.
  `#+TITLE: Title Text'
        문서의 제목이다. 거의 필수라고 생각하자.
  `#+DESCRIPTION: Description Text'
        문서의 핵심을 정리하는 내용이다. 익스포트 시 Meta 태그의
        description 항목으로도 출력 된다.
  `#+KEYWORDS: foo, bar, ...'
        문서의 핵심 단어를 정리한다. 익스포트 시 Meta 태그의 keywords
        항목으로 출력 된다.
  `#+OPTIONS: ...'
        문서의 다양한 옵션을 줄 수 있다. 예를 들어 `toc:2' 라는 옵션을
        주게 될 경우 익스포트 시 목차(Table of Contents)를 2레벨
        헤드라인 까지 정리한다.
  `#+FILETAGS: :foo:bar:'
        현재 파일에 foo와 bar라는 태그를 정의한다.
  `#+DATE: 2020-04-20'
        작성된 날짜와 시각을 기입할 수 있다.


제목줄(Headline)
================

  제목줄은 아래와 같이 여러 레벨로 쓸 수 있다.
  - `* Heading 1'
  - `** Heading 2'
  - `*** Heading 3'
  제한은 없으므로 더 깊은 레벨도 쓸 수 있지만 적당히 쓰는 편이 간결한
  문서를 만드는 데 중요한 것 같다.


링크(Link)
==========

  링크는 보통 아래처럼 쓴다.
  `[[URL]]'
        단순한 하이퍼 링크
  `[[URL][Name]]'
        특정 이름으로 표시되는 하이퍼 링크
  당연하지만 링크는 [HTML]로 익스포트 시 알아서 `A' 태그로 하이퍼링크가
  걸린다.

  로컬 링크나 org 파일 링크를 직접 거는 경우라면 file 형식을 붙여주자.
  `[[file:somefile.org]]'
        특정 파일로 링크 걸기
  `[[file:foobar.org][Foo Bar]]'
        특정 파일 링크를 특정 이름으로 표시하기
  이 경우 [HTML]로 익스포트 시 자동으로 `.html' 파일 등으로 알아서
  링크가 걸린다.


[HTML] <file:html.org>


텍스트 스타일(Text Styles)
==========================

  아래와 같은 기본 스타일들이 있다.
  ,----
  | *bold*  /italics/  _underline_  ~verbatim~  =code=  +strike-through+
  `----
  물론 렌더링되면 *bold* /italics/ _underline_ `verbatim' `code'
  +strike-through+ 로 표시된다.

  verbatim과 code가 동일해 보이는데 사실 동일하다. 이 문법은 짧은 코드를
  표시하기에 딱 적당하다.


블록 문법들
===========

  블록은 렌더링할 경우 blockquote나 pre 태그로 묶이게 렌더링 되는
  문법으로 한 줄 이상의 넓은 범위를 지정할 수도 있다.
  `#+BEGIN_SRC' 내용 `#+END_SRC'
        기본적인 코드 블록이다. 별다른 프로세서가 없어서 그냥 pre 태그로
        익스포트된다.
  `#+BEGIN_SRC python' Python 코드의 pre 블록 `#+END_SRC'
        메이저모드를 명시해서 문법 강조와 실행 지원을 얻을 수 있다.
        지원되는 언어는 매우 많다. 예를 들어 c, python, swift, lisp,
        bash 등등...
  `#+BEGIN_QUOTE' blockquote 내용 `#+END_QUOTE'
        익스포트 시 인용 블록(blockquote)으로 출력된다.
  `#+BEGIN_COMMENT' comment 내용 `#+END_COMMENT'
        프로그래밍 언어의 주석과 비슷하게 이 블럭 안의 내용은 익스포트가
        되지 않는다.
  `#+BEGIN_EXPORT html' HTML 코드 `#+END_EXPORT'
        이 블록 안의 내용은 [HTML]로 출력 시 아무런 변화 없이 그대로
        출력된다. 따라서 간단한 [Org Mode] 문법에서 지원되지 않는 것을
        표현하기 위해 [HTML] 태그를 적기에 적당하다.


[HTML] <file:html.org>

[Org Mode] <file:org-mode.org>


테이블
======

  아래와 같은 식으로 헤더를 쓰고
  ,----
  | | Foo | Bar | Column |
  `----
  그 아래에 `|-' 을 쓰고 `TAB' 키를 누르면 아래처럼 테이블 형태로
  바뀐다.
  ,----
  | | Foo | Bar | Column |
  | |-----+-----+--------+
  `----
  이후 엔터나 탭키를 누르는 상황에 맞게 자동으로 테이블이 만들어 진다.

  이 테이블은 잘 활용하면 스프레드쉬트를 흉내낼 수도 있다. [Org 테이블
  스프레드시트]를 참고하자.


[Org 테이블 스프레드시트] <file:org-table-spreadsheet.org>


기타
====

  `-----'
        줄 긋기(hr 태그로 익스포트)
</content>
</entry>
<entry>
<title>Xcode</title>
<link href="https://seorenn.github.io/note/xcode.html"/>
<id>https://seorenn.github.io/note/xcode.html</id>
<updated>2020-06-26T00:24:38+09:00</updated>
<summary>Xcode와 관련된 정보 모음</summary>
<content type="text">
Xcode는 [애플] 플랫폼 용 소프트웨어를 개발할 때 사용하는 개발 도구 겸
IDE다. 무겁고 잘 죽는 연약한 도구지만 어쩔 수 없이 써야만 한다. 그래도
이런 만능 도구가 무료라는 게 어디인가.


[애플] <file:apple.org>


주제별 내용
===========

  - [Xcode 팁 모음]


[Xcode 팁 모음] <file:xcode-tips.org>


외부 링크
=========

  - [Xcode에서 Build Setting 제대로 관리하기]


[Xcode에서 Build Setting 제대로 관리하기]
<https://sungdoo.dev/programming/know-your-xcode-build-setting/>
</content>
</entry>
<entry>
<title>WWDC</title>
<link href="https://seorenn.github.io/note/wwdc.html"/>
<id>https://seorenn.github.io/note/wwdc.html</id>
<updated>2020-06-26T00:24:33+09:00</updated>
<summary>애플이 매년 개최하는 개발자 행사</summary>
<content type="text">
WWDC는 [애플]에서 개최하는 World Wide Developer Conference 즉 국제
개발자 콘퍼런스의 약자다. 이름처럼 개발자를 위한 행사이다.

개발자를 위한 행사이긴 하나 첫 날에는 키노트가 열리며 여기서는 주로
소프트웨어에 대한 새로운 정보와 함께 맥 제품군이나 아이패드 등의
아이폰을 제외한 디바이스의 발표도 간혹 이루어진다. 따라서 이 키노트는 전
세계와 기자(?)들의 이목이 집중된다.

이 외의 발표들은 대부분 개발자들을 위한 전문적인 내용들이라 기자들에게
소외(?)를 당하지만 역시 개발자들에게는 알짜베기 발표가 많다.


[애플] <file:apple.org>


주제별 내용
===========

  - [WWDC20] (2020)


[WWDC20] <file:wwdc2020.org>
</content>
</entry>
<entry>
<title>rsync</title>
<link href="https://seorenn.github.io/note/rsync.html"/>
<id>https://seorenn.github.io/note/rsync.html</id>
<updated>2020-06-26T00:24:26+09:00</updated>
<summary>rsync 유틸리티 소개</summary>
<content type="text">
rsync는 remote sync의 약자로 두 원격지의 디렉터리를 동기화 하는데
사용하는 [CLI] 도구다. 그냥 복사만 하는 것이 아니라 효율적으로 전송하기
위해 압축 기술을 사용한다. 타임스탬프를 활용해 이후에 수정된 파일만
복사하거나 혹은 체크섬을 활용해 변경된 파일만 복제하는 것도 허용한다.

원격지라는 표현은 로컬와 원격 서버를 모두 포함하는 개념이다. 따라서 두
디렉터리를 동기화하는 것도 가능하다.

리눅스를 비롯한 `*NIX' 운영체제에서 대체로 기본 제공되며 [macOS]에서도
별 다른 설치 없이 사용할 수 있다.


[CLI] <file:cli.org>

[macOS] <file:macos.org>


주제별 내용
===========

  - [rsync로 두 디렉터리 동기화하기]


[rsync로 두 디렉터리 동기화하기] <file:sync-dirs-with-rsync.org>
</content>
</entry>
<entry>
<title>Git</title>
<link href="https://seorenn.github.io/note/git.html"/>
<id>https://seorenn.github.io/note/git.html</id>
<updated>2020-06-26T00:24:19+09:00</updated>
<summary>Git 소개 및 간단한 사용법 정리</summary>
<content type="text">
Git은 현존하는 가장 대표적인 DVCS(Distributed Version Control System) 즉
분산형 버전 컨트롤 시스템으로써 파일의 변경 내역을 추적 및 관리하는데
사용하는 [CLI] 도구다.


[CLI] <file:cli.org>


주제별 내용
===========

  - [Git 일반적인 사용법]
  - [Git 약간 특별한 사용법]
  - [Git 설정하기]


[Git 일반적인 사용법] <file:git-basic-usage.org>

[Git 약간 특별한 사용법] <file:git-special-usage.org>

[Git 설정하기] <file:git-config.org>


외부 링크
=========

  - [Git 사용 중 자주 만나는 이슈 정리]
  - [Git Rebase 제대로 알고 쓰기 (feat. cherry-pick)]
  - [Oh Shit, Git!?!]
  - [git rebase in depth]


[Git 사용 중 자주 만나는 이슈 정리]
<https://parksb.github.io/article/28.html>

[Git Rebase 제대로 알고 쓰기 (feat. cherry-pick)]
<https://readystory.tistory.com/151>

[Oh Shit, Git!?!] <https://ohshitgit.com/>

[git rebase in depth] <https://git-rebase.io/>
</content>
</entry>
<entry>
<title>Doom Emacs</title>
<link href="https://seorenn.github.io/note/doom-emacs.html"/>
<id>https://seorenn.github.io/note/doom-emacs.html</id>
<updated>2020-06-26T00:24:01+09:00</updated>
<summary>커뮤니티 주도 설정팩인 Doom Emacs(둠 이맥스)의 간략한 설명 및 설정, 단축키 등을 정리하는 글</summary>
<content type="text">
Doom Emacs 는 [Emacs] Community Driven Configuration의 양대산맥인
[Spacemacs]와 함께 유명한 [Emacs] 설정 프로젝트다. 직접 과도하게
세팅해서 사용하는 것이 귀찮다면 이런 설정도 사용해보면 괜찮을 것 같다.

Doom Emacs도 [Spacemacs]와 비슷하게 [Vim] 키맵을 흉내 내주는 evil이라는
확장을 토대로 [Vim] 키맵에 기반한 [Emacs] 환경을 설정하고 이와 어울리는
단축키 환경을 만들어 놓은 것이 특징이다.


[Emacs] <file:emacs.org>

[Spacemacs] <file:spacemacs.org>

[Vim] <file:vim.org>


설정 관련 팁
============

설정 파일 위치
~~~~~~~~~~~~~~

  기본적으로 `~/.doom.d' 디렉터리를 개인 설정 파일 위치로 이용할 수
  있다. 이미 install 커맨드로 설치할 때 이미 [보일러플레이트] 코드들이
  여기에 준비된다.


[보일러플레이트] <file:boilerplate.org>


설정 파일 쉽게 열기
~~~~~~~~~~~~~~~~~~~

  `SPC f p' 를 누르면 개인 설정 파일 목록이 뜨기 때문에 쉽게 열 수 있다.


설정 파일 용도
~~~~~~~~~~~~~~

  - `init.el' 은 둠의 핵심인 모듈 설정이 들어간다. 원하는 모듈을 목록에
    추가하면 `sync' 시 자동으로 설치된다.
  - `config.el' 은 일반적인 설정 코드를 넣을 수 있다.
  - `packages.el' 은 추가로 필요한 패키지나 혹은 필요 없는 패키지들을
    나열할 수 있다. 해당 패키지는 `sync' 시 설치되거나 삭제된다.


설정을 고친 후
~~~~~~~~~~~~~~

  Doom Emacs는 설정 후 동기화가 성능 이슈로 자동화가 지원되지 않는다.
  따라서 설정, 특히 패키지를 추가하거나 제거하는 등의 설정을 한 이후에는
  반드시 sync 커맨드를 실행키셔 주어야 한다.
  ,----
  | ~/.emacs.d/bin/doom sync
  `----
  참고로 sync는 과거에는 refresh와 purge라는 이름으로 양분되어 있던
  커맨드가 합쳐지면서 새롭게 만들어진 커맨드다.


폰트 설정
~~~~~~~~~

  폰트나 텍스트 크기는 `config.el' 에 아래와 같은 식으로 설정할 수 있다.
  ,----
  | (setq doom-font (font-spec :family "Menlo" :size 14))
  `----
  이 설정은 고정폭 폰트에만 유효하다.


줄 간격 설정
~~~~~~~~~~~~

  줄 간격(line spacing 혹은 line height) 설정은 아래와 같은 식의 코드를
  `config.el' 에 넣으면 설정할 수 있다.
  ,----
  | (setq-default line-spacing 2)
  `----


창 초기 위치 및 크기 설정
~~~~~~~~~~~~~~~~~~~~~~~~~

  아래 예제는 위에서 120픽셀, 좌측에서 50픽셀 떨어진 곳에 80x24 크기로
  Emacs 창을 배치 시키는 코드다.
  ,----
  | (when window-system
  |   (setq initial-frame-alist
  |         '((top . 120)
  |           (left . 50)
  |           (width . 80)
  |           (height . 24))))
  `----
  이 코드도 적당히 `config.el' 에 넣으면 된다.

  참고로 top, left 값은 픽셀인 반면, width와 height 값은 문자 개수로
  표현한다. 즉 width 80 height 24 값은 가로 80행 세로 24열의 의미다.


배경 색이 버퍼마다 다른 경우
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Doom Emacs에 포함된 `solaire-mode' 는 배경 색을 임의로 변경하는
  확장이다. 이걸 비활성화 하면 배경 색이 바뀌는 문제는 해결된다.

  `packages.el' 파일을 열어서 아래 한 줄을 넣어주자.
  ,----
  | (package! solaire-mode :disable t)
  `----
  수정 후에는 `~/.emacs.d/bin/doom sync' 커맨드를 잊지 말자.


이모티콘 입력기
~~~~~~~~~~~~~~~

  이모티콘(emoji) 입력은 emojify 라는 확장으로 해결할 수 있다.
  `packages.el' 에 아래 내용을 넣고 sync 하면 쉽게 설치할 수 있다.
  ,----
  | (package! emojify)
  `----
  특정 문자가 자동으로 이모티콘으로 표시되게 하고 싶다면 아래 코드를
  `config.el' 에 넣어주자.
  ,----
  | (add-hook! 'after-init-hook #'global-emojify-mode)
  `----
  위 코드는 옵션이고 유니코드 기반 이모티콘만 사용 할거라면 없어도 된다.

  sync가 완료된 후 [Emacs]를 재시작하고 `SPC :' 를 눌러
  `emojify-insert-emoji' 함수를 찾아서 실행시키면 이모티콘 입력기가
  뜬다.


[Emacs] <file:emacs.org>


프로젝트 추가하기
~~~~~~~~~~~~~~~~~

  [Git] 저장소 등 몇몇 디렉터리는 방문 시 자동으로 Projectile로 프로젝트
  디렉터리로 인식되고 자동으로 등록된다. 하지만 이런 특수한 디렉토리
  말고 일반 디렉터리의 경우는 프로젝트로 인식되지 않는다.

  이런 일반 디렉터리도 프로젝트로 등록해 줄 수 있다. 아래와 같은 코드를
  `config.el' 에 넣어보자.
  ,----
  | (projectile-add-known-project "~/boo/bar/project")
  `----
  물론 개수는 상관 없다. 원하는 만큼 등록할 수 있다.


[Git] <file:git.org>


컬러 테마 커스터마이징
~~~~~~~~~~~~~~~~~~~~~~

  컬러 테마를 커스터마이징 하기 위해서 `doom-themes-set-faces' 함수가
  준비되어 있다.
  ,----
  | (doom-themes-set-faces nil
  |   '(foo-face :foreground #123456)
  |   '(bar-face :background nil))
  `----
  첫 매개변수 `nil' 은 테마 이름인데 `nil' 로 설정할 경우 모든 테마에
  적용된다.

  페이스(색상이나 폰트 등의 정보)를 찾을 때는 커서를 원하는 위치에 놓고
  `SPC h F' 를 눌러보면 쉽게 알 수 있다.


visual-line-mode와 커서 이동
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  `visual-line-mode' 가 켜졌을 때 커서 키를 위 혹은 아래로 이동시키는
  경우 visual wrap된 라인을 그대로 통과해버리고 만다. 즉 물리적으로 다음
  혹은 이전 라인으로 커서를 이동시키기 때문에 가상으로 줄바꿈된 것을
  인지하지 못 하도 통과해 버리는 것이다.

  이 경우 아래 코드를 `~/.doom.d/init.el' 최상단에 넣어놓자.
  ,----
  | (setq evil-respect-visual-line-mode t)
  `----
  왜 하필 `config.el' 도 아니고 `init.l' 의 최상단이냐 하면, 관련된 모든
  설정이 로드되기 전에 정의되어 있어야만 효과가 나타나기 때문이다.


주제별 내용
===========

  - [Doom Emacs 단축키]
  - [Doom Emacs 문제 해결]


[Doom Emacs 단축키] <file:doom-emacs-shortcuts.org>

[Doom Emacs 문제 해결] <file:doom-emacs-troubleshooting.org>


외부 링크
=========

  - [Doom Emacs (Youtube Playlist)]
  - [Doom Emacs 공식 저장소]
  - [Doom Emacs 라는 것을 설치해봤다]


[Doom Emacs (Youtube Playlist)]
<https://www.youtube.com/playlist?list=PLPNohcoOBa5FT65hMZL6SkFmbyqFaLe3b>

[Doom Emacs 공식 저장소] <https://github.com/hlissner/doom-emacs>

[Doom Emacs 라는 것을 설치해봤다] <https://seorenn.tistory.com/47>
</content>
</entry>
<entry>
<title>Git 약간 특별한 사용법</title>
<link href="https://seorenn.github.io/note/git-special-usage.html"/>
<id>https://seorenn.github.io/note/git-special-usage.html</id>
<updated>2020-06-25T16:21:28+09:00</updated>
<summary>Git의 약간은 특별한 기능들을 살펴보는 글</summary>
<content type="text">
이 글은 [Git]에서 그나마 자주 사용하지는 않지만 한 번 쯤은 사용할 지도
모를 기능을 정리한다. 특별함의 기준은 그냥 개인적으로 잘 안 쓰는 기능
정도다. 이 외의 기본적인 기능은 [Git 일반적인 사용법] 글을 참고하자.


[Git] <file:git.org>

[Git 일반적인 사용법] <file:git-basic-usage.org>


변경점만 스테이지 하기(Stage Patch)
===================================

  파일 단위가 아니라 변경된 내역 단위로 스테이지 하려면 `-p' 옵션을
  추가로 사용한다.
  ,----
  | git add -p
  `----
  이렇게 하면 각 변경점 위주로 리뷰하며 스테이지할 패치를 고를 수 있다.


커밋 메시지 수정하기
====================

  아래 명령으로 가장 최근의 커밋 메시지를 수정할 수 있다.
  ,----
  | git commit --amend
  `----


브랜치 간 파일 비교하기
=======================

  ,----
  | git diff branch-a branch-b -- path/to/file
  `----
  아래와 같은 방법도 있는 듯 하다.
  ,----
  | git diff branch-a:path/to/file branch-b:path/to/file
  `----


특정 파일의 수정 이력 조회하기
==============================

  아래 명령은 해당 파일의 커밋 별 변경 이력을 최근부터 과거 순으로 계속
  보여준다.
  ,----
  | git log -p path/to/file
  `----


다른 브랜치에서 파일 복사해오기
===============================

  아래와 같이 다른 브랜치의 파일을 현재 브랜치로 복사해 올 수 있다.
  ,----
  | git checkout branch_name path/to/file
  `----


특정 원격 브랜치를 로컬에 그대로 가져오기
=========================================

  원격에만 있는 특정 브랜치를 로컬에 같은 이름의 브랜치로 가져오기
  위해서는 아래 커맨드를 이용한다.
  ,----
  | git checkout -t origin/branch_name
  `----
  이렇게 하면 로컬에 `branch_name' 브랜치가 생성되고 여기에
  원격(origin)의 `branch_name' 브랜치의 내용을 가져온다.


다른 브랜치의 내용 패치 하기
============================

  다른 브랜치의 내용을 현재 브랜치로 몽땅 머지하려면 아래와 같이 할 수
  있다.
  ,----
  | git merge another_branch_name
  `----
  특정 파일만 복사해 오고 싶다면 `checkout' 을 사용할 수 있다.
  ,----
  | git checkout another_bracn file_path
  `----
  특정 파일을 전체가 아닌 수정 단위로만 패치하고 싶다면 `-p' 옵션을
  사용할 수 있다.
  ,----
  | git checkout -p branch_name file_path
  `----


커밋 합치기
===========

  예를 들어 가장 최근의 4개 커밋을 하나로 합치고 싶다면 `rebase'
  커맨드를 이용할 수 있다.
  ,----
  | git rebase -i HEAD~4
  `----
  `-i' 옵션은 인터랙티브(interactive) 하게 한다는 의미이며, `HEAD~4' 는
  HEAD 에서 4단계의 커밋까지 라는 범위를 지정하는 의미다.

  이후 편집기가 뜨면서 합칠 커밋을 선택한다. 대표가 될 커밋은 `pick' 을
  하고 합쳐질 커밋은 `squash' 로 표기하면 된다. 작업 시 하단에 도움말이
  나타나므로 잘 읽어보자.


업데이트 무시하기
=================

  어떤 이유(?)로 특정 파일이 업데이트 되어도 이를 커밋하지 않으려면 아래
  커맨드를 이용할 수 있다.
  ,----
  | git update-index --assume-unchanged PATH
  `----
  이제 해당 파일은 업데이트 되어도 status 에 나타나지 않는다. 다만 이
  방법은 몇몇 커맨드에 의해 다시 원래대로 돌아올 수 있다. 예를 들어
  브랜치를 바꾸거나 pull 상황에 따라 다시 나타날 수 있다.


원격과 브랜치 동기화 하기
=========================

  예를 들어 이런저런 작업을 하면서 원격에서 받은 브랜치가 많아졌는데,
  시간이 흐른 후 원격에서 이런 브랜치들 일부가 사라졌다. 이럴 때 아래
  커맨드로 원격에서 삭제된 브랜치를 로컬에서 지울 수 있다.
  ,----
  | git fetch --prune
  `----
  fetch 시 `--prune' 혹은 `-p' 옵션은 원격에 없는 원격 브랜치를 추적
  중인 로컬 브랜치를 삭제해 준다.

  참고로 완전한 동기화는 안 해주니 오해하지 말자.


다른 브랜치간의 변경 내역만 뽑아서 적용하기
===========================================

  예를 들어 A 라는 브랜치에서 출발한 B 브랜치에서 작업하다가 너무 잦은
  머지로 트리가 너무 복잡해졌다. 이 경우 커밋을 정리하기 위해 rebase를
  사용할 수도 있겠지만 이번에는 C라는 브랜치를 만들어서 여기다 B의 수정
  사항만 별도로 커밋을 만들고 싶다고 하자.

  우선 변경 사항만 뽑아보자.
  ,----
  | git diff A B > /foo/bar/patch
  `----
  이렇게 하면 A를 기준으로 B의 내용을 패치로 뽑아준다. 즉 A에서 B로
  바꿔야 할 때 무엇을 수정해야 하는 지가 파일로 정리된다.

  이제 원하는 브랜치인 C에다 변경 사항을 적용해보자.
  ,----
  | git switch C
  | git apply /foo/bar/patch
  `----
  apply 명령을 통해 현재 브랜치에 간단히 패치를 적용할 수 있다.


로컬의 변경점을 무시하고 원격으로 되돌리기
==========================================

  `reset' 을 강하게 원격으로 때려버리면(?) 원하는 대로 할 수 있다. 아래
  예는 현재 로컬의 브랜치 내용을 원격의 `master' 브랜치로 일치시키는
  커맨드다.
  ,----
  | git reset --hard origin/master
  `----
  뭐 알겠지만 로컬 커밋 내역이 싹 날아갈 수 있으므로 주의하자.
</content>
</entry>
<entry>
<title>SwiftUI</title>
<link href="https://seorenn.github.io/note/swiftui.html"/>
<id>https://seorenn.github.io/note/swiftui.html</id>
<updated>2020-06-25T16:12:39+09:00</updated>
<summary>SwiftUI와 관련된 글 모음</summary>
<content type="text">
SwiftUI는 [Swift] 언어를 이용해 작성할 수 있는 UI 프로그래밍
프레임워크다.

아래의 글들은 SwiftUI에 관한 단편적인 메모 위주 위주다.


[Swift] <file:swift.org>


컴포넌트
========

HStack and VStack
~~~~~~~~~~~~~~~~~

  ,----
  | HStack {
  |     VStack(spacing: 4) {
  |         Text("foo")
  |         Text("bar")
  |     }
  | 
  |     VStack(alignment: .leading) {
  |         ...
  |     }
  | }
  `----
  HStack의 경우 베이스 라인의 기준을 정할 수도 있다.
  ,----
  | HStack(alignment: .lastTextBaseline) {
  |     Text("caption").font(.caption)
  |     Image("20x20")
  |     Text("Title")
  | }
  `----
  위 코드는 마지막 텍스트의 하단을 기준으로 베이스 라인을 맞춰준다.

  `HStack' 의 경우 오른쪽에서 왼쪽으로 읽는 문자 표시 시에는 순서를
  알아서 반대로 표시해 주는 듯 하다.


ZStack
~~~~~~

  ZStack은 UI를 바닥부터 쌓아 가는 형태로 만들 때 사용한다. 대충 쌓기를
  하고 있는데 위에서 쳐다본다고 생각하면 될 것 같다.
  ,----
  | ZStack {
  |     ForEach(...) {
  |         ...
  |     }
  | }
  `----


Spacer
~~~~~~

  플렉시블한 공백이다. 컴포넌트와 컴포넌트 사이에 가능한 최대한의 공간을
  넣는데 사용한다.
  ,----
  | Spacer()
  `----


Text
~~~~

  ,----
  | Text("some text")
  `----
  `+' 오퍼레이터를 이용해 Attributed Text 를 만들 수도 있다.
  ,----
  | Text("foo").foregroundColor(Color.red)
  | + Text("bar").foregroundColor(Color.blue)
  `----
  [Xcode] 11.5부터 시간 관련 기능이 추가된 것 같다.
  ,----
  | Text(Date().addingTimeInterval(600), style: .relative)
  `----
  style에는 이 외에 `.date', `.time', `.timer' 등 다양한 옵션이 있다.

  속성을 넣는 방법도 생긴 것 같다.
  ,----
  | Text("\(Text(name).bold()) foo bar")
  `----
  인터폴레이션으로 Text 오브젝트를 처리할 수 있나보다.

  비슷하게 이미지를 넣을 수 있는 방법도 최근 도입된 것 같다.
  ,----
  | Text("\(Image(systemNamed: "music.mic")) foo bar")
  | .font(.custom("FontName", size: 15))
  `----


[Xcode] <file:xcode.org>


Button
~~~~~~

  ,----
  | Button(
  |     action: { print("Button Action") },
  |     label: { Text("Button Title") }
  | )
  | Button(action: {}) {
  |     Text("Button with Image")
  |     Image(systemName: "square.and.arrow.up")
  | }
  `----


List
~~~~

  가장 기본적인 정적 리스트는 아래와 같은 방식이다.
  ,----
  | List {
  |     SomeRowView()
  |     SomeRowView()
  | }
  `----
  데이터 모델을 사용한 동적 리스트는 아래와 같은 방식이다.
  ,----
  | List(someItemList, id: \.id) { item in
  |     SomeRowView(data: item)
  | }
  `----
  해당 데이터가 각 아이템 타입이 `Identifiable' 프로토콜을 따른다면 `id'
  필드를 생략할 수도 있다.

  `listStyle' 을 이용해 테이블 스타일을 지정할 수 있다.
  ,----
  | List {
  |     ...
  | }.listStyle(GroupedListStyle())  // or PlainListStyle()
  `----
  아직 SwiftUI에서는 inset grouped 리스트 스타일을 지원하지는 않는 것
  같지만 [🌏 돌려서 구현하는 방법]이 있기는 한가 보다.


[🌏 돌려서 구현하는 방법]
<https://sarunw.com/tips/inset-grouped-in-swiftui/>


NavigationView
~~~~~~~~~~~~~~

  기존의 Navigation Controller와 비슷한 역할을 하는 컴포넌트다.
  ,----
  | NavigationView {
  |     List(someItemList) {
  |         NavigationLink(destination: SomeDetailView()) {
  |             SomeRowView()
  |         }
  |     }
  |     .navigationBarTitle(Text("Foo Bar"))
  | }
  `----
  타이틀은 여러 옵션이 있다.
  ,----
  | .navigationBarTitle(Text("foo bar"), displayMode: .inline)
  `----


Shape
~~~~~

  ,----
  | struct SomeShape: Shape {
  |     func path(in rect: CGRect) -> Path {
  |         var path = Path()
  |         path.move(to: ...)
  |         path.addLine(to: ..., in: ...)
  |         ...
  |         return path
  |     }
  | }
  `----


Toggle
~~~~~~

  ,----
  | Toggle(isOn: $someProperty) {
  |     Text("Switch Title")
  | }
  `----


TextEditor
~~~~~~~~~~

  ,----
  | TextEditor(text: $text)
  | .padding()
  | .foregroundColor(Color.black)
  | .font(.title)
  | .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: 200)
  | .border(Color.black, width: 1)
  `----


레이아웃 속성들
===============

frame
~~~~~

  ,----
  | Image("image_20x20").frame(width: 30, height: 30)
  `----


padding
~~~~~~~

  기본 패딩 용도로 쓸 수 있다.
  ,----
  | Text("foo bar").padding()
  `----
  물론 어떤 방향에 패딩을 줄지 고를 수 있다.
  ,----
  | Text("foo bar").padding([.leading, .trailing])
  `----
  패딩 수치도 당연히 고를 수 있다.
  ,----
  | Text("foo bar").padding(10)
  `----
  특정 한 방향에 음수로도 줄 수 있는 트릭도 있다.
  ,----
  | Text("foo bar").padding(.bottom, -130)
  `----


lineLimit
~~~~~~~~~

  ,----
  | Text("foo bar").font(.caption).lineLimit(1)
  `----
  참고로 Stack에도 쓸 수 있다.
  ,----
  | HStack {
  |     ...
  | }
  | .lineLimit(1)
  `----


layoutPriority
~~~~~~~~~~~~~~

  ,----
  | HStack {
  |     Text("foo")
  |     Text("bar").layoutPriority(1)
  | }
  | .lineLimit(1)
  `----
  우선순위가 낮으면 텍스트가 넘칠 경우 `...' 으로 단축될 수 있다.


alignmentGuide
~~~~~~~~~~~~~~

  베이스라인을 수동으로 맞춰준다.
  ,----
  | Image("some_image").alignmentGuide(.lastTextBaseline) {
  |     d in d[.bottom] * 0.927
  | }
  `----


aspectRatio
~~~~~~~~~~~

  ,----
  | SomeView {
  |     ...
  | }
  | .aspectRatio(1, contentMode: .fit)
  `----


offset
~~~~~~

  레이아웃 위치에서 임의로 벗어나게 만들 수 있다.
  ,----
  | Circle().offset(y: -130)
  `----


스타일 속성들
=============

background
~~~~~~~~~~

  ,----
  | Text("foo bar").background(Color.green)
  `----
  이름에 color가 안 들어가 있는 이유는 색상 외에도 쓸 수 있는 게 있어서
  일 것 같다.
  ,----
  | SomeView()
  |     .background(Circle().stroke())
  |     .background(Circle().fill(Color.white))
  `----


foregroundColor
~~~~~~~~~~~~~~~

  ,----
  | Text("foo bar").foregroundColor(Color.white)
  `----


font
~~~~

  ,----
  | Text("foo").font(.title)
  | Text("bar").font(.caption)
  `----


fill
~~~~

  모양(shape)에 색칠을 한다.
  ,----
  | Circle().fill(Color.red)
  `----


stroke
~~~~~~


strokeBorder
~~~~~~~~~~~~

  ,----
  | Circle().strokeBorder(Color.red, lineWidth: 50)
  `----


clipShape
~~~~~~~~~

  ,----
  | image.clipShape(Circle())
  `----


overlay
~~~~~~~

  ,----
  | image.overlay(Circle().stroke(Color.white, lineWidth: 4))
  `----


shadow
~~~~~~

  ,----
  | image.shadow(radius: 10)
  `----


rotationEffect
~~~~~~~~~~~~~~

  ,----
  | SomeView.rotationEffect(.degrees(90))
  `----


scaleEffect
~~~~~~~~~~~

  ,----
  | SomeView.scaleEffect(1.5)
  `----


rotation3DEffect
~~~~~~~~~~~~~~~~

  ,----
  | Text("...")
  |     .rotation3DEffect(.degrees(450), axis: (x: 1, y: 0, z: 0))
  `----


accentColor
~~~~~~~~~~~

  ,----
  | Button("Red").accentColor(.red)
  `----
  기존 UIKit의 tintColor 프로퍼티와 비슷한 용도


액션 속성들
===========

tapAction
~~~~~~~~~

  ,----
  | Text("foo").tapAction {
  |     ...
  | }
  `----
  [macOS] 에서는 클릭 이벤트로 동작하나 보다.


[macOS] <file:macos.org>


contextMenu
~~~~~~~~~~~

  ,----
  | Text("Some Text")
  |     .contextMenu {
  |         Text("Wow super good context menu!")
  |         Button(action: {},
  |                label: { Text("Menu Button") })
  |     }
  `----


그리기 컴포넌트
===============

Circle
~~~~~~

  동그라미
  ,----
  | Circle().fill(Color.red).padding()
  `----


Capsule
~~~~~~~

  알약 모양 동그라미


Ellipse
~~~~~~~

  타원


Gradient
~~~~~~~~

  ,----
  | Gradient(colors: [.red, .yellow, .green])
  `----


LinearGradient
~~~~~~~~~~~~~~

  ,----
  | LinearGradient(gradient: ..., startPoint: ..., endPoint: ...)
  `----


AngularGradient
~~~~~~~~~~~~~~~

  ,----
  | AngularGradient(gradient: Gradient(...),
  |                 center: .center,
  |                 angle: .degrees(-90))
  `----
  center 점을 중앙으로 삼고 둥글게 그라디언트를 그린다. 어디에
  그리는지에 따라 최종 형상이 달라진다.
  ,----
  | Circle().fill(someGradient)
  `----
  위 코드로 눈치챌 수 있지만 그라디언트는 색(Color) 대신 사용할 수 있다.


Path
~~~~

  ,----
  | var p = Path()
  | p.addArc(center: ..., radius: ..., startAngle: ..., endAngle: ..., clockwise: false)
  | p.addLine(to: ...)
  | ...
  | p.closeSubpath()
  `----
  아래와 같은 식이 좀 더 SwiftUI 답긴 하다.
  ,----
  | Path { path in
  |     path.move(to: ...)
  |     path.addLine(to: ...)
  |     path.addQuadCurve(to: ..., control: ...)
  |     ...
  | }
  | .fill(Color.black)
  `----


애니메이션
==========

animation
~~~~~~~~~

  ,----
  | SomeView.rotationEffect(.degrees(90))
  |     .animation(.spring())
  `----
  멀티 애니메이션도 가능하다.
  ,----
  | SomeView.rotationEffect(.degrees(90))
  |     .animation(nil)
  |     .scaleEffect(1.5)
  |     .animation(.spring())
  `----
  물론 위의 애니메이션은 순차가 아니라 동시에 발동한다.


withAnimation
~~~~~~~~~~~~~

  가장 기본적인 뷰 애니메이션 용도다.
  ,----
  | withAnimation {
  |     someSwitch.toggle()
  | }
  `----
  알고리즘도 바꿀 수 있다.
  ,----
  | withAnimation(.spring()) {
  |     someSwitch.toggle()
  | }
  `----
  아래는 버튼과 섞은 좀 더 복잡한 예제다.
  ,----
  | Button("Animate..!") {
  |      withAnimation {
  |          self.degrees += 360
  |      }
  | }
  | .padding(20)
  | .background(Color.blue.opacity(0.8))
  | .foregroundColor(Color.white)
  | .rotation3DEffect(.degrees(degrees), axis: (x: 1, y: 1, z: 1))
  `----


transition
~~~~~~~~~~

  ,----
  | SomeView.transition(.move(edge: .top))
  `----
  조합의 경우는 아래와 같은 식으로 할 수 있다.
  ,----
  | SomeView.transition(
  |     AnyTransition
  |         .move(edge: .top)
  |         .combined(with: .opacity)
  | )
  `----
  등장과 퇴장 애니메이션을 별도로 [구현]할 수도 있다.
  ,----
  | extension AnyTransition {
  |     static var someTransitionName: AnyTransition {
  |         return .asymmetric(
  |             insertion:
  |                 AnyTransition
  |                     .move(edge: .top)
  |                     .combined(with: .opacity)
  |             removal:
  |                 AnyTransition
  |                     .scale
  |                     .combined(with: .opacity)
  |         )
  |     }
  | }
  `----


[구현] <file:implementation.org>


매크로
======

ViewModifier
~~~~~~~~~~~~

  스타일을 매크로처럼 사용할 수 있게 해 준다.
  ,----
  | struct TitleStyleModifier: ViewModifier {
  |     func body(content: Content) -> some View {
  |         content
  |             .foregroundColor(Color.black)
  |             .backgroundColor(Color.yellow)
  |             .font(.largeTitle)
  |     }
  | }
  `----
  이제 이 스타일을 특정 뷰에 적용할 수 있다.
  ,----
  | Text("Title Text").modifier(TitleStyleModifier)
  `----


기타 팁
=======

[iOS] <file:ios.org>

풀스크린 뷰([iOS])
~~~~~~~~~~~~~~~~~~

  ,----
  | struct ContentView: View {
  |     var body: some View {
  |         Text("Fullscreen Text View")
  |             .edgesIgnoringSafeArea(.all)
  |     }
  | }
  `----
  `edgesIgnoringSafeArea' 속성으로 안전 영역을 몽땅 덮어버리는 그게 바로
  풀스크린 뷰다.


[iOS] <file:ios.org>


기존 컴포넌트 붙이기
~~~~~~~~~~~~~~~~~~~~

  SwiftUI가 도입되기 전에 사용하던 컴포넌트를 SwiftUI 뷰에 붙이는
  방법이다. 아래는 MKMapView를 SwiftUI 형태로 감싸는 예제다.
  ,----
  | struct MapView: UIViewRepresentable {
  |     var coordinate: CLLocationCoordinate2D
  | 
  |     func makeUIView(context: Context) -> MKMapView {
  |         MKMapView(frame: .zero)
  |     }
  | 
  |     func updateUIView(_ view: MKMapView, context: Context) {
  |         let span = MKCoordinateSpan(latitudeDelta: 0.02, longitudeDelta: 0.02)
  |         let region = MKCoordinateRegion(center: coordinate, span: span)
  |         view.setRegion(region, animated: true)
  |     }
  | }
  `----
  이런 식으로 코딩해 놓으면 SwiftUI 코드들과 조화를 이룰 수 있다.


다크 테마 미리보기
~~~~~~~~~~~~~~~~~~

  ,----
  | struct SampleView_Previews: PreviewProvider {
  |     static var previews: some View {
  |         Group {
  |             SampleView()
  |                 .environment(\.colorScheme, .dark)
  |         }
  |     }
  | }
  `----


미리보기(Preview) 크기 조절하기
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ,----
  | struct SampleView_Previews: PreviewProvider {
  |     static var previews: some View {
  |         SampleView()
  |             .previewLayout(.fixed(width: 500, height: 300))
  |     }
  | }
  `----


멀티 미리보기(preview)
~~~~~~~~~~~~~~~~~~~~~~

  ,----
  | struct SampleView_Previews: PreviewProvider {
  |     static var previews: some View {
  |         Group {
  |             SampleView(data: someData[0])
  |                 .previewLayout(.fixed(width: 300, height: 100))
  |             SampleView(data: someData[1])
  |                 .previewLayout(.fixed(width: 300, height: 100))
  |         }
  |     }
  | }
  `----
  각각의 뷰 사이즈가 동일하다면 아래 처럼 묶을 수도 있다.
  ,----
  | struct SampleView_Previews: PreviewProvider {
  |     static var previews: some View {
  |         Group {
  |             SampleView(data: someData[0])
  |             SampleView(data: someData[1])
  |         }
  |         .previewLayout(.fixed(width: 300, height: 100))
  |     }
  | }
  `----
  밝은 모드나 다크 모드 시의 차이를 한 번에 볼 때도 유용하다.
  ,----
  | struct SampleView_Previews: PreviewProvider {
  |     static var previews: some View {
  |         Group {
  |             SampleView()
  |                 .environment(\.colorScheme, .light)
  |             SampleView()
  |                 .environment(\.colorScheme, .dark)
  |         }
  |     }
  | }
  `----


디바이스 별 미리보기
~~~~~~~~~~~~~~~~~~~~

  ,----
  | struct SampleView_Previews: PreviewProvider {
  |     static var previews: some View {
  |         SomeView()
  |             .previewDevice(PreviewDevice(rawValue: "iPhone SE"))
  |     }
  | }
  `----
  물론 멀티 디바이스 미리보기도 가능하다.
  ,----
  | struct SampleView_Previews: PreviewProvider {
  |     static var previews: some View {
  |         SomeView()
  |             .previewDevice(PreviewDevice(rawValue: "iPhone SE"))
  |         SomeView()
  |             .previewDevice(PreviewDevice(rawValue: "iPhone XS Max"))
  |     }
  | }
  `----
  디바이스가 많으면 ForEach로 묶어버릴 수도 있다. 기왕 하는거 프리뷰
  밑에 이름도 붙여서 구분해 보자. #+BEGIN_SRC swift struct
  SampleView_Previews: PreviewProvider { static var previews: some View
  { ForEach(["iPhone SE", "iPhone XS", "iPhone XS Max"], id: \.self) {
  deviceName in SomeView() .previewDevice(PreviewDevice(rawValue:
  deviceName)) .previewDisplayName(deviceName) } } }


스토리보드에서 시험해보기
~~~~~~~~~~~~~~~~~~~~~~~~~

  아래 같은 코드로 플레이그라운드에서 SwiftUI를 시험해 볼 수 있다.
  ,----
  | import SwiftUI
  | import PlaygroundSupport
  | 
  | struct ContentView: View {
  |     var body: some View {
  |         Text("Hello Playground!")
  |     }
  | }
  | 
  | PlaygroundPage.current.setLiveView(ContentView())
  `----
  실행시킨 후 창 우측 상단에 있는 'Adjuest Editor Options' 메뉴에서 Live
  View 를 켜 주면 뷰의 모습을 볼 수 있다.

  macOS 에서는 텍스트가 상단에 표시되고, [iOS]의 경우는 텍스트가
  가운데에 표시된다는 차이가 있다.

  다만 아직 SwiftUI를 플레이그라운드에서 완벽히 돌리기엔 무리가 있다는
  점을 알아두자.


[iOS] <file:ios.org>


오류 메시지들
=============

Cannot assign to property: 'self' is immutable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        팁: 혹시 멤버 프로퍼티를 `@Published' 로 설정해서 이
        에러가 났다면 `@State' 로 고쳐서 시도해보자.
  SwiftUI의 모든 뷰는 Immutable 구조체 [인스턴스]가 생성되는 형태로
  동작한다. 따라서 자신의 모든 프로퍼티를 바꾸는 행위는 불가능하다. 이
  점을 이해한다면 어떤 행위가 이 오류를 발생 시키는지 알 수 있을 것이다.


[인스턴스] <file:instance.org>


외부 링크
=========

  - [Combine과 SwiftUI]
  - [Fucking SwiftUI]
  - [Building Custom Views with SwiftUI]
  - [Drawing Paths and Shapes]
  - [Building Lists and Navigation]


[Combine과 SwiftUI] <https://seorenn.tistory.com/67>

[Fucking SwiftUI] <https://fuckingswiftui.com/>

[Building Custom Views with SwiftUI]
<https://developer.apple.com/videos/play/wwdc2019/237>

[Drawing Paths and Shapes]
<https://developer.apple.com/tutorials/swiftui/drawing-paths-and-shapes>

[Building Lists and Navigation]
<https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation>
</content>
</entry>
<entry>
<title>Python 예외 처리</title>
<link href="https://seorenn.github.io/note/python-exception-handling.html"/>
<id>https://seorenn.github.io/note/python-exception-handling.html</id>
<updated>2020-06-24T22:17:00+09:00</updated>
<summary>파이썬의 예외 처리와 예외 발생시키기, 예외 만들기, Traceback 출력하기 등을 알아보자</summary>
<content type="text">
이 글은 [Python] 예외 처리(Exception Handling)의 가장 기초적인 부분을
다룬다. 참고로 문법은 버전 3.x 이후이며 2.x 버전에서는 조금 다를 수
있다.


[Python] <file:python.org>


예외 처리하기
=============

  [Python] 예외 처리의 가장 기본은 `try' 와 `except' 문이다. 대충 아래와
  같은 식으로 쓰인다.
  ,----
  | try:
  |     do_what()
  | except:
  |     print("ERROR: 뭔가 에러가 났어요!")
  `----
  `try' 블록 내부에서 예외가 발생할지도 모를 코드를 실행시키고, 만약
  여기 안에서 예외가 발생하면 `except' 블록의 구문이 실행된다.

  만약 모든 예외가 아니라 특정 예외만 잡고 싶다면 `except' 에 정확한
  이름을 줄 수 있다.
  ,----
  | try:
  |     do_what()
  | except ValueError:
  |     print("Value Error!")
  `----
  이렇게 하면 `do_what()' 에서 `ValueError' 를 제외한 예외는 `except' 로
  진입하지 않는다.

  만약 예외사항의 메시지를 알고 싶다면 그대로 출력해 보는 방법이 있다.
  ,----
  | try:
  |     do_what()
  | except ValueError as e:
  |     print(f"Value Error: {e}")
  `----
  위의 경우 `ValueError' 라는 예외에서 넘겨주는 문자열이 있을 경우
  화면에 표시가 된다. 다만 이 부분은 예외 클래스에 따라 좀 더 적합한
  방식이 있을 수도 있다.

  만약 한 예외가 아니라 여러 예외를 처리하고 싶다면 아래와 같이 `except'
  를 계속 나열하면 된다.
  ,----
  | try:
  |     do_what()
  | except ValueError:
  |     print("Value Error!")
  | except AttributeError:
  |     print("Attribute Error!")
  `----
  이렇게 하면 발생한 예외에 맞는 `except' 블록으로 진입한다.

  혹은 여러 예외를 하나의 `except' 로 잡을 수도 있다.
  ,----
  | try:
  |     do_what()
  | except (ValueError, AttributeError):
  |     print("Value or Attribute Error!")
  `----
  이 경우 `ValueError' 혹은 `AttributeError' 둘 중 하나의 예외가
  발생하면 `except' 안의 구문이 실행된다.

  위의 경우도 당연히 상세한 내용을 찍어볼 수 있다.
  ,----
  | try:
  |     do_what()
  | except (ValueError, AttributeError) as e:
  |     print(f"Something Error: {e}")
  `----
  물론 이건 예외 클래스에서 출력을 지원할 때의 이야기지만 말이다.
  대부분의 기본 예외 오류는 메시지를 다 알려주긴 한다.


[Python] <file:python.org>


예외 발생시키기
===============

  예외는 `raise' 커맨드로 발생시킬 수 있다.
  ,----
  | raise ValueError()
  `----
  보통은 첫 인자로 문자열 메시지를 넣을 수 있다.
  ,----
  | raise ValueError("The value is invalid")
  `----


사용자 예외 클래스
==================

  개인이 만든 기능에는 당연히 개인이 정의한 오류가 발생할 수 있다.
  따라서 당연하게도 예외 클래스 또한 원하는 대로 별도로 디자인할 수
  있다.

  아래는 `TestException' 이라는 예외를 만들고 이를 일부러 발생시키는
  예제다.
  ,----
  | class TestException(Exception):
  |     pass
  | 
  | def test():
  |     raise TestException()
  | 
  | try:
  |     test()
  | except Exception as e:
  |     print(f'Exception: {e}')
  `----
  `TestException' 이 직접 만든 예외이다. 보다시피 `Exception' 이라는
  클래스를 상속받은 클래스다.

  위 예제를 실행하면 예외가 발생하면서 하단의 print 문이 그대로
  실행된다. `except' 에서 굳이 `TestException' 이 아닌 `Exception' 을
  잡은 것은 이 커스텀 예외도 다른 일반 예외와 별 다른 것이 없다는 것을
  알 수 있게 하기 위함이다.

  그런데 위 코드는 아래 처럼 정확히 무슨 예외인지 표시되지는 않는다.
  ,----
  | Exception:
  `----
  이건 `TestException' 클래스에서 특별한 정보를 알려주지 않아서이다.

  만약 발생한 예외의 정보를 문자열로 찍어야 하는 경우라면 `__str__'
  메서드를 구현하면 어느 정도 해결할 수 있다. 이 메서드는 문자열 변환
  요구 시 호출된다.
  ,----
  | class TestException(Exception):
  |     def __str__(self):
  |         return "TestException"
  `----
  `TestException' 클래스를 위 처럼 수정하면 이제 print를 통해서
  `TestException' 에 의한 예외가 났다는 것을 볼 수 있다.
  ,----
  | Exception: TestException
  `----
  이제 예외의 종류를 화면으로 볼 수 있게 되었다.

  하지만 이 정도로는 그다지 유용한 예외라곤 볼 수 없다. 여기에 오류의
  원인을 알려준다면 더 좋은 예외로 볼 수 있을 것 같다. 아래의 코드는
  메시지를 전달할 수 있도록 수정한 예제이다.
  ,----
  | class TestException(Exception):
  |     def __init__(self, message=""):
  |         self.message = message
  |     def __str__(self):
  |         return f"TestException {self.message}"
  | 
  | def test():
  |     raise TestException("Some Error")
  | 
  | try:
  |     test()
  | except Exception as e:
  |     print(f'Exception: {e}')
  `----
  이제 이 코드는 아래와 같은 메시지를 출력한다.
  ,----
  | Exception: TestException Some Error
  `----
  단순하게 만든 예제이지만 이 정도만 알아도 왠만한 오류 내용을 만들 수
  있다.


예외 상황의 메시지를 그대로 출력하기
====================================

  일반적으로 예외 처리가 완벽하지 않은 [Python] 스크립트에서 에러가 나면
  스크립트가 죽으면서 Traceback이라 불리우는 메시지가 화면에 뿌려지는
  것을 볼 수 있다.
  ,----
  | Traceback (most recent call last):
  |   File "foo.py", line 13, in <module>
  |     bar()
  |   File "foo.py", line 10, in test
  |     raise QuxException("Foobar")
  | Exception: QuxException: Foobar
  `----
  이런 메시지를 통해 에러의 종류와 발생 위치나 순서 등을 알 수 있어서
  디버깅에 도움이 된다.

  만약 작성 중인 스크립트에서 모든 예외를 핸들링 하기가 힘든 상황이라
  예외 발생 시 스크립트를 죽이지 않으면서 그 내용을 눈으로 봐가며
  디버깅해야 하는 경우 위의 Traceback 메시지를 예외 상황에서 표시할 수
  있으면 유용할 때가 있다.

  이럴 때는 `traceback' 모듈을 이용할 수 있다. 아래 코드는 `do_what()'
  에서 예외가 발생하면 Traceback을 화면에 표시하는 예제다.
  ,----
  | import traceback
  | 
  | try:
  |     do_what()
  | except:
  |     traceback.print_exc()
  `----
  `traceback' 모듈의 `print_exc()' 함수는 실제로 콘솔에서 발생하던
  오류와 거의 동일한 오류 메시지를 화면에 표시해준다. 따라서 디버깅에
  유리하게 써먹을 수 있다.

  만약 이런 Traceback을 로그 등으로 남기기 위해 별도의 문자열로 얻고
  싶다면 `format_exc()' 함수를 활용할 수도 있다.
  ,----
  | import traceback
  | 
  | try:
  |     do_what()
  | except:
  |     stacktrace = traceback.format_exc()
  |     log(stacktrace)
  `----
  이렇게 하면 대부분의 Traceback을 로그로도 그대로 볼 수 있게 된다. 물론
  스크립트는 당연히 죽지도 않고 말이다.


[Python] <file:python.org>
</content>
</entry>
<entry>
<title>kubectl</title>
<link href="https://seorenn.github.io/note/kubectl.html"/>
<id>https://seorenn.github.io/note/kubectl.html</id>
<updated>2020-06-24T13:20:39+09:00</updated>
<summary>kubectl 사용법 정리</summary>
<content type="text">
kubectl 은 Kubernetes 클러스터 컨트롤 [CLI] 도구다. 이 문서에서는 이
kubectl 의 사용법 예를 몇 가지 정리한다.


[CLI] <file:cli.org>


사용법 예제
===========

포드 리스트
~~~~~~~~~~~

  ,----
  | kubectl get pods
  `----


포드 정보 보기
~~~~~~~~~~~~~~

  ,----
  | kubectl describe pod POD_NAME
  `----


YAML 파일 적용
~~~~~~~~~~~~~~

  ,----
  | kubectl apply -f foo/bar.yaml
  `----


포드 삭제하기
~~~~~~~~~~~~~

  보통은 rescale로 0대만 동작하게 설정하는 식으로 포드를 종료 시킨다.
  ,----
  | kubectl scale --replicas=0 deployment/POD_NAME
  `----
  [YAML] 파일이 있으면 포드 이름을 찾을 필요 없이 좀 더 쉽게 할 수 있다.
  ,----
  | kubectl scale --replicas=0 -f foo/bar.yaml
  `----
  아예 포드를 삭제 시킬 수도 있다. Deployment가 아닌 포드는 이 방법으로
  삭제하는 것이 편한 것 같다.
  ,----
  | kubectl delete pod POD_NAME
  `----


[YAML] <file:yaml.org>


포드 재시작 하기
~~~~~~~~~~~~~~~~

  특별히 커맨드가 있는 건 아니고 아래처럼 할 수 있다.
  ,----
  | kubectl edit deployment/POD_NAME
  `----
  이렇게 입력하면 에디터가 뜨는데 그냥 저장하고 종료하면 재시작 된다고
  한다. (아직 시험 안 해봄😛)


로그 보기
~~~~~~~~~

  ,----
  | kubectl logs -f POD_NAME
  `----
  보통 사용하는 `tail -f' 와 비슷한 커맨드다.

  포드가 여럿인 특정 앱의 모든 로그를 보려면 아래처럼 할 수 있다.
  ,----
  | kubectl logs -f -l app=APP_NAME
  `----
  기본적으로 5개의 포드 까지만 볼 수 있게 되어있는데 에러 메시지에
  옵션(`--max-log-requests') 정보가 나오니까 이것도 참고하자.

  위의 방법이 잘 안 되면 아래와 같은 식으로도 해보자.
  ,----
  | kubectl logs -f deployment/APP_NAME --all-containers=true
  `----
  너무 많은 로그가 나올 수도 있는데, `--since' 옵션을 이용해 과거의
  로그를 다 안 보는 방법이 있으니 참고하자.
  ,----
  | kubectl logs -f deployment/APP_NAME --all-containers=true --since=10m
  `----


포트 포워딩
~~~~~~~~~~~

  ,----
  | kubectl port-forward POD_NAME PORT_NUM
  `----
  `PORT_NUM' 으로 표기한 부분은 포트 번호인데 `HOST_PORT:CONTAINER_PORT'
  와 같은 식으로 다르게 지정하는 것도 가능하다.

  포드가 아닌 서비스도 포트 포워딩이 된다.
  ,----
  | kubectl port-forward svc/SERVICE_NAME PORT_NUM
  `----


컨테이너의 커맨드 실행시키기
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ,----
  | kubectl exec -it POD_NAME -- COMMAND
  `----
  `-it' 옵션을 넣었기 때문에 커맨드에 [셸]을 넣으면 당연히 [셸]도 뜬다.

  포드가 하나 이상의 멀티 컨테이너일 경우 `--container' 옵션으로 골라서
  접속할 수 있다.
  ,----
  | kubectl exec -it POD_NAME --container CONTAINER_NAME -- COMMAND
  `----


[셸] <file:shell.org>


사용량 등 메트릭 조회
~~~~~~~~~~~~~~~~~~~~~

  ,----
  | kubectl top node [NODE]
  `----
  노드의 메트릭을 조회할 수 있다. 노드 이름을 넣지 않으면 모든 노드의
  메트릭을 볼 수 있다.

  ,----
  | kubectl top pod [POD-NAME]
  `----
  비슷하게 단일 포드 혹은 전체 포드의 메트릭을 조회할 수 있다.


심화 예제
=========

레코드와 롤백
~~~~~~~~~~~~~

  `--record' 커맨드로 현재 기록을 남겨둘 수 있다.
  ,----
  | kubectl apply -f somedeploy.yaml --record
  `----
  그리고 롤백도 쉽게 된다.
  ,----
  | kubectl rollout history deploymenys some-deployment
  `----
  (다만 이것도 아직 시험 안 해봄😏)


기타 외부 링크
==============

  - [Kubernetes Best Practices] (Slides)


[Kubernetes Best Practices]
<https://speakerdeck.com/thesandlord/kubernetes-best-practices>
</content>
</entry>
<entry>
<title>WWDC20</title>
<link href="https://seorenn.github.io/note/wwdc2020.html"/>
<id>https://seorenn.github.io/note/wwdc2020.html</id>
<updated>2020-06-24T12:07:41+09:00</updated>
<summary>WWDC 2020(WWDC20) 키노트 정리</summary>
<content type="text">
미국 시간으로 2020년 6월 22일에 열린 [WWDC]의 키노트를 간단히 정리하는
글이다. 영어라 잘못 이해했을 수도 있고, 잠 자는 사이에 잊거나 기억이
왜곡된 경우도 있을 것 같고, 개인적인 의견 및 느낌도 섞여 있음에
주의하자.


[WWDC] <file:wwdc.org>


iOS 14
======

  [iOS 14]

  역시나 새로운 [iOS]의 소개가 가장 먼저 이뤄졌다.

  홈 화면 개편에 많은 부분이 할애되었다. 위젯의 홈 침투(Smart Stack), 앱
  페이지의 숨김, 앱 라이브러리를 이용한 앱 자동 구조화 및 검색 지원
  등이다.

  이 외에 동영상을 화면에 작게 띄우는 PIP(Picture in Picture) 지원 추가,
  앱 클립(App Clip)을 통한 빠른 앱 접근, 번역 지원 추가, 메시지와 관련된
  개선사항들, 지도와 카 플레이 개선, Siri를 완전히 뒤엎는(?) 개선 등 몇
  가지 보조적인 개선이 이뤄진 것 같다.

  iPadOS에서 소개된 것으로 통화 팝업이 푸시처럼 화면 상단에 작게
  나타나던 루머로만 보이던 기능이 실제로 들어가게 될 것으로 보인다.

  통화녹음은 키노트에 없었다. 루머대로 아마도 안 들어가게 될 것 같다.


[iOS 14] <img:../attach/ios14.jpg>

[iOS] <file:ios.org>


iPadOS 14
=========

  어차피 [iOS] 14의 형제이기 때문에 많은 부분은 동일하게 물려받을 것
  같다.

  그밖에 펜슬 입력이 자동으로 글자나 폴리곤으로 바뀌는 것이나 Siri의
  개선 등이 포함되었다.


[iOS] <file:ios.org>


watchOS 7
=========

  손을 씼을 때 자동으로 감지하여 손 씻는 시간을 카운트해 주는 기능이
  생겼다. 코로나19의 힘은 정말 대단했다.

  나머지는 뭔가 말은 많았는데 잘 이해도 안 되고 워치도 없고 모르겠다.


Apple TV
========

  Foundation이라는 Apple TV 오리지널이 소개되었다. 우주를 배경으로 한
  뭔가인 것 같은데 취향이다.


Privacy
=======

  소개하던 모든 제품에도 자물쇠 애니메이션을 강조하며 [애플]의 장점인
  보안을 내세웠다. 이제까지도 앞으로도 계속 애플의 보안 정책은 핵심
  가치다 라는 것을 강조하는 것 같다.


[애플] <file:apple.org>


macOS Big Sur
=============

  [macOS Big Sur]

  [macOS] 새 메이저 버전이 공개되었다. 이름이 Big Sur로 한국어로
  부르기엔 좀 애매모한 발음인 것 같다. 대충 '빅서'라고 들린다. 그런데
  버전은 10.16이 아니라 X(10)을 돌파해서 이제 11.0이 된다. 아마 이후로
  메이저 릴리즈마다 제일 앞자리를 올리려는 버저닝 전략 변화일지도
  모른다.

  특이하게도 이번 [macOS]의 개선은 디자인 변화에 중점을 둔 것 같다.
  전반적으로 [iOS]의 룩앤필과 비슷한 느낌이 들도록 바뀌면서 [애플]의
  OS간 통합이 되고 있다. 심지어 컨트롤 센터도 도입되었다.

  [사파리]가 빨라졌다고 하는 것 같다. 로딩 속도가 [크롬]보다 50%
  빠르다는데 그걸로 끝인가? 이외에 번역 기능 등 [사파리]의 전반적인
  개선도 있는 것 같다.

  어쨌든 여기서도 보안을 엄청나게 강조했다. 제발 보안 때문에 기능을 너무
  희생하지는 않았으면 좋겠다.


[macOS Big Sur] <img:../attach/macos-bigsur.jpg>

[macOS] <file:macos.org>

[iOS] <file:ios.org>

[애플] <file:apple.org>

[사파리] <file:safari.org>

[크롬] <file:chrome.org>


ARM SoC
=======

  가장 마지막에 많은 사람들이 궁금해하던 소식이 전해졌다.

  그동안 소문으로만 무성했던 [애플]의 ARM SoC 칩으로의 이주를 드디어
  공식화했다. Apple Silicon Mac 이라는 이름으로 말이다. 키노트에서
  자신들의 칩의 우월성을 매우 부드럽고 빠르다는 식으로 광고하며
  (은근슬쩍 신형 아이맥을 영상에 등장시키며) [x86]에서 arm64로 매우
  자연스럽고 눈치채기 힘들게 전환될 것이라고 소개하였다.

  칩 이름은 기존 [애플] 휴대용 디바이스에서 쓰던 A 모델 이름 끝에 'Z'가
  붙는 형태인 것 같다. 실제로 영상에서 공개된 칩 이름은 A12Z Bionic
  프로세서였다. 이미 ARM 칩의 성능이 데스크톱에서 쓰기에도 무리가 없는
  수준으로 발전한 데다 전력 관리 등의 장점을 비롯하여 [애플]이 자체
  설계하기에 최적화나 기능 추가에도 유리할 것으로 전망된다. 즉 현재보다
  성능이 좋아질 것 같다. (보안 이슈로 인텔칩 성능을 하락을 시킨 것도
  기억하자)

  이외에 Universal 2 바이너리 체계도 도입되는 것 같다. 기존의
  Universal이 PowerPC와 [x86] 바이너리를 하나에 통합한 것과 비슷하게
  이번엔 여기에 ARM 바이너리를 추가하는 것 같다. 이미 메이저 개발사들은
  이에 대응했으며 일반 사용자는 사용하는 소프트웨어가 [x86]인지
  ARM64인지 신경 쓸 필요가 없을 것 같다.

  그 외에 설치 때 아예 기계어 코드를 플랫폼에 맞게 변경해서 퍼포먼스
  하락 없는 네이티브 지원 등등 Universal 2, Rosetta, Catalyst,
  Virtualization 등 다양한 멀티 플랫폼 지원책 4종에 대해 소개하였다.

  이미 인텔로의 이주에서 보여줬듯이 이미 [애플]은 준비가 되어있고 정말
  별 느낌 없이 자연스러운 이주가 진행될 것 같다.


[애플] <file:apple.org>

[x86] <file:x86.org>


마무리
======

  아주 깔끔하게 애플 공식으로 정리된 영상이 나왔다. 이걸로 마무리 하면
  딱 좋을 것 같다.
</content>
</entry>
<entry>
<title>MozJPEG</title>
<link href="https://seorenn.github.io/note/mozjpeg.html"/>
<id>https://seorenn.github.io/note/mozjpeg.html</id>
<updated>2020-06-23T22:28:32+09:00</updated>
<summary>Mozilla JPEG Encoder</summary>
<content type="text">
MozJPEG은 Mozilla 재단에서 제작한 JPEG Encoder 프로젝트다. 압축 용도로
많이 쓰다보니 사실상 압축기로 봐도 될 것 같다.

Progressive로 점차적 로딩이나 최적화 기능을 제공하므로 별도의 이미지
에디터를 통해 저장한 것보다 드라마틱한 결과를 얻을 때도 있다.


설치
====

  [macOS]의 경우 [Homebrew]로 별다른 설정 없이 설치할 수 있다.
  ,----
  | brew install mozjpeg
  `----
  설치 후 mozjpeg 이라는 바이너리가 없어서 헤멜 수도 있는데, 설치되는
  바이너리 이름은 `cjpeg', `djpeg', `jpegtran' 등등 다양하므로 참고하자.


[macOS] <file:macos.org>

[Homebrew] <file:homebrew.org>


관련 글
=======

  - [MozJPEG으로 JPEG 이미지 압축하기]


[MozJPEG으로 JPEG 이미지 압축하기]
<file:mozjpeg-compress-jpeg-images.org>


외부 링크
=========

  - [Mozilla JPEG Encoder Project]


[Mozilla JPEG Encoder Project] <https://github.com/mozilla/mozjpeg>
</content>
</entry>
</feed>
