<!DOCTYPE html><html lang="ko"><head><meta charset="utf-8"><meta name="viewport"content="width=device-width,initial-scale=1"><meta http-equiv="Content-Type"content="text/html; charset=UTF-8"><link rel="stylesheet"href="/static/style.min.css"><meta name="battery-savings"content="allow-reduced-framerate allow-reduced-script-speed"><title>C 포인터 - Seorenn Note</title><meta name="twitter:title"content="C 포인터"><meta name="og:title"content="C 포인터"><meta name="description"content="C 언어의 포인터 개념에 대한 정리"><meta name="twitter:description"content="C 언어의 포인터 개념에 대한 정리"><meta name="og:description"content="C 언어의 포인터 개념에 대한 정리"><link rel="canonical"href="https://seorenn.github.io/note/c-pointer.html"><meta property="og:url"content="https://seorenn.github.io/note/c-pointer.html"><link rel="shortcut icon"type="image/x-icon"href="/static/favicon.ico"><meta name="twitter:image"content="https://seorenn.github.io/static/seorenn-symbol.png"><meta property="og:image"content="https://seorenn.github.io/static/seorenn-symbol.png"><meta property="og:image:width"content="520"><meta property="og:image:height"content="329"><meta name="twitter:card"content="summary"><meta name="twitter:site"content="@seorenn"><meta name="twitter:creator"content="@seorenn"><meta property="og:type"content="article"><meta property="og:site_name"content="Seorenn"><meta property="og:locale"content="ko_KR"><meta name="referrer"content="unsafe-url"><meta name="robots"content="follow,index"><meta name="google-site-verification"content="YqTFZuthbvGIlDE1dhxiTjZ3m-GfyNs_rsHaOlPKpug"><meta name="naver-site-verification"content="24609571c04926ab1220d5d02610efa1c9e12221"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script data-ad-client="ca-pub-1071465863344332"async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div class="header-content"><header class="top-header"><div class="logo-container"><span class="vertical-center-helper"></span> <a href="/"title="Seorenn"><img class="site-logo"src="/static/seorenn-note-logo-light.png"alt="Seorenn Note"></a><nav><span class="vertical-center-helper"></span> <a href="/"title="Home">HOME</a> | <a href="/note"title="All Notes">NOTES</a></nav></div></header></div><div class="content-container"><section class="content"><div class="mid-ad-container"><ins class="adsbygoogle mid-ad"style="display:block"data-ad-client="ca-pub-1071465863344332"data-ad-slot="4306465772"data-ad-format="auto"data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><header><h1>C 포인터</h1><div class="title-date">2021년 7월 22일 수정</div></header><div id="table-of-contents"role="doc-toc"><h2>≡ 목차 (Table of Contents)</h2><div id="text-table-of-contents"role="doc-toc"><ul><li><a href="#997ec4d8">C 포인터(Pointer)</a></li><li><a href="#096912fa">포인터의 용도</a></li><li><a href="#60d9d1a4">포인터 문법</a></li><li><a href="#7ac4516b">배열과 포인터</a></li></ul></div></div><div id="outline-container-997ec4d8"class="outline-2"><h2 id="997ec4d8">C 포인터(Pointer)</h2><div class="outline-text-2"id="text-997ec4d8"><p><a href="c-language.html">C 언어</a>를 악명높게 한 개념이 바로 이 포인터다. 이름 처럼 뭔가를 가리키기 위해 사용되는 개념인데 주로 가리키는 대상은 메모리의 위치(주소)다. 과거에는 하드웨어를 직접 액세스하기 위한 목적으로 정적인 메모리 주소를 포인팅하는 경우도 있지만 현대에서 이렇게 쓰는 경우는 없다. 현대에는 메모리 공유나 기본 타입 이외의 고차원적인 데이터를 취급할 때 많이 사용된다.</p></div></div><div id="outline-container-096912fa"class="outline-2"><h2 id="096912fa">포인터의 용도</h2><div class="outline-text-2"id="text-096912fa"><p>포인터가 주로 쓰이는 분야는 다음과 같다:</p><ul class="org-ul"><li>메모리 공유: 특정 함수에 넘긴 변수의 값이 함수 내부에서 변경될 수 있다. 위험한 형태이므로 가급적 쓰지 않는 것을 추천하는 패턴이다.</li><li>원시 타입(Primitive Type)을 제외한 타입을 매개변수로 전달할 때: <a href="c-language.html">C 언어</a>는 저수준(?) 언어이기 때문에 <code>struct</code> 등 복잡한 타입의 값을 복사하는 등의 고차원적인 행동은 하지 않기 때문에 이런 복잡한 타입을 다루려면 어쩔 수 없이 포인터를 쓸 수 밖에 없다.</li><li><p>힙 메모리 사용: 원시 타입에서 점유하는 스택 공간은 사용량에 제한이 있다보니 힙(Heap)에서 메모리를 할당 받아서 사용하려면 반드시 포인터가 필요하다.</p><p>물론 이 외에도 여러 용도가 있을 수 있지만 보통 이런 경우에 많이 볼 수 있다.</p></li></ul></div></div><div id="outline-container-60d9d1a4"class="outline-2"><h2 id="60d9d1a4">포인터 문법</h2><div class="outline-text-2"id="text-60d9d1a4"><p>포인터 변수는 특정 타입에 <code>*</code> 를 붙여서 선언한다. 명확하게 하기 위해 타입을 정의할 때 띄어쓰기를 하면 포인터 타입과 일반 타입을 구분할 수 있다.</p><div class="org-src-container"><pre class="src src-c++"><span style="color:#ecbe7b">int</span> <span style="color:#dcaeea">a</span> = <span style="color:#da8548;font-weight:700">0</span>;
<span style="color:#ecbe7b">int</span> *<span style="color:#dcaeea">ptr_a</span> = &amp;a;   <span style="color:#5b6268">/* </span><span style="color:#5b6268">1</span><span style="color:#5b6268"> */</span>
<span style="color:#ecbe7b">int</span>* <span style="color:#dcaeea">ptr_b</span> = &amp;a;   <span style="color:#5b6268">/* </span><span style="color:#5b6268">2</span><span style="color:#5b6268"> */</span>
</pre></div><p>위 1번과 2번 둘 다 같은 용도의 코드지만 2번 코드가 띄어쓰기 덕분인지 <code>int 포인터 타입</code> 이라고 읽히기 유리한 것 같다. 물론 둘 다 허용되는 문법이며 이상하게 (나를 포함해서) 대부분 1번 방식을 많이 사용한다.</p><p><code>&amp;</code> 는 특정 변수의 포인터를 얻기 위해서 사용한다. 즉 <code>&amp;a</code> 는 <code>a</code> 변수의 레퍼런스 포인터를 얻는 코드다.</p><p>위 코드는 결과적으로 <code>ptr_a</code> 와 <code>ptr_b</code> 가 동일하게 a가 사용하는 메모리 공간을 가리키게 된다.</p><p>하지만 <code>a</code> 가 정수형임에 비해 <code>ptr_a</code> 와 <code>ptr_b</code> 는 정수 포인터 타입이다. 포인터 타입은 다른 타입의 크기와는 관계 없이 메모리 어드레스를 포인팅 하기 위한 타입이다. 따라서 넣을 수 있는 데이터의 한계도 원래의 타입과는 전혀 다르다.</p><p>포인터 변수의 내용을 바꾸는 것은 굉장히 위험한 일이다.</p><div class="org-src-container"><pre class="src src-c++">ptr_a = <span style="color:#da8548;font-weight:700">1</span>;
</pre></div><p>아마 최근의 컴파일러라면 위 코드는 컴파일 시 경고를 낼 만한 코드인데, 이 코드는 <code>ptr_a</code> 가 1번 메모리 어드레스를 가리키게 한다. 여기를 읽거나 쓰는 행위는 어떤 결과가 발생할 지 알 수가 없으므로 포인터 변수에 직접 값을 할당하는 행위는 하지 말자.</p><p>포인터의 내용을 액세스하기 위해 <code>*</code> 를 사용한다.</p><div class="org-src-container"><pre class="src src-c++">*ptr_a = <span style="color:#da8548;font-weight:700">1</span>;
</pre></div><p>이 코드는 <code>ptr_a</code> 가 가리키는 곳에 1을 쓴다는 의미다. 따라서 이 코드가 실행되면 <code>a</code> 변수의 값이 1로 바뀐다.</p></div></div><div id="outline-container-7ac4516b"class="outline-2"><h2 id="7ac4516b">배열과 포인터</h2><div class="outline-text-2"id="text-7ac4516b"><p>포인터는 배열과 매치하기 편한 편이다.</p><div class="org-src-container"><pre class="src src-c++"><span style="color:#ecbe7b">int</span> <span style="color:#dcaeea">lst</span><span style="color:#51afef">[]</span> = <span style="color:#51afef">{</span> <span style="color:#da8548;font-weight:700">0</span>, <span style="color:#da8548;font-weight:700">1</span>, <span style="color:#da8548;font-weight:700">2</span>, <span style="color:#da8548;font-weight:700">3</span>, <span style="color:#da8548;font-weight:700">4</span>, <span style="color:#da8548;font-weight:700">5</span> <span style="color:#51afef">}</span>;
<span style="color:#ecbe7b">int</span> *<span style="color:#dcaeea">ptr_lst</span> = <span style="color:#51afef">(</span><span style="color:#ecbe7b">int</span> *<span style="color:#51afef">)</span>lst;
</pre></div><p>이제 포인터를 활용해 이런 짓을 할 수도 있다.</p><div class="org-src-container"><pre class="src src-c++">printf<span style="color:#51afef">(</span><span style="color:#98be65">"first = %d, second = %d"</span>, *ptr_lst, *<span style="color:#c678dd">(</span>ptr_lst + <span style="color:#da8548;font-weight:700">1</span><span style="color:#c678dd">)</span><span style="color:#51afef">)</span>;
</pre></div><p>배열은 연속적인 메모리로 할당된다. 포인터는 연속적인 메모리를 탐색하기에 편하다.</p><p>포인터 변수에 증감을 하는 행위는 해당 포인터가 어떤 타입의 포인터냐에 따라 실제로 가리키는 곳이 달라진다.</p><p>예를 들어 32비트 정수형 포인터 변수의 값에 1을 더하면 이 포인터가 가리키는 실제 주소는 원래에서 4바이트(32비트)가 증가된 곳이다.</p><p>포인터는 과거에는 물리적 메모리 어드레스를 다루기도 했는데 현대의 OS들은 가상 어드레스를 사용한다. 그래서 다른 언어들에서 쓰는 레퍼런스 개념과 비슷하게 생각해도 크게 틀리거나 하지는 않는다.</p><p>하지만 레퍼런스와 포인터가 완전히 같은 개념이 아니라는 것은 확실하게 이해하자.</p></div></div><div class="mid-ad-container"><ins class="adsbygoogle mid-ad"style="display:block"data-ad-client="ca-pub-1071465863344332"data-ad-slot="4306465772"data-ad-format="auto"data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class="backlinks-container"><hr><h1>이 글을 링크하는 글들</h1><div class="article-link"><div class="article-link-title-block"><h2><a class="article-link-title"href="/note/c-language.html">❏ C 언어</a></h2><span class="article-description">C 언어에 대한 이야기들</span><span class="article-link-date"> Updated on 2021년 6월 5일</span></div></div></div></section></div><div class="footer-content"><footer>Copyright 2019 ~ 2020. Seorenn all rights reserved.</footer></div><script async src="https://www.googletagmanager.com/gtag/js?id=UA-44534026-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-44534026-1")</script></body></html>