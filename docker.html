<!DOCTYPE html>
<html lang="kr">
<head>
<!-- 2019-12-01 Sun 01:35 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Docker - Seorenn Static Pages</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Heeseung Seo (Seorenn)">
<meta name="description" content="도커(Docker)의 간단한 소개 및 관련 글들">
<meta property="og:title" content="Docker" />
<meta property="og:description" content="도커(Docker)의 간단한 소개 및 관련 글들" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://k.kakaocdn.net/dn/cnRXKA/btqz6G8Whsb/wIGiF8HsFyxVn5UNmxse10/img.png" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Docker" />
<meta name="twitter:description" content="도커(Docker)의 간단한 소개 및 관련 글들" />
<meta name="twitter:image" content="https://k.kakaocdn.net/dn/cnRXKA/btqz6G8Whsb/wIGiF8HsFyxVn5UNmxse10/img.png" />
<meta name="twitter:site" content="@seorenn" />
<meta name="twitter:creator" content="@seorenn" />
<link rel="stylesheet" type="text/css" href="/static/style.css"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<link rel="canonical" href="https://seorenn.github.io/docker.html"/>
<link property="og:url" href="https://seorenn.github.io/docker.html"/>
<meta name="google-site-verification" content="YqTFZuthbvGIlDE1dhxiTjZ3m-GfyNs_rsHaOlPKpug" />
<meta name="naver-site-verification" content="ebf6a89968fd9f447c1a77d83e2c4aa9bdbb0345"/>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-44534026-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-44534026-1');
</script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">Docker</h1>
<h2><a href="/">Seorenn Static Pages</a></h2></header><p>
도커는 정석적인 설명으론 컨테이너 기반 가상화 플랫폼이라고 소개하곤 합니다. 물론 이
말만으론 딱이 와닿는 설명은 아닐거예요. 개인적으론 그저 가상으로 OS 수준까지
샌드박스를 만들어 주는 것처럼 보이지만 실제로 가상화는 아닌 (&#x2026;) 멋진 도구라고
생각할 뿐입니다.
</p>

<p>
개인적으로 개발단계나 서비스 단계에서 자주 사용하지만, 특정 유틸리티나 서비스를
사용하기 위해서도 종종 사용합니다.
</p>

<hr>

<div id="outline-container-org3e86005" class="outline-2">
<h2 id="org3e86005">기본 사용법</h2>
<div class="outline-text-2" id="text-org3e86005">
<ul class="org-ul">
<li><code>docker images</code> 이미지 리스트 보기</li>
<li><code>docker pull IMAGE_NAME</code> 이미지 다운로드 받기</li>
<li><code>docker build .</code> 현재 디렉토리에 있는 Dockerfile 명세로 빌드하기</li>
<li><code>docker build -t IMAGE_NAME .</code> 이미지를 특정 이름으로 빌드하기</li>
<li><code>docker build -t IMAGE_NAME:TAG_NAME .</code> 태그까지 붙여서 이미지
빌드하기(태그는 옵션)</li>
<li><code>docker -f /foo/bar/some-dockerfile build -t IMAGE_NAME:TAG_NAME .</code> Dockerfile 이 다른
경로에 있거나 혹은 Dockerfile 대신 다른 파일 이름을 사용한다면 이런 식으로 -f 옵션을 쓸 수 있습니다.</li>
<li><code>docker run IMAGE_NAME</code> 특정 이미지 컨테이너 띄우기</li>
<li><code>docker run IMAGE_NAME:TAG_NAME</code> 특정 태그(버전)의 이미지를 띄우기</li>
<li><code>docker run -d IMAGE_NAME</code> 데몬(백그라운드) 모드로 실행하기</li>
<li><code>docker run --rm -it IMAGE_NAME COMMAND</code> 종료하면 사라지는(&#x2013;rm) 컨테이너로
터미널(-it) 커맨드 실행하기</li>
<li><code>docker run -p HOST_PORT:CONTAINER_PORT COMMAND</code> 호스트 포트와 컨테이너 포트를
연결해서 컨테이너를 띄워서 커맨드 실행하기</li>
<li><code>docker run -v HOST_PATH:CONTAINER_PATH COMMAND</code> 호스트 디렉토리와 컨테이너
디렉토리를 볼륨으로 연결해서 컨테이너를 띄워 커맨드 실행하기(호스트와 데이터
공유 시)</li>
<li><code>docker ps</code> 살아있는(?) 컨테이너 리스트 보기</li>
<li><code>docker ps -a</code> 모든 컨테이너 리스트 보기</li>
<li><code>docker exec -it CONTAINER_ID COMMAND</code> 특정 동작 중인 컨테이너에서 커맨드 실행하기</li>
<li><code>docker logs CONTAINER_ID</code> 로그 보기</li>
<li><code>docker logs CONTAINER_ID --tail 10</code> 로그 마지막 끝 10줄만 보기</li>
<li><code>docker logs -f CONTAINER_ID</code> 로그 갱신 계속 모니터링 하기</li>
<li><code>docker stop CONTINER_ID</code> 컨테이너 중지</li>
<li><code>docker rm CONTAINER_ID</code> 컨테이너 삭제</li>
<li><code>docker rmi IMAGE_NAME</code> 이미지 삭제하기</li>
<li><code>docker system prune -a</code> 실행 중이지 않은 모든 컨테이너와 이미지를 삭제 (주로
시스템 공간 확보를 위해 사용)</li>
</ul>
</div>
</div>
<div id="outline-container-org4e6dbf2" class="outline-2">
<h2 id="org4e6dbf2">활용 예제</h2>
<div class="outline-text-2" id="text-org4e6dbf2">
</div>
<div id="outline-container-org1ce8978" class="outline-3">
<h3 id="org1ce8978">구 버전 MongoDB CLI 가 필요할 때</h3>
<div class="outline-text-3" id="text-org1ce8978">
<div class="org-src-container">
<pre class="src src-bash">docker run --rm -it mongo:2 /bin/bash
</pre>
</div>
<p>
개인적으로 mongo 2.x 가 필요할 때는 이걸로 몽고 2.x 이미지의 쉘을 띄워서 안에서
<code>mongo</code> 커맨드를 사용해 접속합니다. 물론 쉘을 띄우지 않고 바로 <code>mongo</code> 커맨드를
이용해도 됩니다.
</p>
<div class="org-src-container">
<pre class="src src-bash">docker run --rm -it mongo:2 mongo --host db.foo.bar
</pre>
</div>
<p>
그냥 2.x 를 안 쓰는 것이 가장 좋겠습니다만&#x2026;😭
</p>
</div>
</div>
</div>
<div id="outline-container-org5ad9123" class="outline-2">
<h2 id="org5ad9123">공간 비우기</h2>
<div class="outline-text-2" id="text-org5ad9123">
<p>
No space left 에러 혹은 디스크 공간 부족으로 인해 이미지들이나 각종 컨테이너를
삭제해야 할 경우 아래의 커맨드를 이용할 수 있습니다.
</p>
<div class="org-src-container">
<pre class="src src-bash">docker <span style="color: #ECBE7B;">rm</span> $<span style="color: #51afef;">(</span>docker ps -q -f <span style="color: #98be65;">'status=exited'</span><span style="color: #51afef;">)</span>
docker rmi $<span style="color: #51afef;">(</span>docker images -q -f <span style="color: #98be65;">"dangling=true"</span><span style="color: #51afef;">)</span>
docker volume <span style="color: #ECBE7B;">rm</span> $<span style="color: #51afef;">(</span>docker volume <span style="color: #ECBE7B;">ls</span> -qf <span style="color: #dcaeea;">dangling</span>=true<span style="color: #51afef;">)</span>
</pre>
</div>
<p>
위 커맨드는 종료된 컨테이너와 사용되지 않는 이미지와 볼륨을 순차적으로 지우는 명령입니다.
</p>
</div>
</div>
<div id="outline-container-org265585c" class="outline-2">
<h2 id="org265585c">기타 메모</h2>
<div class="outline-text-2" id="text-org265585c">
</div>
<div id="outline-container-org4d471d8" class="outline-3">
<h3 id="org4d471d8">컨테이너에서 호스트 포트에 접근하기(macOS)</h3>
<div class="outline-text-3" id="text-org4d471d8">
<p>
네트워크 구현 문제로 호스트에 열려있는 포트들 - 특히 도커에 의해 열리지 않은
포트들 - 에 접근하려면 <code>host.docker.internal</code> 라는 특수한 이름으로 접속하면 됩니다.
예를 들어 내 컴퓨터에 MongDB 를 27017 포트로 열어놓은 상태에서, 리눅스 도커
컨테이너에서 이 MongoDB에 접속하려면 아래와 같은 식의 커맨드를 사용할 수
있습니다.
</p>
<div class="org-src-container">
<pre class="src src-bash">mongo mongodb://host.docker.internal:27017/dbname
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org62b2a93" class="outline-2">
<h2 id="org62b2a93">관련글</h2>
<div class="outline-text-2" id="text-org62b2a93">
<ul class="org-ul">
<li><a href="dockerfile.html">Dockerfile</a></li>
<li><a href="docker-compose.html">Docker Compose</a></li>
<li><a target="_blank" href="https://seorenn.tistory.com/20">Docker에서 macOS 호스트 포트에 접근하기</a></li>
</ul>
</div>
</div>
<div id="footer"><div id="time">2019년 12월 01일 마지막으로 수정됨</div><div id="copyright">Copyright 2019 Heeseung Seo (Seorenn)</div></div></div>
</body>
</html>
