<!DOCTYPE html><html lang="ko"><head><meta charset="utf-8"><meta name="viewport"content="width=device-width,initial-scale=1"><meta http-equiv="Content-Type"content="text/html; charset=UTF-8"><link rel="stylesheet"href="/static/style.min.css"><meta name="battery-savings"content="allow-reduced-framerate allow-reduced-script-speed"><title>Celery로 해보는 비동기 분산처리 기초 - Seorenn Note</title><meta name="twitter:title"content="Celery로 해보는 비동기 분산처리 기초"><meta name="og:title"content="Celery로 해보는 비동기 분산처리 기초"><meta name="description"content="Celery의 설치 및 패키지 사용법, 간단한 워커 서버 사용법 등을 정리하는 글"><meta name="twitter:description"content="Celery의 설치 및 패키지 사용법, 간단한 워커 서버 사용법 등을 정리하는 글"><meta name="og:description"content="Celery의 설치 및 패키지 사용법, 간단한 워커 서버 사용법 등을 정리하는 글"><link rel="canonical"href="https://seorenn.github.io/note/celery-dist-async-tasks.html"><meta property="og:url"content="https://seorenn.github.io/note/celery-dist-async-tasks.html"><link rel="shortcut icon"type="image/x-icon"href="/static/favicon.ico"><meta name="twitter:image"content="https://seorenn.github.io/static/seorenn-symbol.png"><meta property="og:image"content="https://seorenn.github.io/static/seorenn-symbol.png"><meta property="og:image:width"content="520"><meta property="og:image:height"content="329"><meta name="twitter:card"content="summary"><meta name="twitter:site"content="@seorenn"><meta name="twitter:creator"content="@seorenn"><meta property="og:type"content="article"><meta property="og:site_name"content="Seorenn"><meta property="og:locale"content="ko_KR"><meta name="referrer"content="unsafe-url"><meta name="robots"content="follow,index"><meta name="google-site-verification"content="YqTFZuthbvGIlDE1dhxiTjZ3m-GfyNs_rsHaOlPKpug"><meta name="naver-site-verification"content="24609571c04926ab1220d5d02610efa1c9e12221"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script data-ad-client="ca-pub-1071465863344332"async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div class="header-content"><header class="top-header"><div class="logo-container"><span class="vertical-center-helper"></span> <a href="/"title="Seorenn"><img class="site-logo"src="/static/seorenn-note-logo-light.png"alt="Seorenn Note"></a><nav><span class="vertical-center-helper"></span> <a href="/"title="Home">HOME</a> | <a href="/note"title="All Notes">NOTES</a></nav></div></header></div><div class="content-container"><section class="content"><div class="mid-ad-container"><ins class="adsbygoogle mid-ad"style="display:block"data-ad-client="ca-pub-1071465863344332"data-ad-slot="4306465772"data-ad-format="auto"data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><header><h1>Celery로 해보는 비동기 분산처리 기초</h1><div class="title-date">2020년 6월 22일 수정</div></header><div id="table-of-contents"role="doc-toc"><h2>≡ 목차 (Table of Contents)</h2><div id="text-table-of-contents"role="doc-toc"><ul><li><a href="#f6c3e57e">설치</a></li><li><a href="#6bce3880">브로커(Broker) 준비</a></li><li><a href="#c469ae56">태스크 작성</a></li><li><a href="#07ba81d8">워커(worker) 띄우기</a></li><li><a href="#c735efc5">태스크(task) 호출하기</a></li><li><a href="#cddd7f20">결과 받아보기</a></li><li><a href="#4f65b655">마무리</a></li></ul></div></div><p>이 글은 <a href="python.html">Python</a>의 <a href="celery.html">Celery</a>를 이용해 비동기 분산처리 방법을 아주 간단히 정리한다.</p><div id="outline-container-f6c3e57e"class="outline-2"><h2 id="f6c3e57e">설치</h2><div class="outline-text-2"id="text-f6c3e57e"><p><a href="celery.html">Celery</a>는 보통의 패키지처럼 pip로 그냥 설치하면 된다.</p><div class="org-src-container"><pre class="src src-bash">pip install celery
</pre></div></div></div><div id="outline-container-6bce3880"class="outline-2"><h2 id="6bce3880">브로커(Broker) 준비</h2><div class="outline-text-2"id="text-6bce3880"><p>셀러리는 태스크의 요청과 응답을 중간에서 도와주는 브로커가 필요하다. RabbitMQ나 Redis 등 다양한 브로커가 있으니 지원되는 것을 미리 준비해놓자. 이 글에서는 redis가 <code>redis</code> 라는 호스트 이름의 6379 포트에서 돌아가고 있다고 가정한다.</p></div></div><div id="outline-container-c469ae56"class="outline-2"><h2 id="c469ae56">태스크 작성</h2><div class="outline-text-2"id="text-c469ae56"><p>우선 당연하겠지만 모듈을 import 해야한다.</p><div class="org-src-container"><pre class="src src-python"><span style="color:#51afef">from</span> celery <span style="color:#51afef">import</span> Celery
</pre></div><p>이제 셀러리 인스턴스를 만들어서 브로커 세팅을 해야한다.</p><div class="org-src-container"><pre class="src src-python"><span style="color:#dcaeea">app</span> = Celery(<span style="color:#98be65">'mytask'</span>,
             broker=<span style="color:#98be65">'redis://redis:6379/0'</span>)
</pre></div><p>이제 남은 일은 태스크를 코딩하는 일이다. 아래의 코드를 추가로 구현한다.</p><div class="org-src-container"><pre class="src src-python"><span style="color:#ecbe7b">@app.task</span>
<span style="color:#51afef">def</span> <span style="color:#c678dd">print_task</span>(message):
    <span style="color:#51afef">print</span>(f<span style="color:#98be65">'print_task: {message}'</span>)
</pre></div><p>위의 코드들이 순서대로 <code>app.py</code> 라는 파일에 몽땅 작성되었다고 가정하자.</p></div></div><div id="outline-container-07ba81d8"class="outline-2"><h2 id="07ba81d8">워커(worker) 띄우기</h2><div class="outline-text-2"id="text-07ba81d8"><p>아래 명령으로 워커를 띄울 수 있다.</p><div class="org-src-container"><pre class="src src-bash">celery -A app worker
</pre></div><p>백그라운드 데몬이 아니라 일반 프로세스처럼 돌아가는데, 요즘은 <a href="docker.html">Docker</a>로 돌리는 경우도 많기 때문에 굳이 백그라운드 데몬으로 돌릴 이유는 없을 것 같기도 하다.</p></div></div><div id="outline-container-c735efc5"class="outline-2"><h2 id="c735efc5">태스크(task) 호출하기</h2><div class="outline-text-2"id="text-c735efc5"><p>이제 원격으로 태스크를 호출해보자. 아래는 <a href="python.html">Python</a> 인터프리터로 호출해 보는 예제다.</p><div class="org-src-container"><pre class="src src-python">&gt;&gt;&gt; <span style="color:#51afef">from</span> app <span style="color:#51afef">import</span> print_task
&gt;&gt;&gt; print_task.delay(<span style="color:#98be65">'Hello, World!'</span>)
&lt;AsyncResult: ...&gt;
</pre></div><p>이렇게 하면 현재 떠있는 워커(worker)에서 해당 태스크가 실행되는 것을 볼 수 있다. 즉 워커 로그에 아래와 같은 로그가 표시되면 성공이다.</p><div class="org-src-container"><pre class="src src-text">print_task: Hello, World!
</pre></div></div></div><div id="outline-container-cddd7f20"class="outline-2"><h2 id="cddd7f20">결과 받아보기</h2><div class="outline-text-2"id="text-cddd7f20"><p>위의 내용은 단순 프로시져를 구동하기엔 나쁘지 않지만, 일반 함수들 같은 경우 반환되는 결과를 받아야만 한다. 이런 반환값을 받기 위해서는 우선 백엔드(backend) 설정이 추가로 필요하다.</p><p>여러 방법이 있겠지만 여기서는 브로커로 사용하는 redis를 재활용해보자.</p><div class="org-src-container"><pre class="src src-python"><span style="color:#dcaeea">app</span> = Celery(<span style="color:#98be65">'mytask'</span>,
             broker=<span style="color:#98be65">'redis://redis:6379/0'</span>,
             backend=<span style="color:#98be65">'redis://redis:6379/0'</span>)
</pre></div><p><code>app</code> 인스턴스를 위처럼 생성하도록 수정했다.</p><p>이제 아래와 같은 태스크를 추가로 구현해보자.</p><div class="org-src-container"><pre class="src src-python"><span style="color:#ecbe7b">@app.task</span>
<span style="color:#51afef">def</span> <span style="color:#c678dd">add</span>(a, b):
    <span style="color:#51afef">return</span> a + b
</pre></div><p>단순하지만 목적이 완벽한 코드다.</p><p>위 <code>add</code> 태스크를 원격으로 호출해보자. 역시 <a href="python.html">Python</a> 인터프리터로 호출한 예다.</p><div class="org-src-container"><pre class="src src-python">&gt;&gt;&gt; <span style="color:#51afef">from</span> app <span style="color:#51afef">import</span> add
&gt;&gt;&gt; <span style="color:#dcaeea">r</span> = add.delay(<span style="color:#da8548;font-weight:700">1</span>, <span style="color:#da8548;font-weight:700">2</span>)
&gt;&gt;&gt; r.get(timeout=<span style="color:#da8548;font-weight:700">10</span>)
<span style="color:#da8548;font-weight:700">3</span>
</pre></div><p><code>AsyncResult</code> 타입에서 제공하는 <code>get</code> 메서드를 이용하면 응답을 받을 수 있다. 물론 타임아웃이 발생한다면 워커가 내려갔거나 브로커나 백엔드에 문제가 생겼을 것이다.</p></div></div><div id="outline-container-4f65b655"class="outline-2"><h2 id="4f65b655">마무리</h2><div class="outline-text-2"id="text-4f65b655"><p>이 글은 정말 기초만 겉핥기 하는 수준의 글이다. <a href="celery.html">Celery</a> 자체가 태스크 큐 관리 정책 등 다양한 분산처리를 위한 관리 기능을 제공하기 때문에 이 외에 많은 부분을 알아야 할 것 같다. 다행히도 제법 많이 쓰이는 도구라 인터넷에서 많은 정보를 찾을 수 있으니 참고해보자.</p></div></div><div class="mid-ad-container"><ins class="adsbygoogle mid-ad"style="display:block"data-ad-client="ca-pub-1071465863344332"data-ad-slot="4306465772"data-ad-format="auto"data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class="backlinks-container"><hr><h1>이 글을 링크하는 글들</h1><div class="article-link"><div class="article-link-title-block"><h2><a class="article-link-title"href="/note/celery.html">❏ Celery</a></h2><span class="article-description">셀러리(Celery)에 대한 것들</span><span class="article-link-date"> Updated on 2020년 6월 23일</span></div></div></div></section></div><div class="footer-content"><footer>Copyright 2019 ~ 2020. Seorenn all rights reserved.</footer></div><script async src="https://www.googletagmanager.com/gtag/js?id=UA-44534026-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-44534026-1")</script></body></html>