<!DOCTYPE html><html lang="ko"><head><meta charset="utf-8"><meta name="viewport"content="width=device-width,initial-scale=1"><meta http-equiv="Content-Type"content="text/html; charset=UTF-8"><link rel="stylesheet"href="/static/style.min.css"><meta name="battery-savings"content="allow-reduced-framerate allow-reduced-script-speed"><title>클로저 - Seorenn Note</title><meta name="twitter:title"content="클로저"><meta name="og:title"content="클로저"><meta name="description"content="클로저(Closure)에 대한 이야기들"><meta name="twitter:description"content="클로저(Closure)에 대한 이야기들"><meta name="og:description"content="클로저(Closure)에 대한 이야기들"><link rel="canonical"href="https://seorenn.github.io/note/closure.html"><meta property="og:url"content="https://seorenn.github.io/note/closure.html"><link rel="shortcut icon"type="image/x-icon"href="/static/favicon.ico"><meta name="twitter:image"content="https://seorenn.github.io/static/seorenn-symbol.png"><meta property="og:image"content="https://seorenn.github.io/static/seorenn-symbol.png"><meta property="og:image:width"content="520"><meta property="og:image:height"content="329"><meta name="twitter:card"content="summary"><meta name="twitter:site"content="@seorenn"><meta name="twitter:creator"content="@seorenn"><meta property="og:type"content="article"><meta property="og:site_name"content="Seorenn"><meta property="og:locale"content="ko_KR"><meta name="referrer"content="unsafe-url"><meta name="robots"content="follow,index"><meta name="google-site-verification"content="YqTFZuthbvGIlDE1dhxiTjZ3m-GfyNs_rsHaOlPKpug"><meta name="naver-site-verification"content="24609571c04926ab1220d5d02610efa1c9e12221"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1071465863344332"crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-44534026-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-44534026-1")</script></head><body><div class="header-content"><header class="top-header"><div class="logo-container"><span class="vertical-center-helper"></span> <a href="/"title="Seorenn"><img class="site-logo"src="/static/seorenn-note-logo-light.png"alt="Seorenn Note"></a><nav><span class="vertical-center-helper"></span> <a href="/"title="Home">HOME</a> | <a href="/note"title="All Notes">NOTES</a> | <a href="https://seorenn.tistory.com"title="Blog"target="_blank">LOGS</a></nav></div></header></div><div class="content-container"><section class="content"><div class="mid-ad-container"><ins class="adsbygoogle mid-ad"style="display:block"data-ad-client="ca-pub-1071465863344332"data-ad-slot="4306465772"data-ad-format="auto"data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><header><h1>클로저</h1><div class="title-date">2020년 6월 18일 수정</div></header><div id="table-of-contents"role="doc-toc"><h2>≡ 목차 (Table of Contents)</h2><div id="text-table-of-contents"role="doc-toc"><ul><li><a href="#c64282ad">Javascript의 클로저</a></li><li><a href="#aa905561">Swift의 클로저</a></li><li><a href="#88ff6f04">Objective-C 블록</a></li><li><a href="#3c86f914">Python의 클로저와 람다 함수</a></li><li><a href="#d361b195">생각해 볼 일</a></li></ul></div></div><p>개인적으로 컴퓨터 프로그래밍 개념에서 클로저(Closure)는 동적으로 생성되는 함수라고 정의한다. 그리고 생성되는 시점의 주변 환경을 복제하는 특수한 능력을 갖추고 있다는 점이 공통적이기도 할 것 같다. 정확한 특징은 아니지만 이름 없는(익명) 함수라고도 불릴 때도 있다.</p><div id="outline-container-c64282ad"class="outline-2"><h2 id="c64282ad">Javascript의 클로저</h2><div class="outline-text-2"id="text-c64282ad"><p>아마도 아래와 같은 구조의 예제는 인터넷에서 클로저에 관해 찾아보면 쉽게 발견할 수 있는 <a href="javascript.html">Javascript</a> 클로저의 예제일 것이다.</p><div class="org-src-container"><pre class="src src-javascript"><span style="color:#51afef">function</span> <span style="color:#c678dd">generateClosure</span>(<span style="color:#dcaeea">x</span>) {
    <span style="color:#51afef">return</span> <span style="color:#51afef">function</span>(<span style="color:#dcaeea">y</span>) {
        <span style="color:#51afef">return</span> x + y;
    }
}
</pre></div><p>이런 예가 자주 언급되는 이유가 있다. 앞서 설명했던 클로저의 다양한 특성이 많이 드러나는 예이기 때문이다.</p><p>우선 동적 생성 함수라는 점이다. <code>generateClosure()</code> 함수 안에서 이름이 없는 함수를 리턴하고 있다. 이 함수는 코드를 해석하는 시점에서는 존재하지 않다가 이 <code>generateClose()</code> 함수가 호출되어야만 생성된다.</p><p>반환되는 함수는 이름이 없다. 즉 이름 없는 함수다. 거기다 이 <code>generateClose()</code> 함수가 아니면 이 함수를 구할 방법이 없다.</p><p>나머지 주요 특성은 바로 주변 환경을 복제한다는 점이다. 아래 예제는 위 코드를 호출하고 어떤 결과가 나오는지를 보기 위한 예제다.</p><div class="org-src-container"><pre class="src src-javascript">&gt; <span style="color:#51afef">let</span> <span style="color:#dcaeea">c</span> = generateClosure(<span style="color:#da8548;font-weight:700">1</span>);
&gt; c(<span style="color:#da8548;font-weight:700">2</span>);
<span style="color:#da8548;font-weight:700">3</span>
&gt; <span style="color:#51afef">let</span> <span style="color:#dcaeea">d</span> = generateClosure(<span style="color:#da8548;font-weight:700">2</span>);
&gt; d(<span style="color:#da8548;font-weight:700">2</span>);
<span style="color:#da8548;font-weight:700">4</span>
</pre></div><p>여기서 <code>c</code> 와 <code>d</code> 를 같은 매개변수로 호출했음에도 결과가 다르다는 것에 주목하자.</p><p><code>generateClose()</code> 함수 안에서 반환하는 클로저는 앞서 이야기했지만 호출 시점에 동적으로 생성된다. 이 생성되는 시점의 <code>x</code> 의 값을 복제해서 가져간다. 주변 환경을 복제한다는 말은 바로 이 부분이다.</p><p>개념은 이렇게 되는데, 클로저가 자주 쓰이는 분야는 아무래도 핸들러(handler) 혹은 콜백(callback) 구현인 것 같다.</p><div class="org-src-container"><pre class="src src-javascript">setTimeout(<span style="color:#51afef">function</span>() {
    console.log(<span style="color:#98be65">'over 2 seconds!'</span>);
}, <span style="color:#da8548;font-weight:700">2000</span>);
</pre></div><p><code>setTimeout()</code> 함수는 특정 시간 뒤 특정 명령을 실행시키는 함수다. 여기서 첫 매개변수로 이름 없는 함수를 넘기는데 이것도 클로저다.</p><p>이 외에 화살표 함수(Arrow Function)의 경우도 동적으로 생성되는 이름 없는 함수이기 때문에 클로저로 볼 수 있다.</p><div class="org-src-container"><pre class="src src-javascript">&gt; <span style="color:#51afef">let</span> <span style="color:#dcaeea">adder</span> = (x, y) =&gt; x + y;
&gt; adder(<span style="color:#da8548;font-weight:700">1</span>, <span style="color:#da8548;font-weight:700">2</span>)
<span style="color:#da8548;font-weight:700">3</span>
</pre></div></div></div><div id="outline-container-aa905561"class="outline-2"><h2 id="aa905561">Swift의 클로저</h2><div class="outline-text-2"id="text-aa905561"><p><a href="swift.html">Swift</a>의 클로저도 위의 개념적인 부분은 거의 동일하다.</p><div class="org-src-container"><pre class="src src-swift"><span style="color:#51afef">let</span> adder: (<span style="color:#c678dd">Int</span>, <span style="color:#c678dd">Int</span>) -&gt; <span style="color:#c678dd">Int</span> = {
    (x, y) <span style="color:#51afef">in</span>
    <span style="color:#51afef">return</span> x + y
}
</pre></div><p>문법의 차이만 있을 뿐이지 이름도 없고 동적으로 생성되는 데다 주변 환경을 복제하는 것은 거의 동일하다.</p><p>하지만 차이도 있다.</p><p>Swift의 메모리 관리 체계인 <a href="arc.html">ARC</a>의 특징으로 인해 주변 환경 복제 뿐만 아니라 납치(Capture) 문제도 발생하게 된다. 값(value) 타입이 아닌 인스턴스의 경우 리테인 카운드를 증가시키게 되어서 메모리 해제를 제때 하지 못 하는 등의 문제를 발생시킬 수도 있다.</p><p>그래서 납치 규칙(capture rule) 같은 것도 정의할 수 있다.</p><div class="org-src-container"><pre class="src src-swift"><span style="color:#51afef">let</span> selfAdder: (<span style="color:#c678dd">Int</span>) -&gt; <span style="color:#c678dd">Int</span> = {
    [<span style="color:#51afef">unowned</span> <span style="color:#51afef">self</span>] (y) <span style="color:#51afef">in</span>
    <span style="color:#51afef">return</span> <span style="color:#51afef">self</span>.<span style="color:#c678dd">x</span> + y
}
</pre></div><p>위의 코드는 <code>unowned</code> 를 통해 <code>self</code> 에 대해 <code>weak</code> 참조를 하도록 하는 예이다. 이렇게 하면 위의 클로저의 메모리가 해제되지 않으면 <code>self</code> 도 해제되지 않는 문제를 해결할 수 있다.</p></div></div><div id="outline-container-88ff6f04"class="outline-2"><h2 id="88ff6f04">Objective-C 블록</h2><div class="outline-text-2"id="text-88ff6f04"><p><a href="objective-c.html">Objective-C</a>의 경우 블록 문법이라는 클로저와 비슷한 기능이 제공된다.</p><div class="org-src-container"><pre class="src src-objective-c">int (^adder)(int, int) = ^int(int x, int y) {
    return x + y;
};
</pre></div><p><code>^</code> 가 붙어있는 곳이 이 블록을 담는 변수의 이름이다. 어차피 클로저처럼 이름이 없다보니 변수에 담거나 아니면 익명으로 넘기거나 등으로 써야 한다.</p><p><a href="swift.html">Swift</a>의 납치 규칙과 비슷한 문제로 블록 내부에서 특정 인스턴스를 참조할 때 약하게(weak) 참조하는 것도 비슷하다.</p><div class="org-src-container"><pre class="src src-objective-c">__weak MyClassType *wealSelf = self;
int (^selfAdder)(int) = ^int(int y) {
    return weakSelf.x + y;
};
</pre></div></div></div><div id="outline-container-3c86f914"class="outline-2"><h2 id="3c86f914">Python의 클로저와 람다 함수</h2><div class="outline-text-2"id="text-3c86f914"><p><a href="python.html">Python</a>의 경우는 앞서 소개한 것들과 약간 다르게 익명이라기 보다는 그냥 동적으로 생성되는 함수 정도의 소개가 맞는 것 같다.</p><div class="org-src-container"><pre class="src src-python">&gt;&gt;&gt; <span style="color:#51afef">def</span> <span style="color:#c678dd">gen_closure</span>(x):
...     <span style="color:#51afef">def</span> <span style="color:#c678dd">closure</span>(y):
...         <span style="color:#51afef">return</span> x + y
...     <span style="color:#51afef">return</span> closure
...
&gt;&gt;&gt; <span style="color:#dcaeea">c</span> = gen_closure(<span style="color:#da8548;font-weight:700">1</span>)
&gt;&gt;&gt; c(<span style="color:#da8548;font-weight:700">2</span>)
<span style="color:#da8548;font-weight:700">3</span>
&gt;&gt;&gt; <span style="color:#dcaeea">d</span> = gen_closure(<span style="color:#da8548;font-weight:700">2</span>)
&gt;&gt;&gt; d(<span style="color:#da8548;font-weight:700">2</span>)
<span style="color:#da8548;font-weight:700">4</span>
</pre></div><p>함수나 메서드 안에서 특정 함수를 정의하는 경우 이 함수가 바로 클로저라고 이해할 수 있다. 이름이 있을 수 있다는 점만 제외하면 거의 동일한 특성을 보인다.</p><p>이 외에 <a href="python.html">Python</a>의 경우 람다(lambda) 함수라는 특수한 익명 함수를 따로 제공한다. 아래는 람다 함수를 쓰기 위해 잘 안 쓰이는 <code>map</code> 을 사용한 예제이다.</p><div class="org-src-container"><pre class="src src-python">&gt;&gt;&gt; <span style="color:#dcaeea">lst</span> = [<span style="color:#da8548;font-weight:700">1</span>, <span style="color:#da8548;font-weight:700">2</span>, <span style="color:#da8548;font-weight:700">3</span>, <span style="color:#da8548;font-weight:700">4</span>]
&gt;&gt;&gt; <span style="color:#c678dd">list</span>(<span style="color:#c678dd">map</span>(<span style="color:#51afef">lambda</span> x: <span style="color:#c678dd">str</span>(x), lst))
[<span style="color:#98be65">'1'</span>, <span style="color:#98be65">'2'</span>, <span style="color:#98be65">'3'</span>, <span style="color:#98be65">'4'</span>]
</pre></div><p><code>lambda</code> 라는 이름과 함께 매개변수 이름 선언이 오고 단 한 줄의 구현부가 올 수 있다. 보다시피 이름이 없는 익명 함수다.</p></div></div><div id="outline-container-d361b195"class="outline-2"><h2 id="d361b195">생각해 볼 일</h2><div class="outline-text-2"id="text-d361b195"><p>여러 언어의 예제를 살펴봤는데, 이런 편리함을 주는 클로저의 존재에서 생각해야 할 일은 더 있다. 바로 퍼포먼스 문제다.</p><p>앞서 살펴본 클로저의 공통적인 특징은 클로저 생성 당시의 주변 환경을 복제하는 것이다. 당연하게도 클로저가 참조하는 클로저 외부의 변수들을 모두 복제해야 하니 퍼포먼스 문제는 필연적이다.</p><p>그리고 환경 복제는 동시에 메모리 점유가 증가한다는 문제 또한 동시에 가지고 있다.</p><p>따라서 클로저를 꼭 사용해서 좋은 곳과 그렇지 않은 곳도 있다는 것을 이해하고 적절하게 사용하는 것이 가장 좋을 것 같다. 예를 들어 루프 내부에서 클로저를 생성하는 행위가 얼마나 안 좋은 설계일지는 깊게 생각하지 않아도 알 수 있을 것 같다.</p></div></div><div class="mid-ad-container"><ins class="adsbygoogle mid-ad"style="display:block"data-ad-client="ca-pub-1071465863344332"data-ad-slot="4306465772"data-ad-format="auto"data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class="backlinks-container"><hr><h1>이 글을 링크하는 글들</h1><div class="article-link"><div class="article-link-title-block"><h2><a class="article-link-title"href="/note/swift-async-await.html">❏ Swift async/await</a></h2><span class="article-description">Swift의 새로운 비동기 프로그래밍 모델</span><span class="article-link-date"> Updated on 2021년 8월 3일</span></div></div><div class="article-link"><div class="article-link-title-block"><h2><a class="article-link-title"href="/note/arc.html">❏ ARC</a></h2><span class="article-description">Swift와 Objective-C에서 쓰이는 ARC(Automatic Reference Counting) 메모리 관리 시스템</span><span class="article-link-date"> Updated on 2021년 7월 22일</span></div></div><div class="article-link"><div class="article-link-title-block"><h2><a class="article-link-title"href="/note/javascript-arrow-function.html">❏ Javascript 화살표 함수</a></h2><span class="article-description">자바스크립트의 화살표 함수의 소개와 함께 이와 관련된 글들</span><span class="article-link-date"> Updated on 2020년 6월 30일</span></div></div></div></section></div><div class="footer-content"><footer>Copyright 2019 ~ 2020. Seorenn all rights reserved.</footer></div></body></html>