<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>Seorenn</title>
    <link>https://seorenn.github.io</link>
    <description>Seorenn Notes and Logs</description>
    <atom:link href="https://seorenn.github.io" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>https://seorenn.github.io</generator>
    <image>
      <url>https://seorenn.github.io/static/seorenn-symbol.png</url>
      <title>Seorenn</title>
      <link>https://seorenn.github.io</link>
    </image>
    <language>ko</language>
    <lastBuildDate>Sat, 01 Jun 2024 23:30:17 +0900</lastBuildDate>
    <item>
      <title>은행과 NIM과 NIS</title>
      <link>https://seorenn.github.io/article/bank-nim-nis.html</link>
      <description>&lt;p&gt;간혹 경제지 기사를 읽다 보면 은행과 관련된 기사에서 NIM이나 NIS라는 단어를 볼 수 있는데 도대체 무슨 의미일까? '님'이니 '니스'니 뭐 말 장난 하는 것 같기도 하고 말이다. 그래서 대충 찾아보고 적당히 정리해 본다.&lt;/p&gt;
&lt;h2&gt;NIM&lt;/h2&gt;
&lt;p&gt;NIM(Net Interest Margin)은 '순이자마진' 인데 간단히 설명하자면 '이자 장사로 남긴 순수익'이라고 해도 될 것 같다. 좀 딱딱하게 설명하자면 '은행이 자산을 운용해 얻은 수익에서 조달 비용을 뺀 나머지를 운용자산 총액으로 나눈 값'이다.&lt;/p&gt;
&lt;h2&gt;NIS&lt;/h2&gt;
&lt;p&gt;NIS(Net Interest Spread)는 '예대금리차' 즉 대출금리에서 예금금리를 뺀 값으로 볼 수 있다. 이 값은 NIM을 결정하는 중요한 값이기도 하다.&lt;/p&gt;
&lt;h2&gt;의외로 쉬운 용어였다&lt;/h2&gt;
&lt;p&gt;이 글을 쓰게 된 건 어떤 증권사 리포트의 한 문구는 이래서여다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;경쟁은행들과 달리 이자 이익이 높아진 이유는 NIM 상승 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;결과적으로 NIM과 NIS는 '은행이 이자 장사를 얼마나 잘 하나, 잘 할 수 있나'를 나타내는 지표일 뿐이었다.&lt;/p&gt;
&lt;p&gt;왜 쉬운 한국어 한글 놔두고 영문축약어를 쓰냐고 비판할 수는 있겠지만 그건 사람이나 의도에 따라 좀 다르게 판단할 수도 있는 문제라 여기서는 언급하진 않는다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;간혹 경제지 기사를 읽다 보면 은행과 관련된 기사에서 NIM이나 NIS라는 단어를 볼 수 있는데 도대체 무슨 의미일까? '님'이니 '니스'니 뭐 말 장난 하는 것 같기도 하고 말이다. 그래서 대충 찾아보고 적당히 정리해 본다.&lt;/p&gt;
&lt;h2&gt;NIM&lt;/h2&gt;
&lt;p&gt;NIM(Net Interest Margin)은 '순이자마진' 인데 간단히 설명하자면 '이자 장사로 남긴 순수익'이라고 해도 될 것 같다. 좀 딱딱하게 설명하자면 '은행이 자산을 운용해 얻은 수익에서 조달 비용을 뺀 나머지를 운용자산 총액으로 나눈 값'이다.&lt;/p&gt;
&lt;h2&gt;NIS&lt;/h2&gt;
&lt;p&gt;NIS(Net Interest Spread)는 '예대금리차' 즉 대출금리에서 예금금리를 뺀 값으로 볼 수 있다. 이 값은 NIM을 결정하는 중요한 값이기도 하다.&lt;/p&gt;
&lt;h2&gt;의외로 쉬운 용어였다&lt;/h2&gt;
&lt;p&gt;이 글을 쓰게 된 건 어떤 증권사 리포트의 한 문구는 이래서여다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;경쟁은행들과 달리 이자 이익이 높아진 이유는 NIM 상승 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;결과적으로 NIM과 NIS는 '은행이 이자 장사를 얼마나 잘 하나, 잘 할 수 있나'를 나타내는 지표일 뿐이었다.&lt;/p&gt;
&lt;p&gt;왜 쉬운 한국어 한글 놔두고 영문축약어를 쓰냐고 비판할 수는 있겠지만 그건 사람이나 의도에 따라 좀 다르게 판단할 수도 있는 문제라 여기서는 언급하진 않는다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/bank-nim-nis.html</guid>
      <pubDate>Sat, 01 Jun 2024 21:49:00 +0900</pubDate>
    </item>
    <item>
      <title>미국의 4월 PCE는 예상대로</title>
      <link>https://seorenn.github.io/log/20240531-00.html</link>
      <description>&lt;p&gt;오늘은 매 달 찾아오는 대명절 바로 미국 PCE가 발표되는 날이다. 다짜고짜 정리하자면 이렇다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 4월 헤드라인 PCE MoM 0.3% 예상 부합&lt;/li&gt;
&lt;li&gt;미국 4월 헤드라인 PCE YoY 2.7% 예상 부합&lt;/li&gt;
&lt;li&gt;미국 4월 근원 PCE MoM 0.2% (-0.1%) 예상치 하회&lt;/li&gt;
&lt;li&gt;미국 4월 근원 PCE YoY 2.8% 예상 부합&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;참고로 근원 PCE의 MoM 수치가 예상치를 하회한 것처럼 보이는데, 실제로는 0.249%라서 이를 반올림해서 0.2%라는 닉 티미라오스의 알림이 있었다. 즉 예상치 하회라고 보기엔 무리고 부합 정도로 보는 게 맞을 것 같다는 말이다.&lt;/p&gt;
&lt;p&gt;어쨌든 예상대로 나왔다면 크게 나쁠 건 없을 거다. 지난 주부터 주식 시장은 눈치게임이 시작되며 옆으로 기어갔는데 드디어 옆으로 기어가기의 결승선이 나타난 셈이다. 과연 누가 1등일까?&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;오늘은 매 달 찾아오는 대명절 바로 미국 PCE가 발표되는 날이다. 다짜고짜 정리하자면 이렇다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 4월 헤드라인 PCE MoM 0.3% 예상 부합&lt;/li&gt;
&lt;li&gt;미국 4월 헤드라인 PCE YoY 2.7% 예상 부합&lt;/li&gt;
&lt;li&gt;미국 4월 근원 PCE MoM 0.2% (-0.1%) 예상치 하회&lt;/li&gt;
&lt;li&gt;미국 4월 근원 PCE YoY 2.8% 예상 부합&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;참고로 근원 PCE의 MoM 수치가 예상치를 하회한 것처럼 보이는데, 실제로는 0.249%라서 이를 반올림해서 0.2%라는 닉 티미라오스의 알림이 있었다. 즉 예상치 하회라고 보기엔 무리고 부합 정도로 보는 게 맞을 것 같다는 말이다.&lt;/p&gt;
&lt;p&gt;어쨌든 예상대로 나왔다면 크게 나쁠 건 없을 거다. 지난 주부터 주식 시장은 눈치게임이 시작되며 옆으로 기어갔는데 드디어 옆으로 기어가기의 결승선이 나타난 셈이다. 과연 누가 1등일까?&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240531-00.html</guid>
      <pubDate>Fri, 31 May 2024 21:46:00 +0900</pubDate>
    </item>
    <item>
      <title>MozJPEG으로 JPEG 이미지 압축하기</title>
      <link>https://seorenn.github.io/article/mozjpeg-usage.html</link>
      <description>&lt;p&gt;JPEG 이미지 압축 관련 도구 모음인 MozJPEG 사용 방법을 간단히 알아보자. 이 글은 macOS를 기준으로 정리되었다.&lt;/p&gt;
&lt;h2&gt;MozJPEG 설치하기&lt;/h2&gt;
&lt;p&gt;macOS에서는 역시나 Homebrew를 통해 MozJPEG을 쉽게 설치할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;brew install mozjpeg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설치 후 mozjpeg 이라는 바이너리가 없어서 헤멜 수도 있는데, 실제로 설치되는 바이너리 이름은 &lt;code&gt;cjpeg&lt;/code&gt;, &lt;code&gt;djpeg&lt;/code&gt;, &lt;code&gt;jpegtran&lt;/code&gt; 등등 다양하다.&lt;/p&gt;
&lt;h2&gt;기본 사용법&lt;/h2&gt;
&lt;p&gt;기본적으로 아래와 같은 사용 방법을 찾을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;cjpeg -quality 75 input.jpg &amp;gt; output.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 실행하면 75% 압축률로 input.jpg 파일이 output.jpg로 압축이 잘 되...지는 않고 개인적으로는 아래와 같은 오류가 발생하며 비정상 종료되어 버렸다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Unrecognized input file format --- perhaps you need -targa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cjpeg이 타입을 인식하지 못 하는 것으로 추정되는데 메시지와 같은 옵션을 추가해도 해결이 안 되었다.&lt;/p&gt;
&lt;p&gt;어쨌든 글 내용이 좀 이상해졌는데 이제 본론으로 들어가보자.&lt;/p&gt;
&lt;h2&gt;조금 복잡하지만 어쨌든 되는 방법&lt;/h2&gt;
&lt;p&gt;MozJPEG을 통해 같이 설치되는 &lt;code&gt;djpeg&lt;/code&gt;을 이용하면 JPEG 이미지의 압축을 해제할 수 있으니 위처럼 파일 타입을 인식하지 못 하는 경우 이걸 같이 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;djpeg input.jpg | cjpeg -quality 75 &amp;gt; output.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 input.jpg 파일을 75% 수준으로 압축된 output.jpg 파일을 얻을 수 있다.&lt;/p&gt;
&lt;h2&gt;프로그레시브 압축&lt;/h2&gt;
&lt;p&gt;조금 더 욕심을 내고자 한다면 아래처럼 프로그레시브하게 최적화를 거치는 방법도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;djpeg input.jpg | cjpeg -quality 75 -progressive -optimize &amp;gt; output.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경우 압축 효율이 좀 더 좋아지며 점진적 로딩이 되는 프로그레시브 이미지를 얻을 수 있다. 물론 압축 효율이 높다는 말은 처리에 시간이 걸린다는 말이기에 많은 이미지를 한 번에 압축하기엔 좀 부담될 수도 있다.&lt;/p&gt;
&lt;h2&gt;사족&lt;/h2&gt;
&lt;p&gt;이 글에서는 손실(lossy) 압축을 하는 &lt;code&gt;cjpeg&lt;/code&gt;이라는 도구를 다뤘는데, 만약 무손실 압축을 원한다면 &lt;code&gt;jpegtran&lt;/code&gt;의 사용을 고려해보자. 옵션 등 사용 방법은 비슷하다. 단지, 애초에 JPEG 자체가 손실압축 포맷인데 무손실로 뭔가를 한다는 것이 어떤 의미가 있는지는 좀 생각해 볼 필요가 있을 것 같다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/pngquant-usage.html"&gt;pngquant로 PNG 이미지 압축하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;JPEG 이미지 압축 관련 도구 모음인 MozJPEG 사용 방법을 간단히 알아보자. 이 글은 macOS를 기준으로 정리되었다.&lt;/p&gt;
&lt;h2&gt;MozJPEG 설치하기&lt;/h2&gt;
&lt;p&gt;macOS에서는 역시나 Homebrew를 통해 MozJPEG을 쉽게 설치할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;brew install mozjpeg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설치 후 mozjpeg 이라는 바이너리가 없어서 헤멜 수도 있는데, 실제로 설치되는 바이너리 이름은 &lt;code&gt;cjpeg&lt;/code&gt;, &lt;code&gt;djpeg&lt;/code&gt;, &lt;code&gt;jpegtran&lt;/code&gt; 등등 다양하다.&lt;/p&gt;
&lt;h2&gt;기본 사용법&lt;/h2&gt;
&lt;p&gt;기본적으로 아래와 같은 사용 방법을 찾을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;cjpeg -quality 75 input.jpg &amp;gt; output.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 실행하면 75% 압축률로 input.jpg 파일이 output.jpg로 압축이 잘 되...지는 않고 개인적으로는 아래와 같은 오류가 발생하며 비정상 종료되어 버렸다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Unrecognized input file format --- perhaps you need -targa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cjpeg이 타입을 인식하지 못 하는 것으로 추정되는데 메시지와 같은 옵션을 추가해도 해결이 안 되었다.&lt;/p&gt;
&lt;p&gt;어쨌든 글 내용이 좀 이상해졌는데 이제 본론으로 들어가보자.&lt;/p&gt;
&lt;h2&gt;조금 복잡하지만 어쨌든 되는 방법&lt;/h2&gt;
&lt;p&gt;MozJPEG을 통해 같이 설치되는 &lt;code&gt;djpeg&lt;/code&gt;을 이용하면 JPEG 이미지의 압축을 해제할 수 있으니 위처럼 파일 타입을 인식하지 못 하는 경우 이걸 같이 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;djpeg input.jpg | cjpeg -quality 75 &amp;gt; output.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 input.jpg 파일을 75% 수준으로 압축된 output.jpg 파일을 얻을 수 있다.&lt;/p&gt;
&lt;h2&gt;프로그레시브 압축&lt;/h2&gt;
&lt;p&gt;조금 더 욕심을 내고자 한다면 아래처럼 프로그레시브하게 최적화를 거치는 방법도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;djpeg input.jpg | cjpeg -quality 75 -progressive -optimize &amp;gt; output.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경우 압축 효율이 좀 더 좋아지며 점진적 로딩이 되는 프로그레시브 이미지를 얻을 수 있다. 물론 압축 효율이 높다는 말은 처리에 시간이 걸린다는 말이기에 많은 이미지를 한 번에 압축하기엔 좀 부담될 수도 있다.&lt;/p&gt;
&lt;h2&gt;사족&lt;/h2&gt;
&lt;p&gt;이 글에서는 손실(lossy) 압축을 하는 &lt;code&gt;cjpeg&lt;/code&gt;이라는 도구를 다뤘는데, 만약 무손실 압축을 원한다면 &lt;code&gt;jpegtran&lt;/code&gt;의 사용을 고려해보자. 옵션 등 사용 방법은 비슷하다. 단지, 애초에 JPEG 자체가 손실압축 포맷인데 무손실로 뭔가를 한다는 것이 어떤 의미가 있는지는 좀 생각해 볼 필요가 있을 것 같다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/pngquant-usage.html"&gt;pngquant로 PNG 이미지 압축하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/mozjpeg-usage.html</guid>
      <pubDate>Fri, 31 May 2024 20:26:00 +0900</pubDate>
    </item>
    <item>
      <title>pngquant로 PNG 이미지 압축하기</title>
      <link>https://seorenn.github.io/article/pngquant-usage.html</link>
      <description>&lt;p&gt;PNG 이미지 압축 도구인 pngquant의 사용법을 간단히 알아보자. 이 글은 macOS를 기준으로 작성되었다.&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;p&gt;macOS를 기준으로 Homebrew를 이용해 쉽게 설치할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;brew install pngquant
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다른 OS도 각자의 방법에 맞게 어렵지 않게 설치할 수 있을 것 같다.&lt;/p&gt;
&lt;h2&gt;기본 사용법&lt;/h2&gt;
&lt;p&gt;pngquant는 다짜고짜 PNG 이미지 파일의 경로를 입력으로 줘서 실행시켜 보면 그냥 돌아간다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pngquant filename.png
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 식으로 호출하면 &lt;code&gt;filename-fs8.png&lt;/code&gt; 식의 파일로 압축된 결과물이 저장된다. 이 파일을 원하는 용도로 그대로 사용하면 된다. &lt;/p&gt;
&lt;p&gt;압축된 이미지는 당연하게도 실행시킨 디렉터리에 저장되는데, 만약 압축되어 출력되는 파일 이름을 다르게 하거나 다른 디렉터리에 저장하고 싶다면 아래와 같이 &lt;code&gt;-o&lt;/code&gt; 혹은 &lt;code&gt;--output&lt;/code&gt; 옵션을 사용해 출력될 경로를 지정할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pngquant -o /foo/bar/output_filename.png input_filename.png
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;최적화&lt;/h2&gt;
&lt;p&gt;이미지 압축인 만큼 최적화 수준을 결정할 수 있다. 특히 PNG 포맷의 경우 GIF와 비슷하게 정해진 색상 수를 이용해 표현하는데 따라서 이 색상 수를 조절하면 압축률을 조절할 수도 있다. 예를 들자면 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pngquant 64 filename.png
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 압축 시 사용할 색상 수를 결정할 수 있다. 수를 줄이면 더욱 압축이 되지만 그만큼 디더링이 발생하는 등 퀄리티가 처참해지니 잘 조절해야 한다. 개인적으로는 굳이 최적화 옵션을 주지 않아도 마음에 드는 수준으로 압축되는 것 같다.&lt;/p&gt;
&lt;h2&gt;특수한 사용법&lt;/h2&gt;
&lt;p&gt;UNIX 철학에 맞게 pngquant도 stdin 및 stdout을 파이프로 적극적으로 사용할 수 있다. 예를 들자면 아래와 같은 식으로 쓸 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;convert foo | pngquant | foobar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;즉 Imagemagick의 convert 커맨드로 뭔가를 하고 파이프로 그 결과를 받아서 pngquant로 압축한 뒤 출력을 foobar 와 같이 아무런 커맨드에 파이프로 넘겨서 뭔가 마무리 하는 식의 UNIX 철학에 어울리는 커맨드를 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/mozjpeg-usage.html"&gt;MozJPEG으로 JPEG 이미지 압축하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;PNG 이미지 압축 도구인 pngquant의 사용법을 간단히 알아보자. 이 글은 macOS를 기준으로 작성되었다.&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;p&gt;macOS를 기준으로 Homebrew를 이용해 쉽게 설치할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;brew install pngquant
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다른 OS도 각자의 방법에 맞게 어렵지 않게 설치할 수 있을 것 같다.&lt;/p&gt;
&lt;h2&gt;기본 사용법&lt;/h2&gt;
&lt;p&gt;pngquant는 다짜고짜 PNG 이미지 파일의 경로를 입력으로 줘서 실행시켜 보면 그냥 돌아간다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pngquant filename.png
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 식으로 호출하면 &lt;code&gt;filename-fs8.png&lt;/code&gt; 식의 파일로 압축된 결과물이 저장된다. 이 파일을 원하는 용도로 그대로 사용하면 된다. &lt;/p&gt;
&lt;p&gt;압축된 이미지는 당연하게도 실행시킨 디렉터리에 저장되는데, 만약 압축되어 출력되는 파일 이름을 다르게 하거나 다른 디렉터리에 저장하고 싶다면 아래와 같이 &lt;code&gt;-o&lt;/code&gt; 혹은 &lt;code&gt;--output&lt;/code&gt; 옵션을 사용해 출력될 경로를 지정할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pngquant -o /foo/bar/output_filename.png input_filename.png
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;최적화&lt;/h2&gt;
&lt;p&gt;이미지 압축인 만큼 최적화 수준을 결정할 수 있다. 특히 PNG 포맷의 경우 GIF와 비슷하게 정해진 색상 수를 이용해 표현하는데 따라서 이 색상 수를 조절하면 압축률을 조절할 수도 있다. 예를 들자면 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pngquant 64 filename.png
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 압축 시 사용할 색상 수를 결정할 수 있다. 수를 줄이면 더욱 압축이 되지만 그만큼 디더링이 발생하는 등 퀄리티가 처참해지니 잘 조절해야 한다. 개인적으로는 굳이 최적화 옵션을 주지 않아도 마음에 드는 수준으로 압축되는 것 같다.&lt;/p&gt;
&lt;h2&gt;특수한 사용법&lt;/h2&gt;
&lt;p&gt;UNIX 철학에 맞게 pngquant도 stdin 및 stdout을 파이프로 적극적으로 사용할 수 있다. 예를 들자면 아래와 같은 식으로 쓸 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;convert foo | pngquant | foobar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;즉 Imagemagick의 convert 커맨드로 뭔가를 하고 파이프로 그 결과를 받아서 pngquant로 압축한 뒤 출력을 foobar 와 같이 아무런 커맨드에 파이프로 넘겨서 뭔가 마무리 하는 식의 UNIX 철학에 어울리는 커맨드를 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/mozjpeg-usage.html"&gt;MozJPEG으로 JPEG 이미지 압축하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/pngquant-usage.html</guid>
      <pubDate>Fri, 31 May 2024 17:08:00 +0900</pubDate>
    </item>
    <item>
      <title>파이썬에서 홈 디렉토리 경로 처리하기</title>
      <link>https://seorenn.github.io/article/python-home-dir.html</link>
      <description>&lt;p&gt;파이썬에서 경로(path)로 입력받은 문자열 중 &lt;code&gt;~&lt;/code&gt;(틸트)로 시작하는 경우 제대로 처리하지 못 하는 경우가 있는데 이럴 때 해결 방법을 간단히 정리해 보자.&lt;/p&gt;
&lt;p&gt;굳이 정리하자면, POSIX 운영체제의 특징...이라고는 할 수는 없겠지만, 적어도 유닉스나 리눅스, macOS 등의 POSIX 호환 운영체제에서 사용되는 셸들은 &lt;code&gt;~&lt;/code&gt;을 '홈 디렉터리(Home Directory)'라는 의미로 사용한다. 예를 들어 아래의 표현을 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;~/.zshrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 경로는 운영체제 등에 따라 &lt;code&gt;/home/username/.zshrc&lt;/code&gt; 혹은 &lt;code&gt;/Users/username/.zshrc&lt;/code&gt; 등으로 내부적으로 변경되어 동작한다. 즉 &lt;code&gt;~&lt;/code&gt;을 홈 디렉토리로 인식한다는 말이다.&lt;/p&gt;
&lt;p&gt;하지만 파이썬도 그렇고 Emacs Lisp의 경우도 그렇고 다양한 OS에 호환성이 있는 언어들의 경우 &lt;code&gt;~&lt;/code&gt;를 홈 디렉터리로 자동으로 바꿔주지 않는다. 당연하겠지만 이를 홈 디렉터리로 인식해 주는 기능은 셸에서 자체적으로 제공하는 것이기 때문이다.&lt;/p&gt;
&lt;h2&gt;expanduser - 경로에서 홈 디렉토리 확장하기&lt;/h2&gt;
&lt;p&gt;이럴 때를 위해 파이썬에서는 &lt;code&gt;os.path.expanduser&lt;/code&gt; 함수를 이용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.expanduser(&amp;quot;~/.zshrc&amp;quot;)
'/Users/seorenn/.zshrc'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 경우는 macOS에서 구동 중인 REPL에서 사용한 예제다. 보다시피 &lt;code&gt;~&lt;/code&gt;가 사용자의 홈 디렉터리로 잘 변경되는 것을 볼 수 있다. Expand User라는 이름에 걸맡게 축약된 &lt;code&gt;~&lt;/code&gt; 기호를 홈 디렉터리로 확장시켜 준다.&lt;/p&gt;
&lt;p&gt;쓸 데 없이 글이 길어진 것 같다. 어쨌든 셸 스크립팅 목적이라면 자주 사용하게 될 함수 같다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/python-path-tips.html"&gt;파이썬으로 파일이나 디렉터리 경로 다루기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;파이썬에서 경로(path)로 입력받은 문자열 중 &lt;code&gt;~&lt;/code&gt;(틸트)로 시작하는 경우 제대로 처리하지 못 하는 경우가 있는데 이럴 때 해결 방법을 간단히 정리해 보자.&lt;/p&gt;
&lt;p&gt;굳이 정리하자면, POSIX 운영체제의 특징...이라고는 할 수는 없겠지만, 적어도 유닉스나 리눅스, macOS 등의 POSIX 호환 운영체제에서 사용되는 셸들은 &lt;code&gt;~&lt;/code&gt;을 '홈 디렉터리(Home Directory)'라는 의미로 사용한다. 예를 들어 아래의 표현을 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;~/.zshrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 경로는 운영체제 등에 따라 &lt;code&gt;/home/username/.zshrc&lt;/code&gt; 혹은 &lt;code&gt;/Users/username/.zshrc&lt;/code&gt; 등으로 내부적으로 변경되어 동작한다. 즉 &lt;code&gt;~&lt;/code&gt;을 홈 디렉토리로 인식한다는 말이다.&lt;/p&gt;
&lt;p&gt;하지만 파이썬도 그렇고 Emacs Lisp의 경우도 그렇고 다양한 OS에 호환성이 있는 언어들의 경우 &lt;code&gt;~&lt;/code&gt;를 홈 디렉터리로 자동으로 바꿔주지 않는다. 당연하겠지만 이를 홈 디렉터리로 인식해 주는 기능은 셸에서 자체적으로 제공하는 것이기 때문이다.&lt;/p&gt;
&lt;h2&gt;expanduser - 경로에서 홈 디렉토리 확장하기&lt;/h2&gt;
&lt;p&gt;이럴 때를 위해 파이썬에서는 &lt;code&gt;os.path.expanduser&lt;/code&gt; 함수를 이용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.expanduser(&amp;quot;~/.zshrc&amp;quot;)
'/Users/seorenn/.zshrc'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 경우는 macOS에서 구동 중인 REPL에서 사용한 예제다. 보다시피 &lt;code&gt;~&lt;/code&gt;가 사용자의 홈 디렉터리로 잘 변경되는 것을 볼 수 있다. Expand User라는 이름에 걸맡게 축약된 &lt;code&gt;~&lt;/code&gt; 기호를 홈 디렉터리로 확장시켜 준다.&lt;/p&gt;
&lt;p&gt;쓸 데 없이 글이 길어진 것 같다. 어쨌든 셸 스크립팅 목적이라면 자주 사용하게 될 함수 같다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/python-path-tips.html"&gt;파이썬으로 파일이나 디렉터리 경로 다루기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-home-dir.html</guid>
      <pubDate>Fri, 31 May 2024 09:49:00 +0900</pubDate>
    </item>
    <item>
      <title>파이썬에서 파일 정보 얻기</title>
      <link>https://seorenn.github.io/article/python-get-file-infomations.html</link>
      <description>&lt;p&gt;파이썬에서 파일의 정보, 예를 들어 파일 사이즈나 수정 일자를 얻는 방법을 알아보자. 여러 방법이 있을 수 있지만 이 글에서는 가장 진보된(?) 형태인 &lt;code&gt;pathlib.Path&lt;/code&gt; 클래스를 활용한다.&lt;/p&gt;
&lt;h2&gt;Path.stat()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stat()&lt;/code&gt; 메서드를 활용하면 파일의 메타 정보를 얻을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from pathlib import Path
&amp;gt;&amp;gt;&amp;gt; Path(&amp;quot;/Users/seorenn/.zshrc&amp;quot;).stat()
os.stat_result(st_mode=33188, st_ino=247065795, st_dev=16777225, st_nlink=1, st_uid=501, st_gid=20, st_size=1699, st_atime=1713253280, st_mtime=1713253242, st_ctime=1713253242)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;반환되는 값은 &lt;code&gt;os.stat_result&lt;/code&gt; 타입의 값이다. 이 값은 &lt;code&gt;os.stat()&lt;/code&gt; 함수의 결과와 완전히 동일하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.stat(&amp;quot;/Users/seorenn/.zshrc&amp;quot;)
os.stat_result(st_mode=33188, st_ino=247065795, st_dev=16777225, st_nlink=1, st_uid=501, st_gid=20, st_size=1699, st_atime=1713253280, st_mtime=1713253242, st_ctime=1713253242)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;둘 중 원하는 것을 사용하면 된다. 단지 &lt;code&gt;Path&lt;/code&gt;는 좀 더 풍부한 기능이 있다는 차이가 있을 뿐이다.&lt;/p&gt;
&lt;h2&gt;예제: 파일 크기 알아내기&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;os.stat_result&lt;/code&gt; 인스턴스에서 파일 크기는 &lt;code&gt;st_size&lt;/code&gt;를 통해 알 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from pathlib import Path
&amp;gt;&amp;gt;&amp;gt; Path(&amp;quot;/Users/seorenn/.zshrc&amp;quot;).stat().st_size
1699
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 값은 당연하게도 &lt;code&gt;ls -l&lt;/code&gt; 등을 통해 알 수 있는 수치와 동일하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ ls -l ~/
...
-rw-r--r--    1 seorenn  staff    1699 Apr 16 16:40 .zshrc
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;단위는 바이트 단위이므로 1000 혹은 1024 단위로 나누어가면 좀 더 인간 친화적(?) 수치를 얻을 수 있다.&lt;/p&gt;
&lt;p&gt;다만 파일이 심볼릭 링크 등 실제 파일이 아닐 경우 링크된 파일의 크기가 아닌 경로 전체의 길이 크기를 돌려줄 수도 있으므로 주의하자.&lt;/p&gt;
&lt;h2&gt;예제: 파일 수정 시간 알아내기&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;os.stat_result&lt;/code&gt; 인스턴스에서 파일 생성 시간은 &lt;code&gt;st_mtime&lt;/code&gt; 값을 통해 알 수 있다. 단지 이 값이 UNIX Timestamp 형식으로 표현되어 있어서 사람이 보기엔 그다지 효율적이지 못하다는 문제가 있다.&lt;/p&gt;
&lt;p&gt;따라서 좀 더 읽기 편하게 바꾸면 이런 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from pathlib import Path
&amp;gt;&amp;gt;&amp;gt; from datetime import datetime
&amp;gt;&amp;gt;&amp;gt; datetime.fromtimestamp(Path(&amp;quot;/Users/seorenn/.zshrc&amp;quot;).stat().st_mtime)
datetime.datetime(2024, 4, 16, 16, 40, 42, 577873)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;흔하게 사용하는 &lt;code&gt;datetime&lt;/code&gt;에서 &lt;code&gt;fromtimestamp()&lt;/code&gt;가 지원되서 간단히 변환할 수 있따.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;파이썬에서 파일의 정보, 예를 들어 파일 사이즈나 수정 일자를 얻는 방법을 알아보자. 여러 방법이 있을 수 있지만 이 글에서는 가장 진보된(?) 형태인 &lt;code&gt;pathlib.Path&lt;/code&gt; 클래스를 활용한다.&lt;/p&gt;
&lt;h2&gt;Path.stat()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stat()&lt;/code&gt; 메서드를 활용하면 파일의 메타 정보를 얻을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from pathlib import Path
&amp;gt;&amp;gt;&amp;gt; Path(&amp;quot;/Users/seorenn/.zshrc&amp;quot;).stat()
os.stat_result(st_mode=33188, st_ino=247065795, st_dev=16777225, st_nlink=1, st_uid=501, st_gid=20, st_size=1699, st_atime=1713253280, st_mtime=1713253242, st_ctime=1713253242)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;반환되는 값은 &lt;code&gt;os.stat_result&lt;/code&gt; 타입의 값이다. 이 값은 &lt;code&gt;os.stat()&lt;/code&gt; 함수의 결과와 완전히 동일하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.stat(&amp;quot;/Users/seorenn/.zshrc&amp;quot;)
os.stat_result(st_mode=33188, st_ino=247065795, st_dev=16777225, st_nlink=1, st_uid=501, st_gid=20, st_size=1699, st_atime=1713253280, st_mtime=1713253242, st_ctime=1713253242)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;둘 중 원하는 것을 사용하면 된다. 단지 &lt;code&gt;Path&lt;/code&gt;는 좀 더 풍부한 기능이 있다는 차이가 있을 뿐이다.&lt;/p&gt;
&lt;h2&gt;예제: 파일 크기 알아내기&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;os.stat_result&lt;/code&gt; 인스턴스에서 파일 크기는 &lt;code&gt;st_size&lt;/code&gt;를 통해 알 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from pathlib import Path
&amp;gt;&amp;gt;&amp;gt; Path(&amp;quot;/Users/seorenn/.zshrc&amp;quot;).stat().st_size
1699
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 값은 당연하게도 &lt;code&gt;ls -l&lt;/code&gt; 등을 통해 알 수 있는 수치와 동일하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ ls -l ~/
...
-rw-r--r--    1 seorenn  staff    1699 Apr 16 16:40 .zshrc
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;단위는 바이트 단위이므로 1000 혹은 1024 단위로 나누어가면 좀 더 인간 친화적(?) 수치를 얻을 수 있다.&lt;/p&gt;
&lt;p&gt;다만 파일이 심볼릭 링크 등 실제 파일이 아닐 경우 링크된 파일의 크기가 아닌 경로 전체의 길이 크기를 돌려줄 수도 있으므로 주의하자.&lt;/p&gt;
&lt;h2&gt;예제: 파일 수정 시간 알아내기&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;os.stat_result&lt;/code&gt; 인스턴스에서 파일 생성 시간은 &lt;code&gt;st_mtime&lt;/code&gt; 값을 통해 알 수 있다. 단지 이 값이 UNIX Timestamp 형식으로 표현되어 있어서 사람이 보기엔 그다지 효율적이지 못하다는 문제가 있다.&lt;/p&gt;
&lt;p&gt;따라서 좀 더 읽기 편하게 바꾸면 이런 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from pathlib import Path
&amp;gt;&amp;gt;&amp;gt; from datetime import datetime
&amp;gt;&amp;gt;&amp;gt; datetime.fromtimestamp(Path(&amp;quot;/Users/seorenn/.zshrc&amp;quot;).stat().st_mtime)
datetime.datetime(2024, 4, 16, 16, 40, 42, 577873)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;흔하게 사용하는 &lt;code&gt;datetime&lt;/code&gt;에서 &lt;code&gt;fromtimestamp()&lt;/code&gt;가 지원되서 간단히 변환할 수 있따.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-get-file-infomations.html</guid>
      <pubDate>Thu, 30 May 2024 16:17:00 +0900</pubDate>
    </item>
    <item>
      <title>드디어 피드가 동작한다</title>
      <link>https://seorenn.github.io/log/20240530-00.html</link>
      <description>&lt;p&gt;seorenn-publish를 만들면서 나름 순조롭게 RSS와 ATOM 피드를 뽑는 스크립트를 만들어서 시험해 보고 있었다. 그런데 Feedly와 같은 RSS 리더에서 최초 피드 리스트는 잘 받아오는데, 이후 업데이트 되는 내역은 전혀 받아오지 못 하였다. 느낌적인 느낌으로 말해서 그냥 리프레시를 안 하는 느낌이었다.&lt;/p&gt;
&lt;p&gt;이것저것 시도해 봤지만 원인이 무엇인지 정확하게 알 수는 없었다. 결국 다른 유명 사이트의 RSS와 내가 만든 RSS의 차이를 비교해보며 feedgen을 기준으로 lastBuildDate나 엔트리에 description 등등을 추가할 수 있었다.&lt;/p&gt;
&lt;p&gt;추측으론 아마도 lastBuildDate 즉 피드 업데이트 시간을 기록한 것이 주요하지 않았나 생각된다. 아니면 피드 안의 엔트리 정렬이 문제였을 지도 모른다. 엔트리가 시간순으로 정렬되어 들어가 있었는데 이걸 역순으로 바꿔주기도 했다.&lt;/p&gt;
&lt;p&gt;뭐가 답이었든 간에 동작하는 걸 확인했으니 일단은 안심이다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;seorenn-publish를 만들면서 나름 순조롭게 RSS와 ATOM 피드를 뽑는 스크립트를 만들어서 시험해 보고 있었다. 그런데 Feedly와 같은 RSS 리더에서 최초 피드 리스트는 잘 받아오는데, 이후 업데이트 되는 내역은 전혀 받아오지 못 하였다. 느낌적인 느낌으로 말해서 그냥 리프레시를 안 하는 느낌이었다.&lt;/p&gt;
&lt;p&gt;이것저것 시도해 봤지만 원인이 무엇인지 정확하게 알 수는 없었다. 결국 다른 유명 사이트의 RSS와 내가 만든 RSS의 차이를 비교해보며 feedgen을 기준으로 lastBuildDate나 엔트리에 description 등등을 추가할 수 있었다.&lt;/p&gt;
&lt;p&gt;추측으론 아마도 lastBuildDate 즉 피드 업데이트 시간을 기록한 것이 주요하지 않았나 생각된다. 아니면 피드 안의 엔트리 정렬이 문제였을 지도 모른다. 엔트리가 시간순으로 정렬되어 들어가 있었는데 이걸 역순으로 바꿔주기도 했다.&lt;/p&gt;
&lt;p&gt;뭐가 답이었든 간에 동작하는 걸 확인했으니 일단은 안심이다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240530-00.html</guid>
      <pubDate>Thu, 30 May 2024 14:30:00 +0900</pubDate>
    </item>
    <item>
      <title>파이썬으로 파일 및 디렉터리 목록 구하기</title>
      <link>https://seorenn.github.io/article/python-list-dir.html</link>
      <description>&lt;p&gt;파이썬으로 파일과 디렉터리 목록을 구하는 방법은 여러 가지가 있겠지만 여기서는 listdir 및 rglob를 사용하는 방법을 정리한다.&lt;/p&gt;
&lt;h2&gt;listdir - 특정 디렉터리 탐색&lt;/h2&gt;
&lt;p&gt;단순하게 특정 디렉터리의 목록만 구하고 싶다면 &lt;code&gt;os.listdir()&lt;/code&gt; 함수를 이용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.listdir('.')
['foo.a', 'bar.b', 'somedir', ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;당연하겠지만 입력으로 사용한 &lt;code&gt;'.'&lt;/code&gt;은 현재 디렉터리를 의미한다. 여기다 원하는 경로를 넣을 수 있다.&lt;/p&gt;
&lt;h2&gt;glob - 패턴 기반 특정 디렉터리 탐색&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;glob&lt;/code&gt;로 &lt;code&gt;os.listdir&lt;/code&gt;과 비슷하게 특저 디렉터리의 디렉터리나 파일 리스트를 구하는 용도로 사용할 수 있는데 특징으로는 패턴을 이용할 수 있다는 점이 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from glob import glob
&amp;gt;&amp;gt;&amp;gt; for path in glob(&amp;quot;/foo/bar/*.txt&amp;quot;):
...     print(path)
/foo/bar/qwer.txt
/foo/bar/tyui.txt
/foo/bar/asdf.txt
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같은 코드로 &lt;code&gt;/foo/bar&lt;/code&gt; 디렉터리 아래에서 패턴으로 &lt;code&gt;*.txt&lt;/code&gt; 즉 확장자가 &lt;code&gt;txt&lt;/code&gt;인 파일의 목록을 구할 수 있다.&lt;/p&gt;
&lt;h2&gt;rglob - 특정 디렉터리 및 그 아래의 모든 서브 디렉터리 탐색&lt;/h2&gt;
&lt;p&gt;특정 디렉터리 안의 내용물을 서브(자식) 디렉터리까지 다 포함해서 목록을 구할려면 여러 방법이 있겠지만 이번에는 Python 3.4 에서 추가된 &lt;code&gt;pathlib&lt;/code&gt; 모듈의 &lt;code&gt;Path&lt;/code&gt; 클래스의 &lt;code&gt;rglob()&lt;/code&gt; 메서드를 이용해보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from pathlib import Path
&amp;gt;&amp;gt;&amp;gt; list(Path(&amp;quot;/foo/bar/dir&amp;quot;).rglob(&amp;quot;*&amp;quot;))
[PosixPath('/foo/bar/dir/a'), PosixPath('/foo/bar/dir/a/test.txt'), ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PosixPath&lt;/code&gt; 라는 새로운 타입이 등장하는데 이름처럼 경로를 표기하는데 적합한 타입이다. 이 타입은 별로 어려울 것 없이 &lt;code&gt;str()&lt;/code&gt; 로 문자열로 변환이 되니 익숙한 방법을 사용하면 된다.&lt;/p&gt;
&lt;p&gt;어쨌든 이런 식으로 해당 디렉터리 아래의 모든 파일과 디렉터리 목록을 1차원 리스트로 가공된 결과를 얻을 수 있다. 거기다 &lt;code&gt;glob&lt;/code&gt;와 비슷하게 패턴까지 사용할 수도 있다.&lt;/p&gt;
&lt;p&gt;굳이 &lt;code&gt;list()&lt;/code&gt; 를 이용해 리스트화를 한 이유는 결과를 바로 보기 위함이다. 보통 이런 경우 generator가 리턴된 것이기 때문에 굳이 &lt;code&gt;list()&lt;/code&gt; 로 바로 풀어버릴 필요 없이 바로 for 루프를 돌면서 필요한 처리를 하는 게 성능과 메모리 효율이 더 좋을 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; for p in Path(&amp;quot;/Users/seorenn/tmp/a&amp;quot;).rglob(&amp;quot;*&amp;quot;):
...     print(p)
...
/foo/bar/dir/a
/foo/bar/dir/a/test.txt
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 &lt;code&gt;rglob()&lt;/code&gt;의 파일 이름 패턴은 이 외의 다양한 패턴을 지원하므로 궁금하다면 매뉴얼을 찾아보자.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;파이썬으로 파일과 디렉터리 목록을 구하는 방법은 여러 가지가 있겠지만 여기서는 listdir 및 rglob를 사용하는 방법을 정리한다.&lt;/p&gt;
&lt;h2&gt;listdir - 특정 디렉터리 탐색&lt;/h2&gt;
&lt;p&gt;단순하게 특정 디렉터리의 목록만 구하고 싶다면 &lt;code&gt;os.listdir()&lt;/code&gt; 함수를 이용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.listdir('.')
['foo.a', 'bar.b', 'somedir', ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;당연하겠지만 입력으로 사용한 &lt;code&gt;'.'&lt;/code&gt;은 현재 디렉터리를 의미한다. 여기다 원하는 경로를 넣을 수 있다.&lt;/p&gt;
&lt;h2&gt;glob - 패턴 기반 특정 디렉터리 탐색&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;glob&lt;/code&gt;로 &lt;code&gt;os.listdir&lt;/code&gt;과 비슷하게 특저 디렉터리의 디렉터리나 파일 리스트를 구하는 용도로 사용할 수 있는데 특징으로는 패턴을 이용할 수 있다는 점이 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from glob import glob
&amp;gt;&amp;gt;&amp;gt; for path in glob(&amp;quot;/foo/bar/*.txt&amp;quot;):
...     print(path)
/foo/bar/qwer.txt
/foo/bar/tyui.txt
/foo/bar/asdf.txt
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같은 코드로 &lt;code&gt;/foo/bar&lt;/code&gt; 디렉터리 아래에서 패턴으로 &lt;code&gt;*.txt&lt;/code&gt; 즉 확장자가 &lt;code&gt;txt&lt;/code&gt;인 파일의 목록을 구할 수 있다.&lt;/p&gt;
&lt;h2&gt;rglob - 특정 디렉터리 및 그 아래의 모든 서브 디렉터리 탐색&lt;/h2&gt;
&lt;p&gt;특정 디렉터리 안의 내용물을 서브(자식) 디렉터리까지 다 포함해서 목록을 구할려면 여러 방법이 있겠지만 이번에는 Python 3.4 에서 추가된 &lt;code&gt;pathlib&lt;/code&gt; 모듈의 &lt;code&gt;Path&lt;/code&gt; 클래스의 &lt;code&gt;rglob()&lt;/code&gt; 메서드를 이용해보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from pathlib import Path
&amp;gt;&amp;gt;&amp;gt; list(Path(&amp;quot;/foo/bar/dir&amp;quot;).rglob(&amp;quot;*&amp;quot;))
[PosixPath('/foo/bar/dir/a'), PosixPath('/foo/bar/dir/a/test.txt'), ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PosixPath&lt;/code&gt; 라는 새로운 타입이 등장하는데 이름처럼 경로를 표기하는데 적합한 타입이다. 이 타입은 별로 어려울 것 없이 &lt;code&gt;str()&lt;/code&gt; 로 문자열로 변환이 되니 익숙한 방법을 사용하면 된다.&lt;/p&gt;
&lt;p&gt;어쨌든 이런 식으로 해당 디렉터리 아래의 모든 파일과 디렉터리 목록을 1차원 리스트로 가공된 결과를 얻을 수 있다. 거기다 &lt;code&gt;glob&lt;/code&gt;와 비슷하게 패턴까지 사용할 수도 있다.&lt;/p&gt;
&lt;p&gt;굳이 &lt;code&gt;list()&lt;/code&gt; 를 이용해 리스트화를 한 이유는 결과를 바로 보기 위함이다. 보통 이런 경우 generator가 리턴된 것이기 때문에 굳이 &lt;code&gt;list()&lt;/code&gt; 로 바로 풀어버릴 필요 없이 바로 for 루프를 돌면서 필요한 처리를 하는 게 성능과 메모리 효율이 더 좋을 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; for p in Path(&amp;quot;/Users/seorenn/tmp/a&amp;quot;).rglob(&amp;quot;*&amp;quot;):
...     print(p)
...
/foo/bar/dir/a
/foo/bar/dir/a/test.txt
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 &lt;code&gt;rglob()&lt;/code&gt;의 파일 이름 패턴은 이 외의 다양한 패턴을 지원하므로 궁금하다면 매뉴얼을 찾아보자.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-list-dir.html</guid>
      <pubDate>Thu, 30 May 2024 10:50:00 +0900</pubDate>
    </item>
    <item>
      <title>파이썬에서 파일이나 디렉터리 구분 및 존재 확인하기</title>
      <link>https://seorenn.github.io/article/python-file-dir-exists.html</link>
      <description>&lt;p&gt;파이썬에서 특정 경로가 파일인지 아니면 디렉터리인지 구분하고 이 경로가 실제로 존재하는지 확인하는 방법을 정리해 보자.&lt;/p&gt;
&lt;p&gt;사실 이 모두 간단한 &lt;code&gt;os.path&lt;/code&gt;의 두 함수를 통해 가능하다.&lt;/p&gt;
&lt;h2&gt;isfile&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;isfile&lt;/code&gt;, 정확히 말해 &lt;code&gt;os.path.isfile&lt;/code&gt; 함수는 경로가 파일인지 혹은 존재하는지를 알려준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; os.path.isfile('/Users/seorenn/.zshrc')
True
&amp;gt;&amp;gt;&amp;gt; os.path.isfile('/Users/seorenn')
False
&amp;gt;&amp;gt;&amp;gt; os.path.isfile('/Users/seorenn/not_existing_file')
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;보다시피 &lt;code&gt;isfile&lt;/code&gt;을 이용하면 경로가 파일인지 아니면 존재하지 않는지를 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;isdir&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;isfile&lt;/code&gt;을 봤다면 이름만 보면 감이 바로 올 만한 함수다. 이름처럼 &lt;code&gt;isdir&lt;/code&gt;, 정확히 말해 &lt;code&gt;os.path.isdir&lt;/code&gt; 함수는 경로가 디렉터리인지 그리고 실제로 존재하는지를 알려준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.isdir('/Users/seorenn')
True
&amp;gt;&amp;gt;&amp;gt; os.path.isdir('/Users/seorenn/.zsshrc')
False
&amp;gt;&amp;gt;&amp;gt; os.path.isdir('/Users/seorenn/not_existing_dir/')
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아주 쉽고 간단한 기능이지만 개인적으로 자주 까먹는 편이다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;파이썬에서 특정 경로가 파일인지 아니면 디렉터리인지 구분하고 이 경로가 실제로 존재하는지 확인하는 방법을 정리해 보자.&lt;/p&gt;
&lt;p&gt;사실 이 모두 간단한 &lt;code&gt;os.path&lt;/code&gt;의 두 함수를 통해 가능하다.&lt;/p&gt;
&lt;h2&gt;isfile&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;isfile&lt;/code&gt;, 정확히 말해 &lt;code&gt;os.path.isfile&lt;/code&gt; 함수는 경로가 파일인지 혹은 존재하는지를 알려준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; os.path.isfile('/Users/seorenn/.zshrc')
True
&amp;gt;&amp;gt;&amp;gt; os.path.isfile('/Users/seorenn')
False
&amp;gt;&amp;gt;&amp;gt; os.path.isfile('/Users/seorenn/not_existing_file')
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;보다시피 &lt;code&gt;isfile&lt;/code&gt;을 이용하면 경로가 파일인지 아니면 존재하지 않는지를 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;isdir&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;isfile&lt;/code&gt;을 봤다면 이름만 보면 감이 바로 올 만한 함수다. 이름처럼 &lt;code&gt;isdir&lt;/code&gt;, 정확히 말해 &lt;code&gt;os.path.isdir&lt;/code&gt; 함수는 경로가 디렉터리인지 그리고 실제로 존재하는지를 알려준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.isdir('/Users/seorenn')
True
&amp;gt;&amp;gt;&amp;gt; os.path.isdir('/Users/seorenn/.zsshrc')
False
&amp;gt;&amp;gt;&amp;gt; os.path.isdir('/Users/seorenn/not_existing_dir/')
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아주 쉽고 간단한 기능이지만 개인적으로 자주 까먹는 편이다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-file-dir-exists.html</guid>
      <pubDate>Thu, 30 May 2024 00:17:00 +0900</pubDate>
    </item>
    <item>
      <title>애플 iOS 17.5의 서명 중지</title>
      <link>https://seorenn.github.io/log/20240529-00.html</link>
      <description>&lt;p&gt;애플이 iOS 17.5의 서명을 중지했다. 이제 iOS 17.5에서 최신 버전인 iOS 17.5.1로 올리면 더이상 17.5로 다운그레이드가 불가능하다는 말이다.&lt;/p&gt;
&lt;p&gt;서명 중지는 늘상 있는 일이다. 그리고 어차피 버그 픽스 버전이 안정성이 더 좋으므로 굳이 iOS 17.5로 돌아갈 이유도 없다. 안 그래도 지운 사진이 자꾸 부활하는 등 버그로 유명한 버전인데 말이다. 뭐 그냥 그렇다는 소식이다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;애플이 iOS 17.5의 서명을 중지했다. 이제 iOS 17.5에서 최신 버전인 iOS 17.5.1로 올리면 더이상 17.5로 다운그레이드가 불가능하다는 말이다.&lt;/p&gt;
&lt;p&gt;서명 중지는 늘상 있는 일이다. 그리고 어차피 버그 픽스 버전이 안정성이 더 좋으므로 굳이 iOS 17.5로 돌아갈 이유도 없다. 안 그래도 지운 사진이 자꾸 부활하는 등 버그로 유명한 버전인데 말이다. 뭐 그냥 그렇다는 소식이다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240529-00.html</guid>
      <pubDate>Wed, 29 May 2024 21:44:00 +0900</pubDate>
    </item>
    <item>
      <title>파이썬으로 파일이나 디렉터리 경로 다루기</title>
      <link>https://seorenn.github.io/article/python-path-tips.html</link>
      <description>&lt;p&gt;파이썬(Python)으로 파일이나 디렉터리 경로(path)를 다루는 몇 가지 방법을 정리해보자. 아마도 리눅스나 맥 등의 POSIX 호환 OS에서는 다 잘 작동할 것이지만 윈도우의 경우는 동작을 확인하지 못했다는 점에 주의하자.&lt;/p&gt;
&lt;h2&gt;경로 조합하기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.join('/foo/bar', 'qwer', 'test.txt')
'/foo/bar/qwer/test.txt'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;os.path.join&lt;/code&gt;의 입력 갯수는 자유로운 편이다.&lt;/p&gt;
&lt;h2&gt;경로에서 파일명만 얻기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.basename('/foo/bar/test.txt')
'test.txt'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 아래의 '경로에서 디렉터리와 파일명을 분리하기' 항목에서 언급할 &lt;code&gt;os.path.split&lt;/code&gt;을 이용해도 된다.&lt;/p&gt;
&lt;h2&gt;경로에서 디렉터리만 얻기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.dirname('/foo/bar/test.txt')
'/foo/bar'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해당 파일이 위치하는 디렉터리를 알아낼 때 유용하다.&lt;/p&gt;
&lt;p&gt;아래 '경로에서 디렉터리와 파일명을 분리하기' 항목에서 언급된 &lt;code&gt;os.path.split&lt;/code&gt;을 사용할 수도 있다.&lt;/p&gt;
&lt;h2&gt;파일명이나 경로에서 확장자를 제거하거나 알아내기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.splitext('test.txt')
('test', '.txt')
&amp;gt;&amp;gt;&amp;gt; os.path.splitext('/foo/bar/test.txt')
('/foo/bar/test', '.txt')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;입력된 경로에서 파일명의 확장자를 바꿔서 출력해야 되는 경우, 혹은 특정 파일의 확장자만 얻어내야 할 경우 등에서 유용하게 쓸 수 있다.&lt;/p&gt;
&lt;p&gt;반환되는 확장자에 &lt;code&gt;.&lt;/code&gt;이 앞에 붙어있다는 점은 주의하자.&lt;/p&gt;
&lt;h2&gt;경로에서 디렉터리와 파일명을 분리하기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.split('/foo/bar/sample.txt')
('/foo/bar', 'sample.txt')
&amp;gt;&amp;gt;&amp;gt; os.path.split('/foo/bar')
('/foo', 'bar')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;두 번째 예제에서 볼 수 있듯이 &lt;code&gt;os.path.split&lt;/code&gt;은 경로에서 마지막 컴포넌트만 분리해주는 기능이기 때문에 파일이 아니라 마지막 디렉터리를 떼어내는 용도로도 쓸 수 있다.&lt;/p&gt;
&lt;h2&gt;상대경로 얻기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.relpath('/foo/bar/qwer/test.txt', '/foo/bar')
'qwer/test.txt'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;첫 번째 인자가 절대경로이고 두 번째 인자는 첫 번째 인자의 절대경로를 상대경로로 표현할 기준 경로다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/python-home-dir.html"&gt;파이썬에서 홈 디렉토리 경로 처리하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;파이썬(Python)으로 파일이나 디렉터리 경로(path)를 다루는 몇 가지 방법을 정리해보자. 아마도 리눅스나 맥 등의 POSIX 호환 OS에서는 다 잘 작동할 것이지만 윈도우의 경우는 동작을 확인하지 못했다는 점에 주의하자.&lt;/p&gt;
&lt;h2&gt;경로 조합하기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.join('/foo/bar', 'qwer', 'test.txt')
'/foo/bar/qwer/test.txt'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;os.path.join&lt;/code&gt;의 입력 갯수는 자유로운 편이다.&lt;/p&gt;
&lt;h2&gt;경로에서 파일명만 얻기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.basename('/foo/bar/test.txt')
'test.txt'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 아래의 '경로에서 디렉터리와 파일명을 분리하기' 항목에서 언급할 &lt;code&gt;os.path.split&lt;/code&gt;을 이용해도 된다.&lt;/p&gt;
&lt;h2&gt;경로에서 디렉터리만 얻기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.dirname('/foo/bar/test.txt')
'/foo/bar'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해당 파일이 위치하는 디렉터리를 알아낼 때 유용하다.&lt;/p&gt;
&lt;p&gt;아래 '경로에서 디렉터리와 파일명을 분리하기' 항목에서 언급된 &lt;code&gt;os.path.split&lt;/code&gt;을 사용할 수도 있다.&lt;/p&gt;
&lt;h2&gt;파일명이나 경로에서 확장자를 제거하거나 알아내기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.splitext('test.txt')
('test', '.txt')
&amp;gt;&amp;gt;&amp;gt; os.path.splitext('/foo/bar/test.txt')
('/foo/bar/test', '.txt')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;입력된 경로에서 파일명의 확장자를 바꿔서 출력해야 되는 경우, 혹은 특정 파일의 확장자만 얻어내야 할 경우 등에서 유용하게 쓸 수 있다.&lt;/p&gt;
&lt;p&gt;반환되는 확장자에 &lt;code&gt;.&lt;/code&gt;이 앞에 붙어있다는 점은 주의하자.&lt;/p&gt;
&lt;h2&gt;경로에서 디렉터리와 파일명을 분리하기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.split('/foo/bar/sample.txt')
('/foo/bar', 'sample.txt')
&amp;gt;&amp;gt;&amp;gt; os.path.split('/foo/bar')
('/foo', 'bar')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;두 번째 예제에서 볼 수 있듯이 &lt;code&gt;os.path.split&lt;/code&gt;은 경로에서 마지막 컴포넌트만 분리해주는 기능이기 때문에 파일이 아니라 마지막 디렉터리를 떼어내는 용도로도 쓸 수 있다.&lt;/p&gt;
&lt;h2&gt;상대경로 얻기&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.path.relpath('/foo/bar/qwer/test.txt', '/foo/bar')
'qwer/test.txt'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;첫 번째 인자가 절대경로이고 두 번째 인자는 첫 번째 인자의 절대경로를 상대경로로 표현할 기준 경로다.&lt;/p&gt;
&lt;h2&gt;관련된 글들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../article/python-home-dir.html"&gt;파이썬에서 홈 디렉토리 경로 처리하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-path-tips.html</guid>
      <pubDate>Wed, 29 May 2024 11:24:00 +0900</pubDate>
    </item>
    <item>
      <title>이제 어느 정도 완성된 것일까?</title>
      <link>https://seorenn.github.io/log/20240528-00.html</link>
      <description>&lt;p&gt;seorenn-publish를 느긋하게 구축하기 시작한 지 한 달이 지났는데 이제서야 뭔가 쓸 수 있을 만한 물건이 된 것 같다.&lt;/p&gt;
&lt;p&gt;기본적으로 블로그의 로그를 시간 순으로 정렬하고, 기존 노트에 해당하던 글들은 위키 스타일이 아니라 태그와 비슷한 주제별 관리를 통해 정리하기로 했다.&lt;/p&gt;
&lt;p&gt;결과적으로 글을 쓸 때 구태여 위키와 같은 링크를 많이 만들 필요가 없어졌고 그래서 글 내용 자체에 집중할 수 있는 여력은 약간 늘어날 것 같다. 어차피 주제와 비슷하게 글을 모으기 위한 글도 기존에는 수작업으로 정리하고 있었는데 여기에 약간의 자동화를 추가한 개념이기 기존보다는 분명 더 편해지리라 생각한다.&lt;/p&gt;
&lt;p&gt;물론 아직 문제가 많은 것 같다. 시험용 로그를 지웠더니 또 오류가 난다. 덕분에 안정성이 약간 증가했다는 결론으로 이어진 점은 긍정적이다.&lt;/p&gt;
&lt;p&gt;당분간은 써보면서 판단해 봐야겠다.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;seorenn-publish를 느긋하게 구축하기 시작한 지 한 달이 지났는데 이제서야 뭔가 쓸 수 있을 만한 물건이 된 것 같다.&lt;/p&gt;
&lt;p&gt;기본적으로 블로그의 로그를 시간 순으로 정렬하고, 기존 노트에 해당하던 글들은 위키 스타일이 아니라 태그와 비슷한 주제별 관리를 통해 정리하기로 했다.&lt;/p&gt;
&lt;p&gt;결과적으로 글을 쓸 때 구태여 위키와 같은 링크를 많이 만들 필요가 없어졌고 그래서 글 내용 자체에 집중할 수 있는 여력은 약간 늘어날 것 같다. 어차피 주제와 비슷하게 글을 모으기 위한 글도 기존에는 수작업으로 정리하고 있었는데 여기에 약간의 자동화를 추가한 개념이기 기존보다는 분명 더 편해지리라 생각한다.&lt;/p&gt;
&lt;p&gt;물론 아직 문제가 많은 것 같다. 시험용 로그를 지웠더니 또 오류가 난다. 덕분에 안정성이 약간 증가했다는 결론으로 이어진 점은 긍정적이다.&lt;/p&gt;
&lt;p&gt;당분간은 써보면서 판단해 봐야겠다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240528-00.html</guid>
      <pubDate>Tue, 28 May 2024 15:22:00 +0900</pubDate>
    </item>
    <item>
      <title>파이썬 bitstring 패키지 소개</title>
      <link>https://seorenn.github.io/article/python-bitstring.html</link>
      <description>&lt;p&gt;bitstring은 파이썬에서 이진 데이터를 생성하거나 분석하기 쉽게 해주는 도구다. 특히 문자열 데이터 표현을 실제 이진 데이터로 바꾸거나 혹은 그 반대의 작업을 하기에 유용하다.&lt;/p&gt;
&lt;h2&gt;설치 및 임포트&lt;/h2&gt;
&lt;p&gt;설치는 당연하게도 pip를 이용해 쉽게 설치할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install bitstring
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;임포트도 그냥 통채로 해도 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import bitstring
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 주요 클래스 중 필요한 것만 골라서 할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from bitstring import Bits, BitArray, BitStream
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Bits&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Bits&lt;/code&gt;는 bitstring의 근간이 되는 기본 클래스다. 그리고 불변(Immutable) 클래스다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; Bits(0x01)
Bits('0b0')
&amp;gt;&amp;gt;&amp;gt; Bits('0x01')
Bits('0x01')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;데이터 표현에 사용되는 클래스로 보이며 개인적으로는 직접 사용할 일은 별로 없을 것 같다.&lt;/p&gt;
&lt;h2&gt;BitArray&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BitArray&lt;/code&gt;는 하나 이상의 Bit로 구성된 데이터를 구성하기 위한 용도의 클래스다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; ba = BitArray('0xff')
&amp;gt;&amp;gt;&amp;gt; ba
BitArray('0xff')
&amp;gt;&amp;gt;&amp;gt; ba.append('0xaa')
&amp;gt;&amp;gt;&amp;gt; ba
BitArray('0xffaa')
&amp;gt;&amp;gt;&amp;gt; ba.bin
'1111111110101010'
&amp;gt;&amp;gt;&amp;gt; ba.hex
'ffaa'
&amp;gt;&amp;gt;&amp;gt; ba.bytes
b'\xff\xaa'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여러 타입으로 변환도 지원하기 때문에 활용도는 높을 것 같다.&lt;/p&gt;
&lt;h2&gt;ConstBitStream, BitStream&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ConstBitStream&lt;/code&gt;는 바이트 스트림에서 위치를 이동해가며 원하는 타입으로 읽기 편하게 구성되어 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; cbs = ConstBitStream('0x01020304')
&amp;gt;&amp;gt;&amp;gt; cbs.pos
0
&amp;gt;&amp;gt;&amp;gt; cbs.read('int:8')
1
&amp;gt;&amp;gt;&amp;gt; cbs.pos
8
&amp;gt;&amp;gt;&amp;gt; cbs.bytepos
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;pos&lt;/code&gt;와 &lt;code&gt;bytepos&lt;/code&gt;의 차이점을 잘 보자. &lt;code&gt;pos&lt;/code&gt;는 비트 단위다. 즉 비트 단위로 데이터를 읽을 수 있다는 말이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConstBitStream&lt;/code&gt;은 &lt;code&gt;BitStream&lt;/code&gt;의 불변(Immutable) 타입 클래스다. 메서드 등은 거의 동일하지만 &lt;code&gt;BitStream&lt;/code&gt;은 &lt;code&gt;append()&lt;/code&gt;같은 가변(Mutable) 메서드를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; bs = BitStream('0x0102')
&amp;gt;&amp;gt;&amp;gt; bs.append('0x0304')
&amp;gt;&amp;gt;&amp;gt; bs
BitStream('0x01020304')
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;외부 링크&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/scott-griffiths/bitstring" target="_blank"&gt;bitstring 프로젝트 저장소📎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;bitstring은 파이썬에서 이진 데이터를 생성하거나 분석하기 쉽게 해주는 도구다. 특히 문자열 데이터 표현을 실제 이진 데이터로 바꾸거나 혹은 그 반대의 작업을 하기에 유용하다.&lt;/p&gt;
&lt;h2&gt;설치 및 임포트&lt;/h2&gt;
&lt;p&gt;설치는 당연하게도 pip를 이용해 쉽게 설치할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install bitstring
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;임포트도 그냥 통채로 해도 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import bitstring
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 주요 클래스 중 필요한 것만 골라서 할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from bitstring import Bits, BitArray, BitStream
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Bits&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Bits&lt;/code&gt;는 bitstring의 근간이 되는 기본 클래스다. 그리고 불변(Immutable) 클래스다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; Bits(0x01)
Bits('0b0')
&amp;gt;&amp;gt;&amp;gt; Bits('0x01')
Bits('0x01')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;데이터 표현에 사용되는 클래스로 보이며 개인적으로는 직접 사용할 일은 별로 없을 것 같다.&lt;/p&gt;
&lt;h2&gt;BitArray&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BitArray&lt;/code&gt;는 하나 이상의 Bit로 구성된 데이터를 구성하기 위한 용도의 클래스다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; ba = BitArray('0xff')
&amp;gt;&amp;gt;&amp;gt; ba
BitArray('0xff')
&amp;gt;&amp;gt;&amp;gt; ba.append('0xaa')
&amp;gt;&amp;gt;&amp;gt; ba
BitArray('0xffaa')
&amp;gt;&amp;gt;&amp;gt; ba.bin
'1111111110101010'
&amp;gt;&amp;gt;&amp;gt; ba.hex
'ffaa'
&amp;gt;&amp;gt;&amp;gt; ba.bytes
b'\xff\xaa'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여러 타입으로 변환도 지원하기 때문에 활용도는 높을 것 같다.&lt;/p&gt;
&lt;h2&gt;ConstBitStream, BitStream&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ConstBitStream&lt;/code&gt;는 바이트 스트림에서 위치를 이동해가며 원하는 타입으로 읽기 편하게 구성되어 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; cbs = ConstBitStream('0x01020304')
&amp;gt;&amp;gt;&amp;gt; cbs.pos
0
&amp;gt;&amp;gt;&amp;gt; cbs.read('int:8')
1
&amp;gt;&amp;gt;&amp;gt; cbs.pos
8
&amp;gt;&amp;gt;&amp;gt; cbs.bytepos
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;pos&lt;/code&gt;와 &lt;code&gt;bytepos&lt;/code&gt;의 차이점을 잘 보자. &lt;code&gt;pos&lt;/code&gt;는 비트 단위다. 즉 비트 단위로 데이터를 읽을 수 있다는 말이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConstBitStream&lt;/code&gt;은 &lt;code&gt;BitStream&lt;/code&gt;의 불변(Immutable) 타입 클래스다. 메서드 등은 거의 동일하지만 &lt;code&gt;BitStream&lt;/code&gt;은 &lt;code&gt;append()&lt;/code&gt;같은 가변(Mutable) 메서드를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; bs = BitStream('0x0102')
&amp;gt;&amp;gt;&amp;gt; bs.append('0x0304')
&amp;gt;&amp;gt;&amp;gt; bs
BitStream('0x01020304')
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;외부 링크&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/scott-griffiths/bitstring" target="_blank"&gt;bitstring 프로젝트 저장소📎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-bitstring.html</guid>
      <pubDate>Tue, 21 May 2024 16:21:00 +0900</pubDate>
    </item>
    <item>
      <title>파이썬의 F-String 간단 정리</title>
      <link>https://seorenn.github.io/article/python-f-string.html</link>
      <description>&lt;p&gt;F-string은 &lt;a href="https://peps.python.org/pep-0498/" target="_blank"&gt;PEP-498📎&lt;/a&gt; 제안을 통해 파이썬 3.6 부터 지원되기 시작한 문자열 포매팅 기능으로 정식 명칭은 Literal String Interpolation 이다.&lt;/p&gt;
&lt;h2&gt;F-String 기본&lt;/h2&gt;
&lt;p&gt;기능 이름 답게 문자열 제일 앞에 &lt;code&gt;f&lt;/code&gt; 를 붙이면 F-String이 된다. 그리고 문자열 내용에 중괄호(&lt;code&gt;{...}&lt;/code&gt;)로 대체할 내용을 넣을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; name = &amp;quot;Conrad&amp;quot;
&amp;gt;&amp;gt;&amp;gt; print(f&amp;quot;My name is {name}&amp;quot;)
My name is Conrad
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;F-String의 런타임 표현식&lt;/h2&gt;
&lt;p&gt;중괄호 내부에는 런타임에서 동적으로 작동하는 코드를 넣어도 원하는대로 동작한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; f&amp;quot;1 + 2 = {1+2}&amp;quot;
'1 + 2 = 3'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;당연히 함수 호출을 명시하는 것도 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; def makeDouble(v):
...     return v * 2
...
&amp;gt;&amp;gt;&amp;gt; f&amp;quot;This is doubler! If you enter 10, it returns {makeDouble(10)}&amp;quot;
'This is doubler! If you enter 10, it returns 20'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C언어 스타일의 포매팅&lt;/h2&gt;
&lt;p&gt;C 언어의 printf 류의 함수에서 많이 쓰이는 포맷 지시 문자도 비슷하게 쓸 수 있다. 예를 들어 &lt;code&gt;%04d&lt;/code&gt;는 F-String에서는 &lt;code&gt;#04d&lt;/code&gt; 로 쓸 수 있다. &lt;code&gt;%&lt;/code&gt;가 아니라 &lt;code&gt;#&lt;/code&gt;이 쓰인다는 점에 주의하면 상당히 비슷하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; value = 12
&amp;gt;&amp;gt;&amp;gt; f&amp;quot;the value is {value:#04d}&amp;quot;
'the value is 0012'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;디버깅에 유리한 표현 방식&lt;/h2&gt;
&lt;p&gt;파이썬 3.8에서 추가된 F-String 기능으로 자신의 이름과 값을 좀 더 편하게 로깅하는 스타일을 쓸 수 있다. 아래와 같은 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; value = 100
&amp;gt;&amp;gt;&amp;gt; f&amp;quot;{value=}&amp;quot;
'value=100'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;필요하다면 앞에서 언급한 C언어 스타일의 포맷을 지정할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; value = 100
&amp;gt;&amp;gt;&amp;gt; f'{value=:#10d}'
'value=       100'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;주의사항&lt;/h2&gt;
&lt;p&gt;F-String의 치환 문법 내부에는 백슬래시(&lt;code&gt;\&lt;/code&gt;)를 사용할 수 없다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; &amp;quot;the \&amp;quot;back-slash\&amp;quot; string&amp;quot;
'the &amp;quot;back-slash&amp;quot; string'
&amp;gt;&amp;gt;&amp;gt; f'the \'back-slash\' string'
&amp;quot;the 'back-slash' string&amp;quot;
&amp;gt;&amp;gt;&amp;gt; f'the {\'back-slash\'} string'
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1
SyntaxError: f-string expression part cannot include a backslash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;필요하다면 별도의 문자열로 뽑은(?) 다음 이를 활용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; bsstr = &amp;quot;'back-slash'&amp;quot;
&amp;gt;&amp;gt;&amp;gt; f&amp;quot;the {bsstr} string&amp;quot;
&amp;quot;the 'back-slash' string&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</description>
      <content:encoded>&lt;p&gt;F-string은 &lt;a href="https://peps.python.org/pep-0498/" target="_blank"&gt;PEP-498📎&lt;/a&gt; 제안을 통해 파이썬 3.6 부터 지원되기 시작한 문자열 포매팅 기능으로 정식 명칭은 Literal String Interpolation 이다.&lt;/p&gt;
&lt;h2&gt;F-String 기본&lt;/h2&gt;
&lt;p&gt;기능 이름 답게 문자열 제일 앞에 &lt;code&gt;f&lt;/code&gt; 를 붙이면 F-String이 된다. 그리고 문자열 내용에 중괄호(&lt;code&gt;{...}&lt;/code&gt;)로 대체할 내용을 넣을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; name = &amp;quot;Conrad&amp;quot;
&amp;gt;&amp;gt;&amp;gt; print(f&amp;quot;My name is {name}&amp;quot;)
My name is Conrad
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;F-String의 런타임 표현식&lt;/h2&gt;
&lt;p&gt;중괄호 내부에는 런타임에서 동적으로 작동하는 코드를 넣어도 원하는대로 동작한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; f&amp;quot;1 + 2 = {1+2}&amp;quot;
'1 + 2 = 3'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;당연히 함수 호출을 명시하는 것도 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; def makeDouble(v):
...     return v * 2
...
&amp;gt;&amp;gt;&amp;gt; f&amp;quot;This is doubler! If you enter 10, it returns {makeDouble(10)}&amp;quot;
'This is doubler! If you enter 10, it returns 20'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C언어 스타일의 포매팅&lt;/h2&gt;
&lt;p&gt;C 언어의 printf 류의 함수에서 많이 쓰이는 포맷 지시 문자도 비슷하게 쓸 수 있다. 예를 들어 &lt;code&gt;%04d&lt;/code&gt;는 F-String에서는 &lt;code&gt;#04d&lt;/code&gt; 로 쓸 수 있다. &lt;code&gt;%&lt;/code&gt;가 아니라 &lt;code&gt;#&lt;/code&gt;이 쓰인다는 점에 주의하면 상당히 비슷하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; value = 12
&amp;gt;&amp;gt;&amp;gt; f&amp;quot;the value is {value:#04d}&amp;quot;
'the value is 0012'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;디버깅에 유리한 표현 방식&lt;/h2&gt;
&lt;p&gt;파이썬 3.8에서 추가된 F-String 기능으로 자신의 이름과 값을 좀 더 편하게 로깅하는 스타일을 쓸 수 있다. 아래와 같은 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; value = 100
&amp;gt;&amp;gt;&amp;gt; f&amp;quot;{value=}&amp;quot;
'value=100'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;필요하다면 앞에서 언급한 C언어 스타일의 포맷을 지정할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; value = 100
&amp;gt;&amp;gt;&amp;gt; f'{value=:#10d}'
'value=       100'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;주의사항&lt;/h2&gt;
&lt;p&gt;F-String의 치환 문법 내부에는 백슬래시(&lt;code&gt;\&lt;/code&gt;)를 사용할 수 없다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; &amp;quot;the \&amp;quot;back-slash\&amp;quot; string&amp;quot;
'the &amp;quot;back-slash&amp;quot; string'
&amp;gt;&amp;gt;&amp;gt; f'the \'back-slash\' string'
&amp;quot;the 'back-slash' string&amp;quot;
&amp;gt;&amp;gt;&amp;gt; f'the {\'back-slash\'} string'
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1
SyntaxError: f-string expression part cannot include a backslash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;필요하다면 별도의 문자열로 뽑은(?) 다음 이를 활용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; bsstr = &amp;quot;'back-slash'&amp;quot;
&amp;gt;&amp;gt;&amp;gt; f&amp;quot;the {bsstr} string&amp;quot;
&amp;quot;the 'back-slash' string&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-f-string.html</guid>
      <pubDate>Tue, 21 May 2024 16:08:00 +0900</pubDate>
    </item>
    <item>
      <title>연착륙과 경착륙</title>
      <link>https://seorenn.github.io/article/soft-landing-and-hard-landing.html</link>
      <description>&lt;h2&gt;연착륙과 경착륙&lt;/h2&gt;
&lt;p&gt;연착륙은 '軟착륙' 즉 부드러운(soft, 軟, 무를 연) 착륙이라는 의미다. 말 그대로 비행기가 지면에 아주 부드럽게 착륙했다는 의미다.&lt;/p&gt;
&lt;p&gt;경착륙은 '硬착륙' 즉 단단한(hard, 硬, 굳을 경) 착륙이라는 의미다. 말 그대로 비행기가 지면에 아주 강하게 착륙하며 탑승객이나 화물에 큰 충격이 가해질 수 있는 상황이다.&lt;/p&gt;
&lt;h2&gt;경제적인 측면&lt;/h2&gt;
&lt;p&gt;경착륙이나 연착륙은 일단은 착륙하는 상황, 즉 경기가 하강하는 국면에서 결과가 어떻게 날 것인지를 비유적으로 표현하기 위해 사용한다.&lt;/p&gt;
&lt;p&gt;즉 연착륙의 경우는 경기 침체가 오긴 했지만 깊지 않고 짧게 잘 넘어갔다 정도로 이해할 수 있을 것 같다.&lt;/p&gt;
&lt;p&gt;경착륙의 경우는 일반적으론 변동성이 높아지는 것 자체를 의미하기도 하지만, 최근에 쓰이는 의미로는 경제에 상당히 부정적인 즉 '심한 경기 침체 상태이고 회복에 오래 걸린다'라는 의미로 해석할 수 있다. 기업의 실적도 떨어지고 적자나 파산 기업도 늘어나며 실업률도 치솟는 상태가 오래 지속되는 상태다&lt;/p&gt;
&lt;h2&gt;사족&lt;/h2&gt;
&lt;p&gt;개인적으로 '경착륙'과 같은 한자 조합어는 오해를 일으킬 수 있다고 생각된다. 왜냐하면 '경'이라는 한자에는 딱딱한 것과 다르게 '가벼운'이라는 의미도 동일한 발음으로 존재하고 심지어 자주 사용하기 때문이다.&lt;/p&gt;
&lt;p&gt;그래서 '경착륙'이나 '연착륙'이라는 단어는 발음 때문에 오해하기 쉬운 용어라 하루 빨리 사라져야 할 용어라 생각된다. 차라리 영어 외래어를 그대로 받아들여 소프트랜딩이나 하드랜딩이라 쓰는게 차라리 정확한 의미 전달 면에서 더 낫다고 생각된다.&lt;/p&gt;
&lt;p&gt;다만 어디까지나 개인적인 의견이다.&lt;/p&gt;</description>
      <content:encoded>&lt;h2&gt;연착륙과 경착륙&lt;/h2&gt;
&lt;p&gt;연착륙은 '軟착륙' 즉 부드러운(soft, 軟, 무를 연) 착륙이라는 의미다. 말 그대로 비행기가 지면에 아주 부드럽게 착륙했다는 의미다.&lt;/p&gt;
&lt;p&gt;경착륙은 '硬착륙' 즉 단단한(hard, 硬, 굳을 경) 착륙이라는 의미다. 말 그대로 비행기가 지면에 아주 강하게 착륙하며 탑승객이나 화물에 큰 충격이 가해질 수 있는 상황이다.&lt;/p&gt;
&lt;h2&gt;경제적인 측면&lt;/h2&gt;
&lt;p&gt;경착륙이나 연착륙은 일단은 착륙하는 상황, 즉 경기가 하강하는 국면에서 결과가 어떻게 날 것인지를 비유적으로 표현하기 위해 사용한다.&lt;/p&gt;
&lt;p&gt;즉 연착륙의 경우는 경기 침체가 오긴 했지만 깊지 않고 짧게 잘 넘어갔다 정도로 이해할 수 있을 것 같다.&lt;/p&gt;
&lt;p&gt;경착륙의 경우는 일반적으론 변동성이 높아지는 것 자체를 의미하기도 하지만, 최근에 쓰이는 의미로는 경제에 상당히 부정적인 즉 '심한 경기 침체 상태이고 회복에 오래 걸린다'라는 의미로 해석할 수 있다. 기업의 실적도 떨어지고 적자나 파산 기업도 늘어나며 실업률도 치솟는 상태가 오래 지속되는 상태다&lt;/p&gt;
&lt;h2&gt;사족&lt;/h2&gt;
&lt;p&gt;개인적으로 '경착륙'과 같은 한자 조합어는 오해를 일으킬 수 있다고 생각된다. 왜냐하면 '경'이라는 한자에는 딱딱한 것과 다르게 '가벼운'이라는 의미도 동일한 발음으로 존재하고 심지어 자주 사용하기 때문이다.&lt;/p&gt;
&lt;p&gt;그래서 '경착륙'이나 '연착륙'이라는 단어는 발음 때문에 오해하기 쉬운 용어라 하루 빨리 사라져야 할 용어라 생각된다. 차라리 영어 외래어를 그대로 받아들여 소프트랜딩이나 하드랜딩이라 쓰는게 차라리 정확한 의미 전달 면에서 더 낫다고 생각된다.&lt;/p&gt;
&lt;p&gt;다만 어디까지나 개인적인 의견이다.&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/soft-landing-and-hard-landing.html</guid>
      <pubDate>Mon, 20 May 2024 10:45:00 +0900</pubDate>
    </item>
    <item>
      <title>파이썬의 Filter와 Map 그리고 List Comprehension</title>
      <link>https://seorenn.github.io/article/python-filter-and-map.html</link>
      <description>&lt;p&gt;파이썬에도 보통 함수형 언어들의 핵심 일꾼(?)으로 불리는 fillter와 map이 당연히 있다. 하지만 파이썬에서는 이 둘 보다는 다른 방법의 문법을 사용하는 경우도 자주 보이는데 이에 대해 간단히 정리해 보자.&lt;/p&gt;
&lt;h2&gt;filter와 map&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;filter&lt;/code&gt;는 여타 언어들 처럼 리스트에서 불필요한 부분을 걸러내기 위한 용도로 사용된다. 예를 들자면 아래와 같은 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;result = filter(lambda x: iswhat(x), somelist)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 lambda 함수의 결과가 &lt;code&gt;True&lt;/code&gt;이면 리스트에 남고 &lt;code&gt;False&lt;/code&gt;이면 리스트에서 제외된 채로 result로 반환된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;의 경우는 입력된 리스트를 가공하여 다른 형태의 리스트로 만들고 싶을 때 사용한다. 예를 들어 다음과 같은 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;result = map(lambda x: dowhat(x), somelist)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 lambda 함수의 결과를 이용해 리스트가 새로 구성되어서 result로 반환된다.&lt;/p&gt;
&lt;h2&gt;List Comprehension&lt;/h2&gt;
&lt;p&gt;한국어로는 뭐라고 표현해야 할 지를 잘 모르겠다. 어쨌든 이 문법을 이용하면 filter와 map 코드를 파이썬에 어울리는 방식으로 표현할 수 있다.&lt;/p&gt;
&lt;p&gt;예를 들어 위의 filter 예제는 아래와 같은 식으로 바꿔서 쓸 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[x for x in somelist if iswhat(x)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;보다시피 파이썬의 여러 문법이 한 번에 쓰여지고 있는데 생각보다 가독성이 나쁘지는 않다.&lt;/p&gt;
&lt;p&gt;map 예제의 경우도 비슷하게 아래와 같은 식으로 바꿔 쓸 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[dowhat(x) for x in somelist]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 식으로 풀어서 쓸 수 있다. 이런 방식이 코드도 약간은 줄어드는 느낌이다.&lt;/p&gt;
&lt;h2&gt;사족&lt;/h2&gt;
&lt;p&gt;reduce는 어디 갔다고 물어볼 사람이 있을 지도 모르겠는데, 개인적으로 reduce는 코드 읽기 측면에서 상당히 난해하고 가독성이 나쁜 코드를 만들어 낸다고 생각해서 안 쓰는 것이 좋지 않을까 생각된다. 정 필요하다면 루프를 동원해서 풀어서 쓰는 게 훨씬 낫지 않을까?&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;파이썬에도 보통 함수형 언어들의 핵심 일꾼(?)으로 불리는 fillter와 map이 당연히 있다. 하지만 파이썬에서는 이 둘 보다는 다른 방법의 문법을 사용하는 경우도 자주 보이는데 이에 대해 간단히 정리해 보자.&lt;/p&gt;
&lt;h2&gt;filter와 map&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;filter&lt;/code&gt;는 여타 언어들 처럼 리스트에서 불필요한 부분을 걸러내기 위한 용도로 사용된다. 예를 들자면 아래와 같은 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;result = filter(lambda x: iswhat(x), somelist)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 lambda 함수의 결과가 &lt;code&gt;True&lt;/code&gt;이면 리스트에 남고 &lt;code&gt;False&lt;/code&gt;이면 리스트에서 제외된 채로 result로 반환된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;의 경우는 입력된 리스트를 가공하여 다른 형태의 리스트로 만들고 싶을 때 사용한다. 예를 들어 다음과 같은 식이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;result = map(lambda x: dowhat(x), somelist)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 lambda 함수의 결과를 이용해 리스트가 새로 구성되어서 result로 반환된다.&lt;/p&gt;
&lt;h2&gt;List Comprehension&lt;/h2&gt;
&lt;p&gt;한국어로는 뭐라고 표현해야 할 지를 잘 모르겠다. 어쨌든 이 문법을 이용하면 filter와 map 코드를 파이썬에 어울리는 방식으로 표현할 수 있다.&lt;/p&gt;
&lt;p&gt;예를 들어 위의 filter 예제는 아래와 같은 식으로 바꿔서 쓸 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[x for x in somelist if iswhat(x)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;보다시피 파이썬의 여러 문법이 한 번에 쓰여지고 있는데 생각보다 가독성이 나쁘지는 않다.&lt;/p&gt;
&lt;p&gt;map 예제의 경우도 비슷하게 아래와 같은 식으로 바꿔 쓸 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[dowhat(x) for x in somelist]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 식으로 풀어서 쓸 수 있다. 이런 방식이 코드도 약간은 줄어드는 느낌이다.&lt;/p&gt;
&lt;h2&gt;사족&lt;/h2&gt;
&lt;p&gt;reduce는 어디 갔다고 물어볼 사람이 있을 지도 모르겠는데, 개인적으로 reduce는 코드 읽기 측면에서 상당히 난해하고 가독성이 나쁜 코드를 만들어 낸다고 생각해서 안 쓰는 것이 좋지 않을까 생각된다. 정 필요하다면 루프를 동원해서 풀어서 쓰는 게 훨씬 낫지 않을까?&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-filter-and-map.html</guid>
      <pubDate>Sun, 19 May 2024 17:22:00 +0900</pubDate>
    </item>
    <item>
      <title>seorenn-publish의 새로운 시작</title>
      <link>https://seorenn.github.io/log/20240416-00.html</link>
      <description>&lt;p&gt;새로운 개인용 노트 및 블로그 출력 시스템을 만들기 시작했다.&lt;/p&gt;
&lt;p&gt;기존 Emacs 상에서 구축했던 Seorenn Note 시스템이 나쁘진 않았지만 - 아니 사실 Org Mode라는 걸출한 시스템은 마음에 들었지만 - Doom Emacs 상에서 구축되어 있어서 이를 업그레이드 할 때마다 종종 망가지는 치명적인 결함에 시달려 왔다.&lt;/p&gt;
&lt;p&gt;결국 Emacs와 의존성을 완전히 떼어내는 개인 노트 시스템이 필요해졌다. 그래서 아예 Python을 이용해 새롭게 마음대로 만들어 버렸다. &lt;/p&gt;
&lt;p&gt;다만 글 문법은 Org Mode에서 Markdown으로 바꾼다는 큰 차이가 있다. 따라서 이 시스템을 완성해도 기존의 글을 그대로 쓸 수가 없고 결국 수기로든 자동화 툴로든 바꿔야 한다는 큰 일이 남아있게 된다.&lt;/p&gt;
&lt;p&gt;거기다 이제 블로그를 통합하려는 계획까지 갖추고 있어서 갈 길이 험난하다. 과연 성공적으로 이 개인 프로젝트를 완성할 수 있을까?&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;새로운 개인용 노트 및 블로그 출력 시스템을 만들기 시작했다.&lt;/p&gt;
&lt;p&gt;기존 Emacs 상에서 구축했던 Seorenn Note 시스템이 나쁘진 않았지만 - 아니 사실 Org Mode라는 걸출한 시스템은 마음에 들었지만 - Doom Emacs 상에서 구축되어 있어서 이를 업그레이드 할 때마다 종종 망가지는 치명적인 결함에 시달려 왔다.&lt;/p&gt;
&lt;p&gt;결국 Emacs와 의존성을 완전히 떼어내는 개인 노트 시스템이 필요해졌다. 그래서 아예 Python을 이용해 새롭게 마음대로 만들어 버렸다. &lt;/p&gt;
&lt;p&gt;다만 글 문법은 Org Mode에서 Markdown으로 바꾼다는 큰 차이가 있다. 따라서 이 시스템을 완성해도 기존의 글을 그대로 쓸 수가 없고 결국 수기로든 자동화 툴로든 바꿔야 한다는 큰 일이 남아있게 된다.&lt;/p&gt;
&lt;p&gt;거기다 이제 블로그를 통합하려는 계획까지 갖추고 있어서 갈 길이 험난하다. 과연 성공적으로 이 개인 프로젝트를 완성할 수 있을까?&lt;/p&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/log/20240416-00.html</guid>
      <pubDate>Tue, 16 Apr 2024 21:00:00 +0900</pubDate>
    </item>
    <item>
      <title>간단한 파이썬 웹 서버</title>
      <link>https://seorenn.github.io/article/python-simple-web-server.html</link>
      <description>&lt;p&gt;간단한 HTML 파일 디버깅을 위해 정적 웹 서버를 띄워야 할 일이 있을 수 있다. 이럴 때는 별도의 웹 서버 설치 필요 없이 파이썬을 이용해 간단한 웹 서버를 띄울 수 있다. &lt;/p&gt;
&lt;h2&gt;http.server&lt;/h2&gt;
&lt;p&gt;아래 커맨드 한 줄이면 현재 디렉터리의 파일을 서빙하는 HTTP 웹 서버를 띄울 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m http.server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이후 웹 브라우저에서 &lt;code&gt;http://localhost:8000&lt;/code&gt; 주소로 접속하면 파일 목록이 보이거나 혹은 HTML 파일을 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;추가 옵션 예제들&lt;/h2&gt;
&lt;p&gt;아래와 같이 포트 번호나 &lt;code&gt;--bind&lt;/code&gt; 옵션을 이용해 바인딩 할 IP 주소를 지정할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m http.server 3000 --bind 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;현재 디렉터리가 아닌 다른 디렉터리를 서빙 루트로 삼고 싶다면 &lt;code&gt;--directory&lt;/code&gt; 옵션을 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m http.server --directory /foo/bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다양한 옵션이 있지만 사실 별 다른 옵션 없이 현재 디렉터리에 기본 설정으로 띄우는 것만 해도 개발 용도로는 무리가 없는 것 같다.&lt;/p&gt;
&lt;h2&gt;코드에서 띄우기&lt;/h2&gt;
&lt;p&gt;위 명령은 파이썬 패키지를 이용한 것이기 때문에 CLI 커맨드로 별도로 웹 서버를 띄우는 것뿐만 아니라 자신의 스크립트에서 웹 서버를 띄우는 것도 당연히 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from http.server import HTTPServer, SimpleHTTPRequestHandler

server = HTTPServer(('0.0.0.0', 8000), SimpleHTTPRequestHandler)
server.serve_forever()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;앞서 제일 처음 소개한 커맨드를 스크립트로 작성하면 이런 식이다.&lt;/p&gt;
&lt;h2&gt;외부 링크&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/http.server.html" target="_blank"&gt;http.server - HTTP Server📎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded>&lt;p&gt;간단한 HTML 파일 디버깅을 위해 정적 웹 서버를 띄워야 할 일이 있을 수 있다. 이럴 때는 별도의 웹 서버 설치 필요 없이 파이썬을 이용해 간단한 웹 서버를 띄울 수 있다. &lt;/p&gt;
&lt;h2&gt;http.server&lt;/h2&gt;
&lt;p&gt;아래 커맨드 한 줄이면 현재 디렉터리의 파일을 서빙하는 HTTP 웹 서버를 띄울 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m http.server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이후 웹 브라우저에서 &lt;code&gt;http://localhost:8000&lt;/code&gt; 주소로 접속하면 파일 목록이 보이거나 혹은 HTML 파일을 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;추가 옵션 예제들&lt;/h2&gt;
&lt;p&gt;아래와 같이 포트 번호나 &lt;code&gt;--bind&lt;/code&gt; 옵션을 이용해 바인딩 할 IP 주소를 지정할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m http.server 3000 --bind 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;현재 디렉터리가 아닌 다른 디렉터리를 서빙 루트로 삼고 싶다면 &lt;code&gt;--directory&lt;/code&gt; 옵션을 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m http.server --directory /foo/bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다양한 옵션이 있지만 사실 별 다른 옵션 없이 현재 디렉터리에 기본 설정으로 띄우는 것만 해도 개발 용도로는 무리가 없는 것 같다.&lt;/p&gt;
&lt;h2&gt;코드에서 띄우기&lt;/h2&gt;
&lt;p&gt;위 명령은 파이썬 패키지를 이용한 것이기 때문에 CLI 커맨드로 별도로 웹 서버를 띄우는 것뿐만 아니라 자신의 스크립트에서 웹 서버를 띄우는 것도 당연히 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from http.server import HTTPServer, SimpleHTTPRequestHandler

server = HTTPServer(('0.0.0.0', 8000), SimpleHTTPRequestHandler)
server.serve_forever()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;앞서 제일 처음 소개한 커맨드를 스크립트로 작성하면 이런 식이다.&lt;/p&gt;
&lt;h2&gt;외부 링크&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/http.server.html" target="_blank"&gt;http.server - HTTP Server📎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <guid isPermaLink="false">https://seorenn.github.io/article/python-simple-web-server.html</guid>
      <pubDate>Tue, 30 Jun 2020 21:50:00 +0900</pubDate>
    </item>
  </channel>
</rss>
