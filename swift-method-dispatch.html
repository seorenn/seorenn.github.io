<!DOCTYPE html>
<html lang="kr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Swift Method Dispatch - Seorenn Static Pages</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Heeseung Seo (Seorenn)">
<meta name="description" content="Swift에서 메소드 호출이 어떤 식으로 발생하는지를 정리">
<meta name="keywords" content="swift, method, dispatch, function">
<meta property="og:title" content="Swift Method Dispatch" />
<meta property="og:description" content="Swift에서 메소드 호출이 어떤 식으로 발생하는지를 정리" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://seorenn.github.io/img/seorenn-logo.png" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Swift Method Dispatch" />
<meta name="twitter:description" content="Swift에서 메소드 호출이 어떤 식으로 발생하는지를 정리" />
<meta name="twitter:image" content="https://seorenn.github.io/img/seorenn-logo.png" />
<meta name="twitter:site" content="@seorenn" />
<meta name="twitter:creator" content="@seorenn" />
<link rel="stylesheet" type="text/css" href="/static/style.css"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<link rel="canonical" href="https://seorenn.github.io/swift-method-dispatch.html"/>
<link property="og:url" href="https://seorenn.github.io/swift-method-dispatch.html"/>
<meta name="google-site-verification" content="YqTFZuthbvGIlDE1dhxiTjZ3m-GfyNs_rsHaOlPKpug" />
<meta name="naver-site-verification" content="ebf6a89968fd9f447c1a77d83e2c4aa9bdbb0345"/>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-44534026-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-44534026-1');
</script>
</head>
<body>
<script data-ad-client="ca-pub-1071465863344332" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<div id="content">
<header>
<h1 class="title">Swift Method Dispatch</h1>
<h2><a href="/">Seorenn Static Pages</a></h2></header>
<div id="outline-container-orge299b94" class="outline-2">
<h2 id="orge299b94">메소드 디스패치?</h2>
<div class="outline-text-2" id="text-orge299b94">
<p>
메소드 디스패치(method dispatch)란 쉽게 말해서, 특정 인스턴스의 메소드를
호출했을 때 이것을 어떻게 찾아서 점프하는지의 메커니즘을 의미합니다.
</p>

<p>
메소드 디스패치는 대략 아래와 같은 것들이 있습니다.
</p>
<ul class="org-ul">
<li>Direct Dispatch: inline 코드에 해당합니다. C/C++ 등 몇몇 지원하는 언어에서 쓰입니다.</li>
<li>Static Dispatch: 컴파일 타임에 미리 실행 지점을 파악해두는 방식으로 컴파일러에 의존적입니다.</li>
<li>Table Dispatch: 각 클래스별로 메소드 테이블을 만들어 이를 통해 메소드를
검색하는 방식으로 많은 언어에서 사용하는 방식입니다. 사실상 아래에서 이어지는
모던한 방식도 테이블 디스패치를 확장한 선으로 볼 수도 있지요.</li>
<li>Message Dispatch: 테이블 디스패치와 비슷하지만 메시지 이름을 키로 검색하는 방식입니다.
Objective-C에서 많이 쓰입니다.</li>
<li>Dynamic Dispatch: 메시지 디스패치와 거의 동일한 것으로 보입니다.</li>
</ul>
<p>
위의 정리는 확실한 것이 아니라 제가 대충 이해하고 있는 것을 간략하게 적은 것
뿐입니다.
</p>

<p>
이 글은 아직 공부 중인 내용을 포함하고 있어서 언제 어떻게 업데이트 될지 알 수가
없습니다. 읽으실 때 "어 내가 아는 것과 다른데 이 사람 뭐지?" 라고 생각되신다면
정말 제가 이상한 걸지도 모릅니다.😭
</p>
</div>
</div>
<div id="outline-container-org724b25c" class="outline-2">
<h2 id="org724b25c">상속 관계 클래스의 메소드 디스패치</h2>
<div class="outline-text-2" id="text-org724b25c">
<p>
상속으로 오버라이드 한 메소드의 경우 디스패치가 어떻게 진행되는지에 관한 예입니다.
</p>
<div class="org-src-container">
<pre class="src src-swift"><span style="color: #51afef;">class</span> <span style="color: #c678dd;">P</span> {
    <span style="color: #51afef;">func</span> <span style="color: #c678dd;">foo</span>() { ... }
}

<span style="color: #51afef;">class</span> <span style="color: #c678dd;">C</span>: P {
    <span style="color: #51afef;">override</span> <span style="color: #51afef;">func</span> <span style="color: #c678dd;">foo</span>() { ... }
}

<span style="color: #51afef;">let</span> obj1 = <span style="color: #c678dd;">C</span>()
obj1.<span style="color: #c678dd;">foo</span>()   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">C.foo()</span>

<span style="color: #51afef;">let</span> obj2: P = <span style="color: #c678dd;">C</span>()
obj2.<span style="color: #c678dd;">foo</span>()   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">C.foo()</span>
</pre>
</div>
<p>
뭐 그다지 어려울 것도 없고 당연해 보이지만, 만약 <code>obj2</code> 는 P 타입인데 어째서
C에서 오버라이드가 된 메소드가 실행되는지 궁금하다면 이 메소드 디스패치를 좀 더
공부해 보시는 편이 좋을지도 모르겠습니다. 쉽게 표현하자면, 참조하는 디스패치
테이블이 원래 생성된 인스턴스의 테이블을 우선 참조하기 때문에 가능하다고 볼 수 있겠네요.
</p>
</div>
</div>
<div id="outline-container-orga740eb0" class="outline-2">
<h2 id="orga740eb0">프로토콜의 메소드 디스패치</h2>
<div class="outline-text-2" id="text-orga740eb0">
<p>
프로토콜의 경우는 상속과는 좀 다른 면이 있습니다.
</p>
<div class="org-src-container">
<pre class="src src-swift"><span style="color: #51afef;">protocol</span> <span style="color: #c678dd;">P</span> {
    <span style="color: #51afef;">func</span> <span style="color: #c678dd;">foo</span>()
}

<span style="color: #51afef;">extension</span> <span style="color: #c678dd;">P</span> {
    <span style="color: #51afef;">func</span> <span style="color: #c678dd;">foo</span>() { ... }
    <span style="color: #51afef;">func</span> <span style="color: #c678dd;">bar</span>() { ... }
}

<span style="color: #51afef;">struct</span> <span style="color: #c678dd;">A</span>: P {
    <span style="color: #51afef;">func</span> <span style="color: #c678dd;">foo</span>() { ... }
    <span style="color: #51afef;">func</span> <span style="color: #c678dd;">bar</span>() { ... }
}

<span style="color: #51afef;">let</span> a = <span style="color: #c678dd;">A</span>()
a.<span style="color: #c678dd;">foo</span>()   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">A.foo()</span>
a.<span style="color: #c678dd;">bar</span>()   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">A.bar()</span>

<span style="color: #51afef;">let</span> p: P = <span style="color: #c678dd;">A</span>()
p.<span style="color: #c678dd;">foo</span>()   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">A.foo()</span>
p.<span style="color: #c678dd;">bar</span>()   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">P.bar()</span>
</pre>
</div>
<p>
여기서는 프로토콜의 extension으로 정의된 기본 구현체가 이 프로토콜을 따르는
구조체의 동일한 이름의 구현체보다 높은 우선순위를 가지고 있다는 것을 알 수 있습니다.
다르게 말하자면 extension 의 디스패치 테이블이 A 구조체의 테이블보다 우선
검색된다는 말이겠지요.
이 부분은 아무래도 클래스 상속과는 다르기 때문에 주의가 필요할 것 같습니다.
</p>
</div>
</div>
<div id="outline-container-orgc1a3b22" class="outline-2">
<h2 id="orgc1a3b22">지시어</h2>
<div class="outline-text-2" id="text-orgc1a3b22">
</div>
<div id="outline-container-org947739b" class="outline-3">
<h3 id="org947739b">final</h3>
<div class="outline-text-3" id="text-org947739b">
<p>
클래스의 경우 이 <code>final</code> 이 붙게 되면 더이상 상속이 되지 않습니다. 이 말은
메소드 디스패치에도 영향을 주게 되어서 여러 이점이 있을 수 있습니다. 예를 들어
불필요한 테이블을 검색할 필요가 없어져서 퍼포먼스 이점이 있을 수도 있지요.
</p>

<p>
약간 전문적으로 말해서, final class는 다이나믹 디스패치 기능을 없애버립니다. 뭐
그러니 빨라지겠지요.
</p>
</div>
</div>
<div id="outline-container-org038c957" class="outline-3">
<h3 id="org038c957">dynamic</h3>
<div class="outline-text-3" id="text-org038c957">
<p>
<code>final</code> 과 반대되는 것 같은 <code>dynamic</code> 은 정말 반대되는 의미입니다. 다이나믹이
되면 순수 <a href="swift.html">Swift</a> 인스턴스가 아니게 됩니다. <code>NSObject</code> 를
상속받은 것과 비슷한 상태가 되지요. 이 말은 무거워지고 느려지게 됩니다. 대신
메시지 디스패치를 사용할 수 있어서 KVO(Key-Value Observing)가 가능해지게 됩니다.
</p>
</div>
</div>
<div id="outline-container-orgde602e9" class="outline-3">
<h3 id="orgde602e9"><code>@objc</code></h3>
<div class="outline-text-3" id="text-orgde602e9">
<p>
<code>@objc</code> 지시어는 Objective-C 네임스페이스에 등록시켜서 메시지 디스패치가
가능하게 해 줍니다. 반대로 <code>@noobjc</code> 는 메시지 디스패치를 못 하게 막아버리지요.
</p>
</div>
</div>
<div id="outline-container-orgb7fe593" class="outline-3">
<h3 id="orgb7fe593"><code>@inline</code></h3>
<div class="outline-text-3" id="text-orgb7fe593">
<p>
인라인(inline)은 말 그대로 호출을 하지 않고 컴파일 타임에 아예 구현체를 그대로
넣어버리는 무시무시한(?) 다이렉트 디스패치와 비슷한 것을 적용합니다.
</p>
</div>
</div>
</div>
<div id="outline-container-org3ee250e" class="outline-2">
<h2 id="org3ee250e">관련글</h2>
<div class="outline-text-2" id="text-org3ee250e">
<ul class="org-ul">
<li><a href="swift.html">Swift</a></li>
</ul>
</div>
</div>
<div id="footer"><div id="time">2019년 12월 23일 마지막으로 수정됨</div><div id="copyright">Copyright 2019 Heeseung Seo (Seorenn)</div></div></div>
</body>
</html>
