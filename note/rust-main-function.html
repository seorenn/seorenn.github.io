<!DOCTYPE html><html lang="ko"><head><meta charset="utf-8"><meta name="viewport"content="width=device-width,initial-scale=1"><meta http-equiv="Content-Type"content="text/html; charset=UTF-8"><link rel="stylesheet"href="/static/style.min.css"><meta name="battery-savings"content="allow-reduced-framerate allow-reduced-script-speed"><title>Rust의 시작점 main 함수 - Seorenn Note</title><meta name="twitter:title"content="Rust의 시작점 main 함수"><meta name="og:title"content="Rust의 시작점 main 함수"><meta name="description"content="Rust의 엔트리포인트가 되는 main 함수에 대해 정리해보자"><meta name="twitter:description"content="Rust의 엔트리포인트가 되는 main 함수에 대해 정리해보자"><meta name="og:description"content="Rust의 엔트리포인트가 되는 main 함수에 대해 정리해보자"><link rel="canonical"href="https://seorenn.github.io/note/rust-main-function.html"><meta property="og:url"content="https://seorenn.github.io/note/rust-main-function.html"><link rel="shortcut icon"type="image/x-icon"href="/static/favicon.ico"><meta name="twitter:image"content="https://seorenn.github.io/static/seorenn-symbol.png"><meta property="og:image"content="https://seorenn.github.io/static/seorenn-symbol.png"><meta property="og:image:width"content="520"><meta property="og:image:height"content="329"><meta name="twitter:card"content="summary"><meta name="twitter:site"content="@seorenn"><meta name="twitter:creator"content="@seorenn"><meta property="og:type"content="article"><meta property="og:site_name"content="Seorenn"><meta property="og:locale"content="ko_KR"><meta name="referrer"content="unsafe-url"><meta name="robots"content="follow,index"><meta name="google-site-verification"content="YqTFZuthbvGIlDE1dhxiTjZ3m-GfyNs_rsHaOlPKpug"><meta name="naver-site-verification"content="24609571c04926ab1220d5d02610efa1c9e12221"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1071465863344332"crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-N5PL2YB2ZH"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-N5PL2YB2ZH")</script></head><body><div class="header-content"><header class="top-header"><div class="logo-container"><span class="vertical-center-helper"></span> <a href="/"title="Seorenn"><img class="site-logo"src="/static/seorenn-note-logo-light.png"alt="Seorenn Note"></a><nav><span class="vertical-center-helper"></span> <a href="/"title="Home">HOME</a> | <a href="/note"title="All Notes">NOTES</a> | <a href="https://seorenn.tistory.com"title="Blog"target="_blank">LOGS</a></nav></div></header></div><div class="content-container"><section class="content"><div class="mid-ad-container"><ins class="adsbygoogle mid-ad"style="display:block"data-ad-client="ca-pub-1071465863344332"data-ad-slot="4306465772"data-ad-format="auto"data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><header><h1>Rust의 시작점 main 함수</h1><div class="title-date">2020년 7월 20일 수정</div></header><div id="table-of-contents"role="doc-toc"><h2>≡ 목차 (Table of Contents)</h2><div id="text-table-of-contents"role="doc-toc"><ul><li><a href="#854ad248">main 함수</a></li><li><a href="#d1fc8fc1">리턴 타입이 없다?</a></li><li><a href="#67106d3f">리턴 타입이 있을 수도 있다</a></li><li><a href="#7101b5bf">파라미터(Parameter or Arguments)</a></li></ul></div></div><p><a href="c-language.html">C 언어</a>의 시작점과 동일하게 <a href="rust.html">Rust</a>도 <code>main</code> 이라는 이름의 함수가 시작점이 된다. 이 main 함수과 관련된 내용을 정리해보자.</p><div id="outline-container-854ad248"class="outline-2"><h2 id="854ad248">main 함수</h2><div class="outline-text-2"id="text-854ad248"><p>프로그램이 시작되는 지점은 main 이라는 이름을 가진 함수다.</p><div class="org-src-container"><pre class="src src-rust"><span style="color:#51afef">fn</span> <span style="color:#c678dd">main</span><span style="color:#51afef">()</span> <span style="color:#51afef">{</span>
    ...
<span style="color:#51afef">}</span>
</pre></div><p>말 그대로 메인 함수다. 독자 실행형 소프트웨어라면 반드시 이 함수가 시작점에 해당한다. 이 정도면 왠만한 경우에도 별 무리 없는 시작점으로 활용 가능한 함수다.</p></div></div><div id="outline-container-d1fc8fc1"class="outline-2"><h2 id="d1fc8fc1">리턴 타입이 없다?</h2><div class="outline-text-2"id="text-d1fc8fc1"><p><a href="c-language.html">C 언어</a>에 익숙하다면 main 함수는 리턴 타입을 가질 수 있다는 것을 알고 있을 것이다.</p><div class="org-src-container"><pre class="src src-c++"><span style="color:#ecbe7b">int</span> <span style="color:#c678dd">main</span><span style="color:#51afef">()</span> <span style="color:#51afef">{</span>
    <span style="color:#51afef">return</span> <span style="color:#da8548;font-weight:700">0</span>;  <span style="color:#5b6268">// </span><span style="color:#5b6268">Ok</span>
<span style="color:#51afef">}</span>
</pre></div><p>참고로 유닉스 혹은 유닉스에서 유래한 OS에서 명령의 실행 결과는 전통적으로 0이 성공을 의미한다.</p><p>그런데 특이하게도 <a href="rust.html">Rust</a> 가이드 글들의 main 함수는 하나같이 아래와 같은 모양만 보인다.</p><div class="org-src-container"><pre class="src src-rust"><span style="color:#51afef">fn</span> <span style="color:#c678dd">main</span><span style="color:#51afef">()</span> <span style="color:#51afef">{</span>
    ...
<span style="color:#51afef">}</span>
</pre></div><p>리턴 타입도 없으므로 당연히 <code>return</code> 문도 사용하지 않는다.</p><p>사실 <a href="rust.html">Rust</a>의 main 함수는 별 다른 오류가 없었다면 성공한 것으로 간주하고 정상(0) 코드를 리턴한다. 그래서 아무 리턴이 없었더라도 <a href="shell.html">셸</a> 스크립트에서도 성공으로 간주하여 동작하는 것을 볼 수 있다.</p><p>아래는 <code>&amp;&amp;</code> 을 이용해 위의 리턴이 없는 main 함수를 가진 코드를 빌드한 <code>someproj</code> 라는 실행 파일로 시험한 예이다.</p><div class="org-src-container"><pre class="src src-bash">$ target/debug/someproj &amp;&amp; <span style="color:#ecbe7b">echo</span> <span style="color:#98be65">"Ok"</span>
Ok
</pre></div><p><code>&amp;&amp;</code> 은 앞의 명령이 성공하면 그 뒤의 명령을 실행시키는 <a href="shell.html">셸</a> 오퍼레이터다. 즉 <code>someproj</code> 명령이 성공(0)을 리턴했다는 말이다.</p><p>그렇다면 반대로 뭔가 런타임 에러가 발생되는 케이스는 어떻게 될까? 일부러 아래와 같은 코드를 작성해봤다.</p><div class="org-src-container"><pre class="src src-rust"><span style="color:#51afef">use</span> <span style="color:#a9a1e1">std</span>::<span style="color:#a9a1e1">fs</span>::<span style="color:#ecbe7b">File</span>;

<span style="color:#51afef">fn</span> <span style="color:#c678dd">main</span><span style="color:#51afef">()</span> <span style="color:#51afef">{</span>
    <span style="color:#ecbe7b">File</span>::open<span style="color:#c678dd">(</span><span style="color:#98be65">"unknown_file.txt"</span><span style="color:#c678dd">)</span>.expect<span style="color:#c678dd">(</span><span style="color:#98be65">"File not found"</span><span style="color:#c678dd">)</span>;
<span style="color:#51afef">}</span>
</pre></div><p>없는 파일을 열려고 하니 에러가 발생할거다. 그래서 <code>expect</code> 가 이걸 붙잡고 오류를 내면서 종료시킬 것이다.</p><div class="org-src-container"><pre class="src src-bash">$ target/debug/someproj
thread <span style="color:#98be65">'main'</span> panicked at <span style="color:#98be65">'File not found: Os { code: 2, kind: NotFound, message: "No such file or directory" }'</span>, src/main.rs:4:5
note: run with <span style="color:#51afef;font-weight:700">`RUST_BACKTRACE=1`</span> environment variable to display a backtrace
</pre></div><p>그리고 당연히 이 결과는 실패한 것으로 간주된다.</p><div class="org-src-container"><pre class="src src-bash">$ target/debug/someproj &amp;&amp; <span style="color:#ecbe7b">echo</span> <span style="color:#98be65">"Ok"</span>
thread <span style="color:#98be65">'main'</span> panicked at <span style="color:#98be65">'File not found: Os { code: 2, kind: NotFound, message: "No such file or directory" }'</span>, src/main.rs:4:5
note: run with <span style="color:#51afef;font-weight:700">`RUST_BACKTRACE=1`</span> environment variable to display a backtrace
$ <span style="color:#ecbe7b">echo</span> $<span style="color:#dcaeea">?</span>
<span style="color:#da8548;font-weight:700">101</span>
</pre></div><p><code>Ok</code> 가 표시되지 않았다. 그리고 실제로 리턴된 결과도 101이었다. 참고로 <a href="shell.html">셸</a>에서 위처럼 <code>$?</code> 를 이용해 마지막으로 실행시킨 커맨드의 실행 결과를 알 수 있다.</p></div></div><div id="outline-container-67106d3f"class="outline-2"><h2 id="67106d3f">리턴 타입이 있을 수도 있다</h2><div class="outline-text-2"id="text-67106d3f"><p>위에서는 없다고 했는데 사실 main 함수는 리턴 타입을 가질 수 있다. 다만 특이하게도 유닉스 스럽지 않게 <code>Result</code> 타입을 리턴하도록 강제된다.</p><div class="org-src-container"><pre class="src src-rust"><span style="color:#51afef">fn</span> <span style="color:#c678dd">main</span><span style="color:#51afef">()</span> -&gt; <span style="color:#ecbe7b">Result</span><span style="color:#51afef">&lt;</span><span style="color:#c678dd">()</span>, <span style="color:#ecbe7b">i32</span><span style="color:#51afef">&gt;</span> <span style="color:#51afef">{</span>
    <span style="color:#5b6268">// </span><span style="color:#5b6268">...</span>
    <span style="color:#ecbe7b">Ok</span><span style="color:#c678dd">(</span><span style="color:#98be65">()</span><span style="color:#c678dd">)</span>
<span style="color:#51afef">}</span>
</pre></div><p>위의 코드는 성공으로 간주하고 끝난다. 유닉스 기반의 소프트웨어들은 모두 성공 시 0을 리턴하는 게 관습처럼 정해져있기 때문에 성공시에는 별 다른 값 없이 <code>Ok(())</code> 만을 리턴하면 알아서 0을 리턴하는 것으로 보인다.</p><div class="org-src-container"><pre class="src src-bash">$ target/debug/someproj &amp;&amp; <span style="color:#ecbe7b">echo</span> <span style="color:#98be65">"Ok"</span>
Ok
</pre></div><p>예상대로 문제 없이 동작한다.</p><p>자 그렇다면 에러를 리턴해야 하는 상황은 어떨까? <code>Result</code> 타입을 사용하므로 에러일 때는 당연하게도 <code>Err()</code> 을 리턴하면 될 것이다.</p><div class="org-src-container"><pre class="src src-rust"><span style="color:#51afef">fn</span> <span style="color:#c678dd">main</span><span style="color:#51afef">()</span> -&gt; <span style="color:#ecbe7b">Result</span><span style="color:#51afef">&lt;</span><span style="color:#c678dd">()</span>, <span style="color:#ecbe7b">i32</span><span style="color:#51afef">&gt;</span> <span style="color:#51afef">{</span>
    <span style="color:#5b6268">// </span><span style="color:#5b6268">...</span>
    <span style="color:#ecbe7b">Err</span><span style="color:#c678dd">(</span><span style="color:#da8548;font-weight:700">1</span><span style="color:#c678dd">)</span>
<span style="color:#51afef">}</span>
</pre></div><p>위 코드가 실행되면 <code>Error: 1</code> 이라는 것이 화면에 표시되면서 종료되는 특징이 있다. 어쨌든 이번에도 셸로 명령어 연결을 시도해보자.</p><div class="org-src-container"><pre class="src src-bash">$ target/debug/someproj &amp;&amp; <span style="color:#ecbe7b">echo</span> <span style="color:#98be65">"Ok"</span>
Error: <span style="color:#da8548;font-weight:700">1</span>
</pre></div><p>이번에는 <code>Ok</code> 가 화면에 찍히지 않는다. 즉 <code>someproj</code> 가 에러를 리턴하고 종료되었다는 말이다. 아마도 제대로 이해한 것 같다.</p><p>셸에서 리턴 코드를 확인해보면 동일하게 1이 리턴된 것을 알 수 있다.</p><div class="org-src-container"><pre class="src src-bash">$ target/debug/someproj
Error: <span style="color:#da8548;font-weight:700">1</span>
$ <span style="color:#ecbe7b">echo</span> $<span style="color:#dcaeea">?</span>
<span style="color:#da8548;font-weight:700">1</span>
</pre></div><p><code>Result</code> 타입은 generic이기 때문에 리턴되는 타입 자체가 유동적이다. 아래와 같이 에러를 리턴하는 방식도 쓸 수 있다.</p><div class="org-src-container"><pre class="src src-rust"><span style="color:#51afef">use</span> <span style="color:#a9a1e1">std</span>::<span style="color:#a9a1e1">io</span>::<span style="color:#ecbe7b">Error</span>;

<span style="color:#51afef">fn</span> <span style="color:#c678dd">main</span><span style="color:#51afef">()</span> -&gt; <span style="color:#ecbe7b">Result</span><span style="color:#51afef">&lt;</span><span style="color:#c678dd">()</span>, <span style="color:#a9a1e1">std</span>::<span style="color:#a9a1e1">io</span>::<span style="color:#ecbe7b">Error</span><span style="color:#51afef">&gt;</span> <span style="color:#51afef">{</span>
    <span style="color:#5b6268">// </span><span style="color:#5b6268">...</span>
    <span style="color:#ecbe7b">Err</span><span style="color:#c678dd">(</span><span style="color:#ecbe7b">Error</span>::from_raw_os_error<span style="color:#98be65">(</span><span style="color:#da8548;font-weight:700">1</span><span style="color:#98be65">)</span><span style="color:#c678dd">)</span>
<span style="color:#51afef">}</span>
</pre></div><p>이 외에 모듈에서 정의된 다양한 에러타입도 사용되는 것 같다.</p></div></div><div id="outline-container-7101b5bf"class="outline-2"><h2 id="7101b5bf">파라미터(Parameter or Arguments)</h2><div class="outline-text-2"id="text-7101b5bf"><p>다시 <a href="c-language.html">C 언어</a>와 비교해보자. <a href="c-language.html">C 언어</a> main 함수의 기본 형태는 대체로 아래와 같은 식으로 arguments 목록을 얻기 위한 매개변수를 정의한다.</p><div class="org-src-container"><pre class="src src-c++"><span style="color:#ecbe7b">int</span> <span style="color:#c678dd">main</span><span style="color:#51afef">(</span><span style="color:#ecbe7b">int</span> <span style="color:#dcaeea">argc</span>, <span style="color:#ecbe7b">char</span> *<span style="color:#dcaeea">argv</span><span style="color:#c678dd">[]</span><span style="color:#51afef">)</span> <span style="color:#51afef">{</span>
    <span style="color:#5b6268">// </span><span style="color:#5b6268">...</span>
<span style="color:#51afef">}</span>
</pre></div><p>하지만 <a href="rust.html">Rust</a>의 main 함수 예제에선 저런 파라미터 처리를 위한 매개변수를 전달받는 예제를 전혀 볼 수 있다.</p><p>이유는 단순하다. 파라미터(arguments) 전달 방식이 다르기 때문이다.</p><div class="org-src-container"><pre class="src src-rust"><span style="color:#51afef">use</span> <span style="color:#a9a1e1">std</span>::env;

<span style="color:#51afef">fn</span> <span style="color:#c678dd">main</span><span style="color:#51afef">()</span> <span style="color:#51afef">{</span>
    <span style="color:#51afef">let</span> <span style="color:#dcaeea">args</span>: <span style="color:#ecbe7b">Vec</span><span style="color:#c678dd">&lt;</span><span style="color:#ecbe7b">String</span><span style="color:#c678dd">&gt;</span> = <span style="color:#a9a1e1">env</span>::args<span style="color:#c678dd">()</span>.collect<span style="color:#c678dd">()</span>;
    <span style="color:#c678dd">println!</span><span style="color:#c678dd">(</span><span style="color:#98be65">"</span><span style="color:#98be65;font-style:italic">{:?}</span><span style="color:#98be65">"</span>, args<span style="color:#c678dd">)</span>;
<span style="color:#51afef">}</span>
</pre></div><p><code>std::env::args</code> 를 이용해 파라미터(arguments)를 받아올 수 있다. 실행시켜보면 아래와 같은 결과를 얻을 수 있다.</p><div class="org-src-container"><pre class="src src-bash">$ target/debug/someproj param1 param2 param3
<span style="color:#51afef">[</span><span style="color:#98be65">"target/debug/someproj"</span>, <span style="color:#98be65">"param1"</span>, <span style="color:#98be65">"param2"</span>, <span style="color:#98be65">"param3"</span><span style="color:#51afef">]</span>
</pre></div><p>첫 파라미터는 자기자신이고, 나머지는 공백을 기준으로 나눠진 파라미터 리스트(Vec)로 얻을 수 있다. 다른 언어에서 다뤄봤다면 매우 익숙하게 느껴질 것이다.</p><p>참고로 저렇게 빌드해서 실행하는 게 귀찮다면 <a href="cargo.html">Cargo</a>의 <code>run</code> 커맨드에서도 파라미터를 줄 수 있으니 멀리 돌아가지 않아도 된다.</p><div class="org-src-container"><pre class="src src-bash">$ cargo run param1 param2 param3
    Finished dev <span style="color:#51afef">[</span>unoptimized + debuginfo<span style="color:#51afef">]</span> target<span style="color:#51afef">(</span>s<span style="color:#51afef">)</span> <span style="color:#51afef">in</span> 0.00s
     Running <span style="color:#51afef;font-weight:700">`target/debug/someproj param1 param2 param3`</span>
<span style="color:#51afef">[</span><span style="color:#98be65">"target/debug/someproj"</span>, <span style="color:#98be65">"param1"</span>, <span style="color:#98be65">"param2"</span>, <span style="color:#98be65">"param3"</span><span style="color:#51afef">]</span>
</pre></div><p>어쨌거나 파라미터를 벡터 타입으로 받아왔기 때문에 갯수나 각 파라미터를 얻는 과정이 어렵지는 않을 것이다.</p><div class="org-src-container"><pre class="src src-rust"><span style="color:#51afef">use</span> <span style="color:#a9a1e1">std</span>::env;

<span style="color:#51afef">fn</span> <span style="color:#c678dd">main</span><span style="color:#51afef">()</span> <span style="color:#51afef">{</span>
    <span style="color:#51afef">let</span> <span style="color:#dcaeea">args</span>: <span style="color:#ecbe7b">Vec</span><span style="color:#c678dd">&lt;</span><span style="color:#ecbe7b">String</span><span style="color:#c678dd">&gt;</span> = <span style="color:#a9a1e1">env</span>::args<span style="color:#c678dd">()</span>.collect<span style="color:#c678dd">()</span>;
    <span style="color:#c678dd">println!</span><span style="color:#c678dd">(</span><span style="color:#98be65">"Total </span><span style="color:#98be65;font-style:italic">{}</span><span style="color:#98be65"> arguments"</span>, <span style="color:#bbc2cf;background-color:#f1f1f1">&amp;</span>args.len<span style="color:#98be65">()</span><span style="color:#c678dd">)</span>;
    <span style="color:#51afef">for</span> <span style="color:#dcaeea">param</span> <span style="color:#51afef">in</span> <span style="color:#bbc2cf;background-color:#f1f1f1">&amp;</span>args <span style="color:#c678dd">{</span>
        <span style="color:#c678dd">println!</span><span style="color:#98be65">(</span><span style="color:#98be65">"</span><span style="color:#98be65;font-style:italic">{}</span><span style="color:#98be65">"</span>, param<span style="color:#98be65">)</span>;
    <span style="color:#c678dd">}</span>
<span style="color:#51afef">}</span>
</pre></div><p>굳이 실행 결과가 필요할지는 의문이지만 대충 이렇게 된다.</p><div class="org-src-container"><pre class="src src-bash">$ target/debug/someproj param1 param2 param3
Total <span style="color:#da8548;font-weight:700">4</span> arguments
target/debug/someproj
param1
param2
param3
</pre></div><p>뭐 아마도 이걸 그대로 쓰기 보다는 별도의 옵션 처리를 도와줄 패키지를 이용하는 편이 더 많겠지만 기본적인 지식은 알아두는 편이 좋을 지도 모르겠다.</p></div></div><div class="mid-ad-container"><ins class="adsbygoogle mid-ad"style="display:block"data-ad-client="ca-pub-1071465863344332"data-ad-slot="4306465772"data-ad-format="auto"data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class="backlinks-container"><hr><h2>이 글을 링크하는 글들</h2><div class="article-link"><div class="article-link-title-block"><h2><a class="article-link-title"href="/note/rust.html">❏ Rust</a></h2><span class="article-description">The Rust Programming Language</span><span class="article-link-date"> Updated on 2023년 5월 15일</span></div></div></div></section></div><div class="footer-content"><footer>Copyright 2019 ~ 2020. Seorenn all rights reserved.</footer></div></body></html>